<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinHub - Finley Chang</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #0d1117;
            min-height: 100vh;
            padding: 20px;
        }
        
        .page {
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .page.hidden {
            display: none;
        }
        
        .home-page {
            text-align: center;
        }
        
        .home-page h1 {
            color: #c9d1d9;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .home-page p {
            color: #8b949e;
            font-size: 18px;
        }
        
        .home-page a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 20px;
            margin-top: 20px;
            display: inline-block;
            padding: 12px 24px;
            border: 1px solid #58a6ff;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .home-page a:hover {
            background: rgba(88, 166, 255, 0.1);
            color: #79c0ff;
            transform: translateY(-2px);
        }
        
        /* Minesweeper game styles */
        .minesweeper-page {
            background-color: #eee;
            font-family: Arial, sans-serif;
        }
        
        #minesweeper-game-container {
            display: inline-block;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
        }
        
        .minesweeper-grid {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
        }
        
        .cell {
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            background-color: #d1d1d1;
            border: 1px solid transparent;
            border-color: #fff #808080 #808080 #fff;
        }
        
        .cell.revealed {
            background-color: #c0c0c0;
            border: 1px solid #808080;
            border-color: #808080 #fff #fff #808080;
        }
        
        .cell.flag {
            color: red;
            font-size: 18px;
        }
        
        .cell.mine {
            background-color: red;
            color: black;
        }
        
        .cell.number-1 { color: blue; }
        .cell.number-2 { color: green; }
        .cell.number-3 { color: red; }
        .cell.number-4 { color: darkblue; }
        .cell.number-5 { color: darkred; }
        .cell.number-6 { color: teal; }
        .cell.number-7 { color: black; }
        .cell.number-8 { color: gray; }
        
        #message {
            margin-top: 5px;
            font-size: 20px;
            font-weight: bold;
            height: 25px;
            color: #333;
        }
        
        #restart-btn {
            padding: 8px 15px;
            margin-bottom: 15px;
            font-size: 16px;
            cursor: pointer;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
            background-color: #d1d1d1;
            font-weight: bold;
        }
        
        #restart-btn:active {
            border-top: 4px solid #808080;
            border-left: 4px solid #808080;
            border-bottom: 4px solid #fff;
            border-right: 4px solid #fff;
        }
        
        /* Pong game styles */
        .pong-page {
            background-color: #1a1a1a;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            color: white;
        }
        
        #pongCanvas {
            border: 4px solid #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            background-color: #000;
        }
        
        .pong-info {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .pong-button-style {
            transition: all 0.1s;
            box-shadow: 0 4px #2c2c2c;
            position: relative;
            top: 0;
        }
        
        .pong-button-style:active {
            box-shadow: 0 0 #2c2c2c;
            top: 4px;
        }
        
        .pong-settings-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .pong-settings-modal.hidden {
            display: none;
        }
        
        .pong-settings-content {
            background: #1f2937;
            padding: 24px;
            border-radius: 12px; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 320px;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content h3 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
            color: white;
            text-align: center;
        }
        
        .pong-settings-content label {
            display: block;
            color: #e5e7eb;
            margin-bottom: 4px;
        }
        
        .pong-settings-content select,
        .pong-settings-content input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: #111827;
            color: white;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content select:focus,
        .pong-settings-content input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 1px white;
        }
        
        .pong-settings-content button {
            width: 100%;
            margin-top: 16px;
        }
        
        /* Sandboxels page styles */
        .sandboxels-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            background-color: white;
            border: none;
            display: flex;
            flex-direction: column;
        }
        
        .sandboxels-iframe {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            padding: 0;
        }
        
        .sandboxels-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100000;
            padding: 10px 15px;
            background-color: #d9534f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .sandboxels-close-btn:hover {
            background-color: #c9302c;
        }
        
        /* Coinflip page styles */
        .coinflip-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        .coinflip-page button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .coinflip-page button:active {
            transform: scale(0.95);
        }
        
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(900deg); }
            100% { transform: rotateY(1800deg); }
        }
        
        .coin-flipping {
            animation: coinFlip 1s ease-in-out;
        }
        
        /* Jumpscare overlay */
        .jumpscare-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
        }
        
        .jumpscare-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .jumpscare-overlay.active .jumpscare-image {
            animation: jumpscarePop 0.3s ease-out, jumpscareFade 0.5s ease-in 0.8s forwards;
        }
        
        .jumpscare-image {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            transform: scale(0.1);
            opacity: 0;
        }
        
        @keyframes jumpscarePop {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes jumpscareFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.9);
            }
        }
        
        /* Visual Effects CSS */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, -5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, 5px); }
        }
        
        .spin-effect {
            animation: spin 1s ease-in-out;
        }
        
        .shake-effect {
            animation: shake 0.5s ease-in-out;
        }
        
        .invert-effect {
            filter: invert(1);
        }
        
        .upsidedown-effect {
            transform: rotate(180deg);
        }
        
        .matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            pointer-events: none;
        }
        
        .confetti-particle {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10001;
        }
        
        /* Shop page styles */
        .shop-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .upgrade-item {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 20px;
            margin: 15px auto;
            max-width: 400px;
            color: #c9d1d9;
        }
        
        .upgrade-item h3 {
            color: #58a6ff;
            margin: 0 0 10px 0;
            font-size: 20px;
        }
        
        .upgrade-item p {
            margin: 5px 0;
            font-size: 14px;
            color: #8b949e;
        }
        
        .upgrade-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upgrade-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .upgrade-btn:disabled {
            background: #30363d;
            color: #8b949e;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Limbo page styles */
        .limbo-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Panic menu page styles */
        .panicmenu-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Achievements page styles */
        .achievements-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            grid-template-rows: repeat(16, 32px);
            gap: 4px;
            background: #161b22;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #30363d;
            margin: 20px auto;
            max-width: fit-content;
        }
        
        .achievement-sprite {
            width: 32px;
            height: 32px;
            border: 2px solid #30363d;
            border-radius: 4px;
            background: #21262d;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: grid;
            grid-template-columns: repeat(16, 2px);
            grid-template-rows: repeat(16, 2px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            filter: grayscale(100%) brightness(0.3);
        }
        
        .achievement-sprite.found {
            filter: none;
            border-color: #58a6ff;
            background: #161b22;
        }
        
        .pixel {
            width: 2px;
            height: 2px;
        }
        
        /* Clicker page styles */
        .clicker-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        #clicker-button:active {
            transform: scale(0.95);
        }
        
        #clicker-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(35, 134, 54, 0.5);
        }
        
        .achievement-sprite:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.5);
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .achievement-sprite:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-tooltip .tooltip-name {
            font-weight: bold;
            color: #58a6ff;
            margin-bottom: 4px;
            display: block;
        }
        
        .achievement-tooltip .tooltip-desc {
            color: #8b949e;
            font-size: 11px;
            white-space: normal;
            max-width: 200px;
            text-align: left;
        }
        
        .finhub-title {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .big-letter {
            display: grid;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            color: #c9d1d9;
            gap: 0;
        }
        
        .big-letter .small-letter {
            display: inline-block;
            width: 8px;
            height: 8px;
            text-align: center;
        }
        
        /* Big F made of small letters - 3 thick, 2x tall */
        .letter-f {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big i made of small letters - 3 thick, 2x tall */
        .letter-i {
            grid-template-columns: repeat(9, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big n made of small letters - 3 thick, 2x tall */
        .letter-n {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big H made of small letters - 3 thick, 2x tall */
        .letter-h {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big u made of small letters - 3 thick, 2x tall */
        .letter-u {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big b made of small letters - 3 thick, 2x tall */
        .letter-b {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Colors for small letters */
        .small-letter.f { color: #58a6ff; }
        .small-letter.i { color: #f0883e; }
        .small-letter.n { color: #bc8cff; }
        .small-letter.l { color: #3fb950; }
        .small-letter.e { color: #f85149; }
        .small-letter.y { color: #ffa657; }
        
        .subtitle {
            color: #8b949e;
            font-size: 18px;
            text-align: center;
            margin-top: 20px;
        }
        
        .letters-source {
            color: #6e7681;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        /* Clock display in top left */
        .clock-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 15px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .clock-display.hidden {
            display: none;
        }
        
        /* Command feedback display */
        .command-feedback {
            position: fixed;
            bottom: 70px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 400px;
            z-index: 998;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-feedback.hidden {
            display: none;
        }
        
        .command-feedback .command-text {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-feedback .feedback-text {
            color: #8b949e;
            margin-left: 8px;
        }
        
        /* Command bar in bottom left */
        .command-bar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-bar::before {
            content: '>';
            color: #58a6ff;
            font-weight: bold;
        }
        
        /* Pet goose styling */
        .pet-goose {
            position: fixed;
            bottom: 100px;
            left: 20px;
            width: 60px;
            height: 60px;
            font-size: 50px;
            z-index: 99;
            pointer-events: none;
            user-select: none;
            transition: transform 0.2s;
        }
        
        .pet-goose:hover {
            transform: scale(1.1);
        }
        
        .pet-goose.hidden {
            display: none;
        }
        
        .command-input {
            background: transparent;
            border: none;
            outline: none;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex: 1;
        }
        
        .command-input::placeholder {
            color: #6e7681;
        }
        
        /* Commands menu - draggable tab */
        .commands-menu {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            right: -300px;
            width: 300px;
            max-height: 500px;
            background: rgba(13, 17, 23, 0.98);
            border: 1px solid #30363d;
            border-right: none;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .commands-menu.open {
            right: 0;
        }
        
        .commands-menu.dragging {
            transform: none;
            transition: none;
        }
        
        .commands-menu-header {
            background: #161b22;
            padding: 12px 16px;
            border-bottom: 1px solid #30363d;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .commands-menu-header h3 {
            color: #c9d1d9;
            font-size: 16px;
            margin: 0;
        }
        
        .commands-menu-close {
            background: none;
            border: none;
            color: #8b949e;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .commands-menu-close:hover {
            color: #c9d1d9;
        }
        
        .commands-list {
            padding: 16px;
        }
        
        .command-category {
            margin-bottom: 20px;
        }
        
        .command-category h4 {
            color: #58a6ff;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .command-item {
            color: #c9d1d9;
            font-size: 13px;
            padding: 6px 0;
            font-family: 'Courier New', monospace;
        }
        
        .command-item .command-name {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-item .command-desc {
            color: #8b949e;
            margin-left: 8px;
        }
        
        @media (max-width: 768px) {
            .finhub-title {
                font-size: 48px;
            }
            .command-bar {
                min-width: 200px;
                bottom: 10px;
                left: 10px;
            }
            .commands-menu {
                width: 250px;
                right: -250px;
            }
        }
    </style>
</head>
<body>
    <!-- Main page with FinHub title -->
    <div class="page" id="mainPage">
        <div class="finhub-title">
            <!-- Big F made of small letters -->
            <div class="big-letter letter-f" id="letter-f"></div>
            <!-- Big i made of small letters -->
            <div class="big-letter letter-i" id="letter-i"></div>
            <!-- Big n made of small letters -->
            <div class="big-letter letter-n" id="letter-n"></div>
            <!-- Big H made of small letters -->
            <div class="big-letter letter-h" id="letter-h"></div>
            <!-- Big u made of small letters -->
            <div class="big-letter letter-u" id="letter-u"></div>
            <!-- Big b made of small letters -->
            <div class="big-letter letter-b" id="letter-b"></div>
        </div>
        
        <p class="subtitle">Built with code, powered by Finley</p>
        <p class="letters-source">Spelled with letters from: F-I-N-L-E-Y</p>
        <!-- Canvas for wooperbird goose on main page -->
        <canvas id="wooperbirdCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></canvas>
                </div>
        
        <!-- Pet goose (persistent, bottom left) -->
        <div id="petGoose" class="pet-goose hidden">ü¶¢</div>
    
    <!-- Home page -->
    <div class="page home-page hidden" id="homePage">
        <h1>Welcome to the home</h1>
        <p>Type "back" in the command bar to return</p>
        <a href="https://sso.browardschools.com/" target="_blank">Broward Schools Login</a>
            </div>
    
    <!-- Minesweeper page -->
    <div class="page minesweeper-page hidden" id="minesweeperPage" oncontextmenu="return false;">
        <button id="restart-btn">Restart Game</button>
        <div id="message">Flags Remaining: 10</div>
        <div id="minesweeper-game-container">
            <div class="minesweeper-grid" id="minesweeper-grid"></div>
        </div>
    </div>

    <!-- Pong page -->
    <div class="page sandboxels-page hidden" id="pongPage">
        <iframe id="pong-iframe" class="sandboxels-iframe" src="https://web-pong.com/" name="pong_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closePong()">X CLOSE VIEW (Return to finleychang.com)</button>
                    </div>
    
    <!-- Sandboxels page -->
    <div class="page sandboxels-page hidden" id="sandboxelsPage">
        <iframe id="sandboxels-iframe" class="sandboxels-iframe" src="https://shalbito.vercel.app/" name="sandboxels_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closeSandboxels()">X CLOSE VIEW (Return to finleychang.com)</button>
        </div>
        
    <!-- Paint page -->
    <div class="page sandboxels-page hidden" id="paintPage">
        <canvas id="paintCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: black; font-size: 16px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); z-index: 1000; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px;">
            <div>Brush Size: <span id="paint-brush-size">5</span></div>
            <div style="margin-top: 10px;">
                <label for="paint-color-picker" style="display: block; margin-bottom: 5px;">Color:</label>
                <input type="color" id="paint-color-picker" value="#000000" style="width: 60px; height: 30px; cursor: pointer; border: 2px solid #333; border-radius: 4px;">
                <span id="paint-color-display" style="margin-left: 10px;">#000000</span>
            </div>
            </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
        
    <!-- Coinflip page -->
    <div class="page coinflip-page hidden" id="coinflipPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Coin Flip</h1>
        <div id="money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="money-count">0</span>
            </div>
        <div id="win-chance-display" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Win Chance: <span id="win-chance-percent">50</span>%
        </div>
        <div id="coin-container" style="width: 200px; height: 200px; margin: 20px auto; position: relative; perspective: 1000px;">
            <div id="coin" style="width: 200px; height: 200px; position: relative; transform-style: preserve-3d; transition: transform 0.6s;">
                <div id="coin-front" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(0deg);">H</div>
                <div id="coin-back" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(180deg);">T</div>
            </div>
        </div>
        <div id="coinflip-result" style="color: #c9d1d9; font-size: 24px; margin: 20px 0; min-height: 30px;"></div>
        <div style="margin: 30px 0;">
            <button id="heads-btn" onclick="guessCoin('heads')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Heads</button>
            <button id="tails-btn" onclick="guessCoin('tails')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Tails</button>
        </div>
        <div id="streak-display" style="color: #58a6ff; font-size: 20px; margin-top: 20px;">
            Streak: <span id="streak-count">0</span>
        </div>
    </div>
    
    <!-- Clicker page -->
    <div class="page clicker-page hidden" id="clickerPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Clicker Game</h1>
        <div id="clicker-money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="clicker-money-count">0</span>
        </div>
        <div id="clicker-per-click" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Money Per Click: $<span id="clicker-amount">1</span>
        </div>
        <div style="margin: 40px 0;">
            <button id="clicker-button" onclick="clickMoney()" style="padding: 30px 60px; font-size: 32px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.1s; user-select: none;">CLICK ME!</button>
        </div>
    </div>
    
    <!-- Achievements page -->
    <div class="page achievements-page hidden" id="achievementsPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 10px;">Achievements</h1>
        <div id="achievements-stats" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Found: <span id="found-count">0</span> / <span id="total-count">256</span>
                </div>
        <div id="achievements-grid" class="achievements-grid">
            <!-- Achievements will be generated here -->
            </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>

    <!-- Goose Rain page -->
    <div class="page gooserain-page hidden" id="gooserainPage">
        <canvas id="gooseCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Geese: <span id="goose-count">0</span>
                </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
    
    <!-- Stones page -->
    <div class="page stones-page hidden" id="stonesPage">
        <canvas id="stonesCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #4682B4 0%, #5F9EA0 60%, #D2B48C 60%, #CD853F 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Stones: <span id="stones-count">0</span>
        </div>
        <div style="position: fixed; top: 50px; left: 20px; color: white; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Press E to spawn stones
        </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
    </div>
    
    <!-- Limbo page (blocked) -->
    <div class="page limbo-page hidden" id="limboPage">
        <h1 style="color: #f85149; font-size: 48px; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">‚ö†Ô∏è BLOCKED ‚ö†Ô∏è</h1>
        <p style="color: #c9d1d9; font-size: 24px; margin-bottom: 40px; text-align: center;">Your blocked from this website</p>
        <p style="color: #8b949e; font-size: 18px; margin-bottom: 30px;">Enter the password to be unblocked:</p>
        <input type="text" id="limboPasswordInput" placeholder="Password" style="padding: 15px 20px; font-size: 20px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; margin-bottom: 20px; text-align: center; min-width: 250px;">
        <button id="limboSubmitBtn" onclick="checkLimboPassword()" style="padding: 15px 40px; font-size: 20px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Submit</button>
        <p id="limboError" style="color: #f85149; font-size: 16px; margin-top: 20px; min-height: 24px;"></p>
    </div>
    
    <!-- Panic Menu page -->
    <div class="page panicmenu-page hidden" id="panicmenuPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Panic Menu</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">Set a hotkey and URL to quickly swap tabs</p>
        <div style="max-width: 500px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Hotkey:</label>
                <input type="text" id="panicHotkeyInput" placeholder="Press a key..." style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; text-align: center;" readonly>
                <p style="color: #8b949e; font-size: 14px; margin-top: 5px;">Click the input and press a key to set</p>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Website URL:</label>
                <input type="text" id="panicUrlInput" placeholder="https://example.com" style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9;">
            </div>
            <button onclick="savePanicSettings()" style="width: 100%; padding: 15px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 20px;">Save Settings</button>
            <div id="panicStatus" style="color: #58a6ff; font-size: 16px; text-align: center; min-height: 24px; margin-bottom: 20px;"></div>
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer;">Back</button>
        </div>
    </div>
    
    <!-- Background Selection page -->
    <div class="page background-page hidden" id="backgroundPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Background Selection</h1>
        <div style="margin-bottom: 30px;">
            <button id="bg-solid-btn" onclick="setBgMode('solid')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer;">Solid Color</button>
            <button id="bg-gradient-btn" onclick="setBgMode('gradient')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 6px; cursor: pointer;">Gradient (2 Colors)</button>
        </div>
        <div id="bg-solid-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select Color</h2>
            <div id="bg-solid-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
        </div>
        <div id="bg-gradient-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select 2 Colors</h2>
            <div style="margin-bottom: 15px;">
                <p style="color: #8b949e; font-size: 16px;">Color 1: <span id="bg-gradient-color1-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
                <p style="color: #8b949e; font-size: 16px;">Color 2: <span id="bg-gradient-color2-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
            </div>
            <div id="bg-gradient-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
            <button id="bg-apply-gradient-btn" onclick="applyGradientBackground()" disabled style="padding: 12px 24px; font-size: 18px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 8px; cursor: not-allowed; margin-top: 20px;">Apply Gradient</button>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Clock display (top left) -->
    <div class="clock-display hidden" id="clockDisplay"></div>
    
    <!-- Command feedback display -->
    <div class="command-feedback hidden" id="commandFeedback">
        <span class="command-text"></span><span class="feedback-text"></span>
    </div>
    
    <!-- Command bar in bottom left -->
    <div class="command-bar">
        <input type="text" class="command-input" id="commandInput" placeholder="Type a color or 'home'..." autocomplete="off">
    </div>
    
        <!-- Commands menu - draggable -->
    <div class="commands-menu" id="commandsMenu">
        <div class="commands-menu-header" id="commandsMenuHeader">
            <h3>Commands</h3>
            <button class="commands-menu-close" id="commandsMenuClose">√ó</button>
        </div>
        <div class="commands-list" id="commandsList">
            <!-- Commands will be dynamically generated based on unlocks -->
        </div>
    </div>

    <script>
        // Letters from "finley" to use
        const finleyLetters = ['f', 'i', 'n', 'l', 'e', 'y'];
        
        // Function to expand pattern: make 3x wider and 2x taller
        function expandPattern(pattern) {
            const expanded = [];
            // Make each row 3x wider
            pattern.forEach(row => {
                const wideRow = [];
                row.forEach(cell => {
                    // Repeat each cell 3 times
                    wideRow.push(cell, cell, cell);
                });
                expanded.push(wideRow);
            });
            // Make 2x taller by duplicating each row
            const tallExpanded = [];
            expanded.forEach(row => {
                tallExpanded.push(row); // Original row
                tallExpanded.push(row); // Duplicate row
            });
            return tallExpanded;
        }
        
        // Function to create letter patterns
        function createLetterPattern(letter, pattern, sourceLetters = finleyLetters) {
            const container = document.getElementById(`letter-${letter}`);
            if (!container) return;
            container.innerHTML = ''; // Clear existing
            const expandedPattern = expandPattern(pattern);
            expandedPattern.forEach(row => {
                row.forEach(cell => {
                    const span = document.createElement('span');
                    span.className = 'small-letter';
                    if (cell === 1) {
                        // Randomly pick a letter from source
                        const randomLetter = sourceLetters[Math.floor(Math.random() * sourceLetters.length)];
                        span.textContent = randomLetter;
                        span.classList.add(randomLetter);
                } else {
                        span.textContent = ' ';
                    }
                    container.appendChild(span);
                });
            });
        }
        
        // Letters for GooseHub (TYLER)
        const tylerLetters = ['t', 'y', 'l', 'e', 'r'];
        
        // Letter patterns for GOOSEHUB
        const gPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const oPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const sPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [0,1,1,1,1,1,0],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const ePattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,1,1]
        ];
        
        // Transform to FinHub mode (revert from GooseHub)
        function transformToFinHubMode() {
            isGooseMode = false;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with code, powered by Finley';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            }
            
            // Clear and recreate title with FINHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for F, I, N, H, U, B
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern, finleyLetters);
                createLetterPattern('i', iPattern, finleyLetters);
                createLetterPattern('n', nPattern, finleyLetters);
                createLetterPattern('h', hPattern, finleyLetters);
                createLetterPattern('u', uPattern, finleyLetters);
                createLetterPattern('b', bPattern, finleyLetters);
            }
            
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Transform to GooseHub mode
        function transformToGooseMode() {
            isGooseMode = true;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with feathers, powered by birds';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: T-Y-L-E-R';
            }
            
            // Clear and recreate title with GOOSEHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for G, O, O, S, E, H, U, B (need unique IDs for the two O's)
                const gooseLetters = ['g', 'o', 'o2', 's', 'e', 'h', 'u', 'b'];
                gooseLetters.forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter.replace('2', '')}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                // Wait a tiny bit for DOM to update, then create patterns
                setTimeout(() => {
                    createLetterPattern('g', gPattern, tylerLetters);
                    createLetterPattern('o', oPattern, tylerLetters);
                    createLetterPattern('o2', oPattern, tylerLetters);
                    createLetterPattern('s', sPattern, tylerLetters);
                    createLetterPattern('e', ePattern, tylerLetters);
                    createLetterPattern('h', hPattern, tylerLetters);
                    createLetterPattern('u', uPattern, tylerLetters);
                    createLetterPattern('b', bPattern, tylerLetters);
                }, 10);
            }
            
            // Unlock honk and gooserain commands
            unlockCommand('honk');
            unlockCommand('gooserain');
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Render commands menu dynamically - show all commands except goose ones until unlocked
        function renderCommandsMenu() {
            const commandsList = document.getElementById('commandsList');
            if (!commandsList) return;
            
            const gooseCommands = ['goose', 'honk', 'gooserain']; // Goose commands that need to be unlocked
            
            const commandDefinitions = {
                'Navigation': [
                    { name: 'home', desc: 'Go to home page' },
                    { name: 'back', desc: 'Return to main page' },
                    { name: 'sweeper', desc: 'Play Minesweeper' },
                    { name: 'pong', desc: 'Play Pong' },
                    { name: 'sandboxles', desc: 'Open Sandboxels' },
                    { name: 'paint', desc: 'Open Paint game' },
                    { name: 'snake', desc: 'Play Google Snake' },
                    { name: 'coinflip', desc: 'Flip a coin' },
                    { name: 'clicker', desc: 'Play clicker game' },
                    { name: 'finley', desc: 'Transform back to FinHub' },
                    { name: 'achievements', desc: 'View achievements' },
                    { name: 'background', desc: 'Change background' },
                    { name: 'bg', desc: 'Change background' },
                    { name: 'petgoose', desc: 'Get a pet goose (permanent!)' },
                    { name: 'goose', desc: 'Transform to GooseHub' },
                    { name: 'gooserain', desc: 'Make it rain geese!', isGoose: true },
                    { name: 'stones', desc: 'Throw stones!' },
                    { name: 'wooper', desc: 'Wooper colors!' },
                    { name: 'wooperbird', desc: 'WooperBird command', isWooper: true },
                    { name: 'panicmenu', desc: 'Panic menu settings' },
                ],
                'Colors': [
                    { name: 'rainbow', desc: 'Rainbow colors' },
                    { name: 'black', desc: 'Black' },
                    { name: 'red', desc: 'Red' },
                    { name: 'blue', desc: 'Blue' },
                    { name: 'green', desc: 'Green' },
                    { name: 'yellow', desc: 'Yellow' },
                    { name: 'purple', desc: 'Purple' },
                    { name: 'orange', desc: 'Orange' },
                    { name: 'white', desc: 'White' },
                    { name: 'pink', desc: 'Pink' },
                    { name: 'cyan', desc: 'Cyan' },
                    { name: 'gold', desc: 'Gold' },
                    { name: 'silver', desc: 'Silver' },
                ],
                'Actions': [
                    { name: 'honk', desc: 'Play honk sound', isGoose: true },
                    { name: 'clock', desc: 'Toggle clock (true/false)' },
                    { name: 'whoami', desc: 'Display user profile' },
                    { name: 'roll', desc: 'Roll a random number (roll [number])' },
                    { name: '8ball', desc: 'Magic 8-Ball (8ball [question])' },
                    { name: 'funfact', desc: 'Get a random fun fact' },
                    { name: 'changelog', desc: 'Show recent command additions' },
                    { name: 'rickroll', desc: 'Never gonna give you up...' },
                    { name: 'Secret6767', desc: 'Unlock all commands' },
                ],
                'Visual Effects': [
                    { name: 'matrix', desc: 'Matrix falling code effect' },
                    { name: 'confetti', desc: 'Burst of confetti particles' },
                    { name: 'spin', desc: 'Rotate website 360 degrees' },
                    { name: 'invert', desc: 'Invert all colors' },
                    { name: 'shake', desc: 'Shake the screen' },
                    { name: 'upsidedown', desc: 'Flip the page upside down' },
                    { name: 'party', desc: 'Disco color cycling' },
                    { name: 'chaos', desc: 'Randomly trigger 3 effects at once' },
                ],
                'Menu': [
                    { name: 'cmds', desc: 'Show/hide this menu' },
                ]
            };
            
            let html = '';
            Object.keys(commandDefinitions).forEach(category => {
                const commands = commandDefinitions[category];
                const visibleCommands = commands.filter(cmd => {
                    // Hide goose commands if pet goose doesn't exist
                    if ((cmd.isGoose || cmd.name === 'goose' || cmd.name === 'gooserain' || cmd.name === 'honk' || cmd.name === 'wooperbird') && !hasPetGoose()) {
                        return false;
                    }
                    // Hide goose commands if not unlocked (for legacy support)
                    if (cmd.isGoose && !unlockedCommands.has(cmd.name) && !hasPetGoose()) {
                        return false;
                    }
                    // Hide wooper commands if not unlocked
                    if (cmd.isWooper && !unlockedCommands.has(cmd.name)) {
                        return false;
                    }
                    return true;
                });
                
                if (visibleCommands.length > 0) {
                    html += `<div class="command-category"><h4>${category}</h4>`;
                    visibleCommands.forEach(cmd => {
                        html += `<div class="command-item"><span class="command-name">${cmd.name}</span><span class="command-desc">- ${cmd.desc}</span></div>`;
                    });
                    html += `</div>`;
                }
            });
            
            commandsList.innerHTML = html;
        }
        
        // Unlock a command
        function unlockCommand(commandName) {
            unlockedCommands.add(commandName);
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Play honk sound
        function playHonkSound() {
            try {
                // Generate honk sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(180, audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Could not play honk sound:', e);
            }
        }
        
        // Big F pattern (original - will be expanded to 3x wide, 2x tall)
        const fPattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0]
        ];
        
        // Big i pattern
        const iPattern = [
            [1,1,1],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [1,1,1]
        ];
        
        // Big n pattern
        const nPattern = [
            [1,0,0,0,0,0,1],
            [1,1,0,0,0,0,1],
            [1,0,1,0,0,0,1],
            [1,0,0,1,0,0,1],
            [1,0,0,0,1,0,1],
            [1,0,0,0,0,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big H pattern
        const hPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big u pattern
        const uPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        // Big b pattern
        const bPattern = [
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,1,0],
            [1,1,1,1,1,0,0]
        ];
        
        // Create all letters
        createLetterPattern('f', fPattern);
        createLetterPattern('i', iPattern);
        createLetterPattern('n', nPattern);
        createLetterPattern('h', hPattern);
        createLetterPattern('u', uPattern);
        createLetterPattern('b', bPattern);
        
        // Global money system - shared across all tabs
        let globalMoney = 0;
        let unlockedColors = new Set(); // Colors are unlocked by default (not used anymore but keeping for compatibility)
        let clickerPerClick = 1; // Clicker base money per click
        let unlockedCommands = new Set(); // Only goose commands need to be unlocked
        let isGooseMode = false; // Track if in goose mode
        let resetConfirm = false; // Track if reset command was just used (needs confirmation)
        let resetUsed = false; // Track if reset has been used (can only use once)
        
        // Pet goose system (persistent, survives reset)
        function hasPetGoose() {
            return localStorage.getItem('hasPetGoose') === 'true';
        }
        
        function spawnPetGoose() {
            const petGoose = document.getElementById('petGoose');
            if (petGoose) {
                petGoose.classList.remove('hidden');
                localStorage.setItem('hasPetGoose', 'true');
                // Unlock goose commands when pet goose is spawned
                unlockCommand('honk');
                unlockCommand('gooserain');
                unlockCommand('wooperbird');
            }
        }
        
        function loadPetGoose() {
            if (hasPetGoose()) {
                spawnPetGoose();
            }
        }
        
        // Load global data
        function loadGlobalData() {
            const saved = localStorage.getItem('globalData');
            if (saved) {
                const data = JSON.parse(saved);
                globalMoney = data.money || 0;
                unlockedColors = new Set(data.unlockedColors || []);
                clickerPerClick = data.clickerPerClick || 1;
                unlockedCommands = new Set(data.unlockedCommands || []); // Only goose commands stored
                isGooseMode = data.isGooseMode || false;
            }
            // Check if reset was used in this session
            if (sessionStorage.getItem('resetUsed') === 'true') {
                resetUsed = true;
            }
            updateAllMoneyDisplays();
            renderCommandsMenu();
            if (isGooseMode) {
                transformToGooseMode();
            }
            // Load pet goose (persistent)
            loadPetGoose();
        }
        
        // Save global data
        function saveGlobalData() {
            localStorage.setItem('globalData', JSON.stringify({
                money: globalMoney,
                unlockedColors: Array.from(unlockedColors),
                clickerPerClick: clickerPerClick,
                unlockedCommands: Array.from(unlockedCommands),
                isGooseMode: isGooseMode
            }));
        }
        
        // Reset everything - clears all progress
        function resetEverything() {
            // Mark reset as used - can only use once
            resetUsed = true;
            sessionStorage.setItem('resetUsed', 'true');
            
            // Save pet goose state before clearing (preserve it)
            const petGooseExists = hasPetGoose();
            
            // Clear all localStorage
            localStorage.removeItem('globalData');
            localStorage.removeItem('coinflipData');
            localStorage.removeItem('achievements');
            
            // Restore pet goose state (it survives reset!)
            if (petGooseExists) {
                localStorage.setItem('hasPetGoose', 'true');
            }
            
            // Reset all variables
            globalMoney = 0;
            unlockedColors = new Set();
            clickerPerClick = 1;
            unlockedCommands = new Set(); // Reset goose command unlocks
            isGooseMode = false;
            resetConfirm = false;
            
            // Reset coinflip data
            coinflipStreak = 0;
            winChanceUpgrades = 0;
            
            // Reset achievements
            foundAchievements = new Set();
            colorChangeCount = 0;
            commandsUsed = new Set();
            coinflipWins = 0;
            
            // Recreate FinHub letters (reset from GooseHub if needed)
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern);
                createLetterPattern('i', iPattern);
                createLetterPattern('n', nPattern);
                createLetterPattern('h', hPattern);
                createLetterPattern('u', uPattern);
                createLetterPattern('b', bPattern);
            }
            
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            if (subtitle) subtitle.textContent = 'Built with code, powered by Finley';
            if (lettersSource) lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            
            // Update displays
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
            const clickerAmount = document.getElementById('clicker-amount');
            if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            
            // Re-render menu and achievements
            renderCommandsMenu();
            renderAchievements();
            
            // Clear color changes
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                letter.style.color = '';
            });
            
            // Go back to main page
            showPage('mainPage');
            
            // Show success message
            commandInput.placeholder = '‚úÖ Everything has been reset!';
            setTimeout(() => {
                commandInput.placeholder = 'Type a color or "home"...';
            }, 3000);
        }
        
        // Update all money displays across all pages
        function updateAllMoneyDisplays() {
            const displays = ['money-count', 'clicker-money-count'];
            displays.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = globalMoney;
            });
        }
        
        // Add money (global)
        function addMoney(amount) {
            globalMoney += amount;
            updateAllMoneyDisplays();
            saveGlobalData();
        }
        
        // Spend money (global)
        function spendMoney(amount) {
            if (globalMoney >= amount) {
                globalMoney -= amount;
                updateAllMoneyDisplays();
                saveGlobalData();
                return true;
            }
            return false;
        }
        
        // Color command system with multiple shades
        const colorPalettes = {
            'black': ['#000000', '#1a1a1a', '#333333', '#4d4d4d', '#666666', '#000000', '#0d0d0d', '#262626'],
            'red': ['#ff0000', '#cc0000', '#ff3333', '#990000', '#ff6666', '#ff1a1a', '#b30000', '#ff4d4d'],
            'blue': ['#0000ff', '#0000cc', '#3333ff', '#000099', '#6666ff', '#1a1aff', '#0000b3', '#4d4dff'],
            'green': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'yellow': ['#ffff00', '#cccc00', '#ffff33', '#999900', '#ffff66', '#ffff1a', '#b3b300', '#ffff4d'],
            'purple': ['#800080', '#660066', '#993399', '#4d004d', '#b366b3', '#8c1a8c', '#5c005c', '#cc66cc'],
            'orange': ['#ffa500', '#cc8400', '#ffb833', '#996300', '#ffcc66', '#ffad1a', '#b37500', '#ffd24d'],
            'white': ['#ffffff', '#e6e6e6', '#cccccc', '#f5f5f5', '#ffffff', '#fafafa', '#d9d9d9', '#ffffff'],
            'pink': ['#ff69b4', '#cc5490', '#ff7fc4', '#993f6c', '#ff99d4', '#ff73ba', '#b34a85', '#ff8fce'],
            'cyan': ['#00ffff', '#00cccc', '#33ffff', '#009999', '#66ffff', '#1affff', '#00b3b3', '#4dffff'],
            'lime': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'magenta': ['#ff00ff', '#cc00cc', '#ff33ff', '#990099', '#ff66ff', '#ff1aff', '#b300b3', '#ff4dff'],
            'brown': ['#a52a2a', '#842121', '#b84d4d', '#661919', '#cc7070', '#ad3333', '#8b1f1f', '#c55c5c'],
            'gray': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'grey': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'gold': ['#ffd700', '#ccac00', '#ffdd33', '#998000', '#ffe666', '#ffdb1a', '#b39900', '#ffe84d'],
            'silver': ['#c0c0c0', '#999999', '#d4d4d4', '#737373', '#e6e6e6', '#b8b8b8', '#8c8c8c', '#d9d9d9']
        };
        
        // Color costs in shop
        const colorCosts = {
            'black': 10,
            'red': 20,
            'blue': 20,
            'green': 20,
            'yellow': 25,
            'purple': 30,
            'orange': 30,
            'white': 15,
            'pink': 35,
            'cyan': 25,
            'lime': 20,
            'magenta': 35,
            'brown': 25,
            'gray': 15,
            'grey': 15,
            'gold': 50,
            'silver': 40,
            'rainbow': 100
        };
        
        // Function to change all letter colors with different shades (all colors unlocked)
        function changeAllColors(colorName) {
            const palette = colorPalettes[colorName];
            if (!palette) {
                // Special case for rainbow
                if (colorName === 'rainbow') {
                    applyRainbowColors();
                }
                return;
            }
            
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    // Randomly pick a shade from the palette
                    const randomShade = palette[Math.floor(Math.random() * palette.length)];
                    letter.style.color = randomShade;
                }
            });
        }

        // Function to apply rainbow colors
        function applyRainbowColors() {
            const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = rainbowColors[colorIndex % rainbowColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Function to apply wooper colors (blue and pink)
        function applyWooperColors() {
            const wooperColors = ['#0000ff', '#ff69b4']; // Blue and pink
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = wooperColors[colorIndex % wooperColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Navigation system
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            document.getElementById(pageId).classList.remove('hidden');
        }
        
        // Commands menu functionality
        const commandsMenu = document.getElementById('commandsMenu');
        const commandsMenuHeader = document.getElementById('commandsMenuHeader');
        const commandsMenuClose = document.getElementById('commandsMenuClose');
        
        function toggleCommandsMenu() {
            commandsMenu.classList.toggle('open');
        }
        
        // Close menu button
        commandsMenuClose.addEventListener('click', () => {
            commandsMenu.classList.remove('open');
        });
        
        // Make menu draggable
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        commandsMenuHeader.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.target === commandsMenuClose || !commandsMenu.classList.contains('open')) return;
            const rect = commandsMenu.getBoundingClientRect();
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;
            isDragging = true;
            commandsMenu.classList.add('dragging');
            commandsMenu.style.transition = 'none';
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                // Keep menu within viewport
                const maxX = window.innerWidth - commandsMenu.offsetWidth;
                const maxY = window.innerHeight - commandsMenu.offsetHeight;
                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));
                
                commandsMenu.style.right = 'auto';
                commandsMenu.style.left = `${currentX}px`;
                commandsMenu.style.top = `${currentY}px`;
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                isDragging = false;
                commandsMenu.classList.remove('dragging');
                commandsMenu.style.transition = 'right 0.3s ease';
            }
        }
        
        // Clock system
        let clockEnabled = false;
        let clockInterval = null;
        const clockDisplay = document.getElementById('clockDisplay');
        
        function loadClockSetting() {
            const saved = localStorage.getItem('clockEnabled');
            clockEnabled = saved === 'true';
            if (clockEnabled) {
                showClock();
            } else {
                hideClock();
            }
        }
        
        function saveClockSetting() {
            localStorage.setItem('clockEnabled', clockEnabled.toString());
        }
        
        function updateClock() {
            if (!clockDisplay) return;
            const now = new Date();
            // Florida timezone (America/New_York - EST/EDT)
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false, // Military time
                timeZone: 'America/New_York'
            };
            const timeString = new Intl.DateTimeFormat('en-US', options).format(now);
            clockDisplay.textContent = timeString;
        }
        
        function showClock() {
            if (!clockDisplay) return;
            clockEnabled = true;
            clockDisplay.classList.remove('hidden');
            updateClock();
            if (clockInterval) clearInterval(clockInterval);
            clockInterval = setInterval(updateClock, 1000);
            saveClockSetting();
        }
        
        function hideClock() {
            if (!clockDisplay) return;
            clockEnabled = false;
            clockDisplay.classList.add('hidden');
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
            saveClockSetting();
        }
        
        // Command feedback helper
        function showCommandFeedback(command, feedback, isError = false) {
            const feedbackEl = document.getElementById('commandFeedback');
            const commandTextEl = feedbackEl?.querySelector('.command-text');
            const feedbackTextEl = feedbackEl?.querySelector('.feedback-text');
            
            if (feedbackEl && commandTextEl && feedbackTextEl) {
                commandTextEl.textContent = `> ${command}`;
                feedbackTextEl.textContent = feedback ? ` ${feedback}` : '';
                feedbackEl.classList.remove('hidden');
                feedbackEl.style.color = isError ? '#f85149' : '#c9d1d9'; // Red for error, default for success
                
                // Auto-hide after 3 seconds
                clearTimeout(feedbackEl.timeoutId);
                feedbackEl.timeoutId = setTimeout(() => {
                    feedbackEl.classList.add('hidden');
                }, 3000);
            }
        }
        
        // Whoami profile
        function showWhoami() {
            const profile = `You are a curious explorer, a digital architect, and a master of your own domain. Keep building!`;
            return profile;
        }
        
        // Changelog system - tracks recent command additions
        const changelog = [
            { command: 'petgoose', description: 'Get a permanent pet goose', date: 'Latest' },
            { command: 'upsidedown', description: 'Flip the page upside down', date: 'Recent' },
            { command: 'Secret6767', description: 'Unlock all commands', date: 'Recent' },
            { command: 'rickroll', description: 'Never gonna give you up...', date: 'Recent' },
            { command: 'funfact', description: 'Get a random fun fact', date: 'Recent' },
            { command: 'roll [number]', description: 'Roll a random number', date: 'Recent' },
            { command: '8ball [question]', description: 'Magic 8-Ball answers', date: 'Recent' },
            { command: 'clock true/false', description: 'Toggle military time clock', date: 'Recent' },
            { command: 'whoami', description: 'Display user profile', date: 'Recent' },
        ];
        
        function showChangelog() {
            // Get the last 5 entries
            const recentChanges = changelog.slice(0, 5);
            let changelogText = 'üìã Recent Commands Added:\n\n';
            recentChanges.forEach((entry, index) => {
                changelogText += `${index + 1}. ${entry.command}\n   ‚îî‚îÄ ${entry.description}\n\n`;
            });
            return changelogText.trim();
        }
        
        // Load clock setting on page load
        loadClockSetting();
        
        // Command input handler
        const commandInput = document.getElementById('commandInput');
        commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const originalCommand = commandInput.value.trim();
                const command = originalCommand.toLowerCase().trim();
                const hasColorPalette = colorPalettes.hasOwnProperty(command);
                
                // Handle navigation commands
                if (command === 'reset') {
                    // Check if reset has already been used
                    if (sessionStorage.getItem('resetUsed') === 'true') {
                        commandInput.value = '';
                        commandInput.placeholder = 'Reset can only be used once per session!';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    } else if (resetConfirm) {
                        // Second time - actually reset
                        resetEverything();
                        commandInput.value = '';
                        resetConfirm = false;
                            } else {
                        // First time - ask for confirmation
                        resetConfirm = true;
                        commandInput.value = '';
                        commandInput.placeholder = '‚ö†Ô∏è Type "reset" again to confirm - THIS WILL DELETE ALL PROGRESS!';
                        setTimeout(() => {
                            resetConfirm = false;
                            if (commandInput.placeholder.includes('confirm')) {
                                commandInput.placeholder = 'Type a color or "home"...';
                            }
                        }, 5000);
                    }
                } else if (command === 'home') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('homePage');
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'back') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('mainPage');
                    commandInput.value = '';
                    commandInput.placeholder = 'Type a color or "home"...';
                } else if (command === 'sweeper') {
                    resetConfirm = false;
                    showPage('minesweeperPage');
                    initMinesweeper();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'pong') {
                    resetConfirm = false;
                    showPage('pongPage');
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'sandboxles') {
                    resetConfirm = false;
                    showPage('sandboxelsPage');
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'paint') {
                    resetConfirm = false;
                    showPage('paintPage');
                    initPaint();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'snake') {
                    resetConfirm = false;
                    // Execute snake game JavaScript
                    (function() {
                        if(window.snakeGameActive) return;
                        window.snakeGameActive = true;

                        const snakeColor = '#00FF00';
                        const headColor = '#FFFF00';
                        const snakeSpeed = 80; // faster for smoother movement
                        const snakeSize = 20;
                        const maxLength = 50;

                        let snake = [{x: 100, y: 100}];
                        let direction = 'right';
                        let grow = 0;

                        const canvas = document.createElement('canvas');
                        canvas.style.position = 'fixed';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.zIndex = '9999';
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        document.body.appendChild(canvas);
                        const ctx = canvas.getContext('2d');

                        // Polyfill for roundRect if not available
                        if (!ctx.roundRect) {
                            ctx.roundRect = function(x, y, width, height, radius) {
                                this.beginPath();
                                this.moveTo(x + radius, y);
                                this.lineTo(x + width - radius, y);
                                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                                this.lineTo(x + width, y + height - radius);
                                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                this.lineTo(x + radius, y + height);
                                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                                this.lineTo(x, y + radius);
                                this.quadraticCurveTo(x, y, x + radius, y);
                                this.closePath();
                            };
                        }

                        window.addEventListener('keydown', e => {
                            if(e.key === 'ArrowUp' && direction !== 'down') direction = 'up';
                            if(e.key === 'ArrowDown' && direction !== 'up') direction = 'down';
                            if(e.key === 'ArrowLeft' && direction !== 'right') direction = 'left';
                            if(e.key === 'ArrowRight' && direction !== 'left') direction = 'right';
                            // Allow escape to close
                            if(e.key === 'Escape') {
                                canvas.remove();
                                window.snakeGameActive = false;
                            }
                        });

                        function wrapWords() {
                            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
                            const textNodes = [];
                            while(walker.nextNode()) textNodes.push(walker.currentNode);

                            textNodes.forEach(node => {
                                if(node.nodeValue.trim() === '') return;
                                const words = node.nodeValue.split(/(\s+)/);
                                const fragment = document.createDocumentFragment();
                                words.forEach(word => {
                                    if(word.trim() === '') {
                                        fragment.appendChild(document.createTextNode(word));
                                    } else {
                                        const span = document.createElement('span');
                                        span.textContent = word;
                                        span.style.display = 'inline-block';
                                        fragment.appendChild(span);
                                    }
                                });
                                node.parentNode.replaceChild(fragment, node);
                            });
                        }

                        wrapWords();

                        function moveSnake() {
                            const head = {...snake[0]};
                            const step = 10; // smaller step for better collision
                            if(direction === 'up') head.y -= step;
                            if(direction === 'down') head.y += step;
                            if(direction === 'left') head.x -= step;
                            if(direction === 'right') head.x += step;

                            snake.unshift(head);

                            if(grow > 0) grow--;
                            else snake.pop();

                            if(snake.length > maxLength) snake.pop();

                            // Eat one word at a time
                            const elements = Array.from(document.body.querySelectorAll('span')).filter(el => el !== canvas);
                            for(let el of elements) {
                                const rect = el.getBoundingClientRect();
                                const padding = 4; // smaller hitbox
                                if(head.x + padding < rect.right && head.x + snakeSize - padding > rect.left &&
                                   head.y + padding < rect.bottom && head.y + snakeSize - padding > rect.top) {
                                    el.style.visibility = 'hidden';
                                    grow += 1;
                                    break;
                                }
                            }
                        }

                        function drawSnake() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // Draw tail with gradient effect
                            for(let i = 0; i < snake.length; i++) {
                                const seg = snake[i];
                                const t = i / snake.length;
                                ctx.fillStyle = `rgba(${Math.floor(0 + t*255)}, ${Math.floor(255 - t*100)}, 0, 1)`;
                                ctx.beginPath();
                                ctx.roundRect(seg.x, seg.y, snakeSize, snakeSize, 6); // rounded corners
                                ctx.fill();
                            }

                            // Draw head
                            const head = snake[0];
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.roundRect(head.x, head.y, snakeSize, snakeSize, 8);
                            ctx.fill();
                        }

                        function gameLoop() {
                            moveSnake();
                            drawSnake();
                        }

                        setInterval(gameLoop, snakeSpeed);

                        console.log("Snake game started! Arrow keys move. Snake eats one word at a time, hitbox improved. Press ESC to exit.");
                    })();
                    commandsUsed.add('snake');
                    commandInput.value = '';
                    commandInput.placeholder = 'Snake game started! Press ESC to exit.';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 3000);
                } else if (command === 'finley') {
                    resetConfirm = false;
                    transformToFinHubMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Welcome back to FinHub!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'coinflip') {
                    resetConfirm = false;
                    showPage('coinflipPage');
                    resetCoinFlip();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'clicker') {
                    resetConfirm = false;
                    showPage('clickerPage');
                    updateAllMoneyDisplays();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'achievements' || command === 'ach') {
                    resetConfirm = false;
                    showPage('achievementsPage');
                    renderAchievements();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'background' || command === 'bg') {
                    resetConfirm = false;
                    showPage('backgroundPage');
                    initBackground();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'goose') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    transformToGooseMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Honk! GooseHub activated!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'honk') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    if (unlockedCommands.has('honk')) {
                        playHonkSound();
                        commandInput.value = '';
                        commandInput.placeholder = 'HONK! ü¶¢';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                                    } else {
                        commandInput.value = '';
                        commandInput.placeholder = 'Honk command not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'gooserain') {
                    resetConfirm = false;
                    if (unlockedCommands.has('gooserain')) {
                        showPage('gooserainPage');
                        initGooseRain();
                        commandInput.value = '';
                        commandInput.placeholder = 'Type "back" to return';
                    } else {
                        commandInput.value = '';
                        commandInput.placeholder = 'Goose rain not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'stones') {
                    resetConfirm = false;
                    showPage('stonesPage');
                    initStones();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'wooper') {
                    resetConfirm = false;
                    applyWooperColors();
                    unlockCommand('wooperbird');
                    commandInput.value = '';
                    commandInput.placeholder = 'Wooper colors applied! üêü';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'wooperbird') {
                    resetConfirm = false;
                    if (unlockedCommands.has('wooperbird')) {
                        spawnWooperbirdGoose();
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird dropped! üê¶';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    } else {
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird not unlocked yet! Use "wooper" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'panicmenu' || command === 'panic') {
                    resetConfirm = false;
                    showPage('panicmenuPage');
                    initPanicMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command.startsWith('clock ')) {
                    resetConfirm = false;
                    const arg = originalCommand.substring(6).trim().toLowerCase();
                    if (arg === 'true') {
                        clockEnabled = true;
                        showClock();
                        saveClockSetting();
                        showCommandFeedback(originalCommand, 'Clock enabled! ‚è∞');
                    } else if (arg === 'false') {
                        clockEnabled = false;
                        hideClock();
                        saveClockSetting();
                        showCommandFeedback(originalCommand, 'Clock disabled.');
                    } else {
                        showCommandFeedback(originalCommand, 'Invalid argument. Use "clock true" or "clock false".', true);
                    }
                    commandInput.value = '';
                } else if (command === 'whoami') {
                    resetConfirm = false;
                    const profile = showWhoami();
                    showCommandFeedback(originalCommand, profile);
                    commandInput.value = '';
                } else if (command.startsWith('roll ')) {
                    resetConfirm = false;
                    const arg = originalCommand.substring(5).trim();
                    const maxNum = parseInt(arg);
                    if (isNaN(maxNum) || maxNum < 1 || maxNum > 1000000) {
                        showCommandFeedback(originalCommand, 'Invalid number. Use a number between 1 and 1000000.', true);
                    } else {
                        const rolled = Math.floor(Math.random() * maxNum) + 1;
                        showCommandFeedback(originalCommand, `Rolled: ${rolled}`);
                    }
                    commandInput.value = '';
                } else if (command.startsWith('8ball ') || command.startsWith('8-ball ')) {
                    resetConfirm = false;
                    const responses = [
                        'It is certain.',
                        'It is decidedly so.',
                        'Without a doubt.',
                        'Yes definitely.',
                        'You may rely on it.',
                        'As I see it, yes.',
                        'Most likely.',
                        'Outlook good.',
                        'Yes.',
                        'Signs point to yes.',
                        'Reply hazy, try again.',
                        'Ask again later.',
                        'Better not tell you now.',
                        'Cannot predict now.',
                        'Concentrate and ask again.',
                        "Don't count on it.",
                        'My reply is no.',
                        'My sources say no.',
                        'Outlook not so good.',
                        'Very doubtful.'
                    ];
                    const answer = responses[Math.floor(Math.random() * responses.length)];
                    showCommandFeedback(originalCommand, `üé± ${answer}`);
                    commandInput.value = '';
                } else if (command === 'changelog') {
                    resetConfirm = false;
                    const changelogText = showChangelog();
                    showCommandFeedback(originalCommand, changelogText);
                    commandInput.value = '';
                } else if (command === 'rickroll') {
                    resetConfirm = false;
                    window.open('https://www.youtube.com/watch?v=dQw4w9WgXcQ', '_blank');
                    showCommandFeedback(originalCommand, 'Never gonna give you up! üéµ');
                    commandInput.value = '';
                } else if (command === 'secret6767') {
                    resetConfirm = false;
                    // Unlock all commands
                    unlockCommand('honk');
                    unlockCommand('gooserain');
                    unlockCommand('wooperbird');
                    showCommandFeedback(originalCommand, 'All commands unlocked! üîì‚ú®');
                    commandInput.value = '';
                } else if (command === 'petgoose') {
                    resetConfirm = false;
                    spawnPetGoose();
                    showCommandFeedback(originalCommand, 'Pet goose spawned! ü¶¢ You can never get rid of him!');
                    commandInput.value = '';
                } else if (command === 'funfact') {
                    resetConfirm = false;
                    const facts = [
                        "A cloud weighs around a million tonnes. A cloud typically has a volume of around 1km3 and a density of around 1.003kg per m3 ‚Äì that's a density that's around 0.4 per cent lower than the air surrounding it (this is how they are able to float).",
                        "Giraffes are 30 times more likely to get hit by lightning than people. True, there are only five well-documented fatal lightning strikes on giraffes between 1996 and 2010. But due to the population of the species being just 140,000 during this time, it makes for about 0.003 lightning deaths per thousand giraffes each year. This is 30 times the equivalent fatality rate for humans.",
                        "Identical twins don't have the same fingerprints. You can't blame your crimes on your twin, after all. This is because environmental factors during development in the womb (umbilical cord length, position in the womb, and the rate of finger growth) affect your fingerprint.",
                        "Earth's rotation is changing speed. It's actually slowing. This means that, on average, the length of a day increases by around 1.8 seconds per century. 600 million years ago a day lasted just 21 hours.",
                        "Earlobes have no biological purpose. While they are rich in nerve endings and may play a role in social bonding, many scientists argue that earlobes don't have any true biological purpose.",
                        "Your brain is constantly eating itself. This process is called phagocytosis, where cells envelop and consume smaller cells or molecules to remove them from the system. Don't worry! Phagocytosis isn't harmful, but actually helps preserve your grey matter.",
                        "The largest piece of fossilised dinosaur poo discovered is over 30cm long and over two litres in volume. Believed to be a Tyrannosaurus rex turd, the fossilised dung (also named a 'coprolite') is helping scientists better understand what the dinosaur ate.",
                        "Mars isn't actually round. Unlike any other rocky planet in the Solar System, Mars is actually shaped like a rugby ball, but with different sizes along all three axes.",
                        "There's no such thing as zero-calorie foods. Even low-calorie foods, such as celery and watercress, contain more energy than the body needs to process them.",
                        "The Universe's average colour is called 'Cosmic latte'. In a 2002 study, astronomers found that the light coming from galaxies averaged into a beige colour that's close to white.",
                        "Animals can experience time differently from humans. To smaller animals, the world around them moves more slowly compared to humans. Salamanders and lizards, for example, experience time more slowly than cats and dogs. This is because the perception of time depends on how quickly the brain can process incoming information.",
                        "Water might not be wet. This is because most scientists define wetness as a liquid's ability to maintain contact with a solid surface, meaning that water itself is not wet, but can make other objects wet.",
                        "Most people stroke cats the wrong way. Research shows they often just tolerate it for the food and attention. The safest spots? Under the chin, cheeks and base of the ears. The worst? Their belly and the base of their tail ‚Äì touch there and you're more likely to annoy them than bond with them.",
                        "A chicken once lived for 18 months without a head. Mike the chicken's incredible feat was recorded back in the 1940s in the USA. He survived as his jugular vein and most of his brainstem were left mostly intact, ensuring just enough brain function remained for survival. In the majority of cases, a headless chicken dies in a matter of minutes.",
                        "The raw ingredients of a human body would cost over ¬£116,000. But if you're prepared to do the refining yourself, a body could cost a lot less ‚Äì under ¬£100 in fact.",
                        "All the world's bacteria stacked on top of each other would stretch for 10 billion light-years. Together, Earth's 0.001mm-long microbes could wrap around the Milky Way over 20,000 times.",
                        "Wearing a tie can reduce blood flow to the brain by 7.5 per cent. A study in 2018 found that wearing a necktie can reduce the blood flow to your brain by up to 7.5 per cent, which can make you feel dizzy, nauseous and cause headaches. They can also increase the pressure in your eyes if on too tight and are great at carrying germs.",
                        "The fear of long words is called Hippopotomonstrosesquippedaliophobia. The 36-letter word was first used by the Roman poet Horace in the first century BCE to criticise those writers with an unreasonable penchant for long words. It was American poet Aimee Nezheukumatathil, possibly afraid of their own surname, who coined the term how we know it in 2000.",
                        "The world's oldest dog lived to 29.5 years old. While the median age a dog reaches tends to be about 10-15 years, one Australian cattle dog, 'Bluey', survived to the ripe old age of 29.5.",
                        "The world's oldest cat lived to 38 years and three days old. Creme Puff was the oldest cat to ever live.",
                        "The Sun makes a sound but we can't hear it. In the form of pressure waves, the Sun does make a sound. The wavelength of the pressure waves from the Sun is measured in hundreds of miles, however, meaning they are far beyond the range of human hearing.",
                        "Mount Everest isn't the tallest mountain on Earth. Mauna Kea and Mauna Loa in Hawaii, the twin volcanoes, are taller than Mount Everest as 4.2km of their height is submerged underwater. The twin volcanoes measure a staggering 10.2km in total, compared to Everest's paltry 8.8km.",
                        "Our solar system has a wall. The heliopause ‚Äì the region of space in which solar wind isn't hot enough to push back the wind of particles coming from distant stars ‚Äì is often considered the 'boundary wall' of the Solar System and interstellar space.",
                        "Octopuses don't actually have tentacles. They have eight limbs, but they're arms (for most species). Technically, when talking about cephalopods (octopuses, squids etc), scientists define tentacles as limbs with suckers at their end. Octopus arms have suckers down most of their length.",
                        "Most maps of the world are wrong. On most maps, the Mercator projection ‚Äì first developed in 1569 ‚Äì is still used. This method is wildly inaccurate and makes Alaska appear as large as Brazil and Greenland 14 times larger than it actually is. For a map to be completely accurate, it would need to be life-size and round, not flat.",
                        "NASA genuinely faked part of the Moon landing. While Neil Armstrong's first steps on the lunar surface were categorically not faked, the astronaut quarantine protocol when the astronauts arrived back on Earth was largely just one big show.",
                        "Comets smell like rotten eggs. A comet smells like rotten eggs, urine, burning matches, and‚Ä¶ almonds. Traces of hydrogen sulphide, ammonia, sulphur dioxide, and hydrogen cyanide were all found in the makeup of the comet 67P/Churyumove-Gerasimenko. Promotional postcards were even commissioned in 2016 carrying the pungent scent of a comet.",
                        "Earth's poles are moving. This magnetic reversal of the North and South Pole has happened 171 times in the past 71 million years. We're overdue a flip. It could come soon, as the North Pole is moving at around 55 kilometres per year, an increase over the 15km per year up until 1990.",
                        "You can actually die laughing. And a number of people have, typically due to intense laughter causing a heart attack or suffocation. Comedy shows should come with a warning.",
                        "Chainsaws were first invented for childbirth. It was developed in Scotland in the late 18th Century to help aid and speed up the process of symphysiotomy (widening the pubic cartilage) and removal of disease-laden bone during childbirth. It wasn't until the start of the 20th Century that we started using chainsaws for woodchopping.",
                        "Ants don't have lungs. They instead breathe through spiracles, nine or ten tiny openings, depending on the species.",
                        "You don't actually lose most of your heat through your head. Your face, head and chest are more sensitive to temperature changes, but this myth isn't entirely true. In reality, covering any part of the body helps prevent heat loss in the same way.",
                        "The T.rex likely had feathers. Scientists in China discovered Early Cretaceous period tyrannosaur skeletons that were covered in feathers. If the ancestors of the T. rex had feathers, the T. rex probably did, too.",
                        "Football teams wearing red kits play better. The colour of your clothes can affect how you're perceived by others and change how you feel. A review of football matches in the last 55 years, for example, showed that teams wearing a red kit consistently played better in home matches than teams in any other colour.",
                        "When you cut a worm in two, it regenerates. That said, this only works if it's cut widthways ‚Äì and not all will. Earthworms can regrow their tails, and the planarian flatworm can regrow its whole body from a tiny sliver of tissue.",
                        "Wind turbines kill between 10,000 and 100,000 birds each year in the UK. Interestingly, painting one of the blades of a wind turbine black can reduce bird deaths by 70 per cent.",
                        "Snails have teeth. Between 1,000 and 12,000 teeth, to be precise. They aren't like ours, though, so don't be thinking about snails with ridiculous toothy grins. You'll find the snail's tiny 'teeth' all over its file-like tongue.",
                        "Sound can be minus decibels. The quietest place on Earth is Microsoft's anechoic chamber in Redmond, WA, USA, at -20.6 decibels. These anechoic chambers are built out of heavy concrete and brick and are mounted on springs to stop vibrations from getting in through the floor.",
                        "A horse normally has more than one horsepower. A study in 1993 showed that the maximum power a horse can produce is 18,000W, around 24 horsepower.",
                        "Your signature could reveal personality traits. A study in 2016 purports that among men, a larger signature correlates with higher social bravado and, among women, a bigger signature correlates with narcissistic traits.",
                        "One in 18 people have a third nipple. Known as polythelia, the third nipple is caused by a mutation in inactive genes.",
                        "Bananas are radioactive. Due to being rich in potassium, every banana is actually slightly radioactive thanks to containing the natural isotope potassium-40. Interestingly, your body contains around 16mg of potassium-40, meaning you're around 280 times more radioactive than a banana already. Any excess potassium-40 you gain from a banana is excreted out within a few hours.",
                        "There's no such thing as a straight line. Zoom in close enough to anything and you'll spot irregularities. Even a laser light beam is slightly curved.",
                        "Deaf people are known to use sign language in their sleep. A case study of a 71-year-old man with rapid eye movement disorder and a severe hearing impairment showed him using fluent sign language in his sleep, with researchers able to get an idea of what he was dreaming about thanks to those signs.",
                        "Finland is the happiest country on Earth. According to the World Happiness Report, it has been for six years in a row. It's not really surprising, given that Finland is the home of Santa Claus, reindeer and one sauna for every 1.59 people.",
                        "Hippos can't swim. Hippos really do have big bones, so big and dense, in fact, that they're barely buoyant at all. They don't swim and instead perform a slow-motion gallop on the riverbed or on the sea floor. In fact, hippos can even sleep underwater, thanks to a built-in reflex that allows them to bob up, take a breath, and sink back down without waking.",
                        "The Moon looks upside down in the Southern Hemisphere. Compared to the Northern Hemisphere, anyway. This means that the 'Man in the Moon' is upside down in the Southern Hemisphere and looks more like a rabbit.",
                        "You can yo-yo in space. In 2012, NASA astronaut Don Pettit took a yo-yo on board the International Space Station and demonstrated several tricks. It works because a yo-yo mainly relies on the laws of conservation of angular momentum to perform tricks, which, provided you keep the string taut, apply in microgravity too.",
                        "Not only plants photosynthesise. Algae (which are not plants) and some other organisms ‚Äì including sea slugs and pea aphids ‚Äì contain chlorophyll and can also take sunlight and turn it into an energy source.",
                        "You can be heavily pregnant and not realise. Cryptic pregnancies aren't that uncommon, with 1 in 500 not recognised until at least halfway through and 1 in 2,500 not known until labour starts.",
                        "Bacteria on your skin cause your itches. Specifically, bacteria known as Staphylococcus aureus can release a chemical that activates a protein in our nerves. This sends a signal from our skin to our brains, which our brain perceives as an itch.",
                        "Polar bears aren't actually white. Surprisingly, underneath all their white fur, polar bears actually have jet-black skin.",
                        "Starfish don't have bodies. Along with other echinoderms (think sea urchins and sand dollars), their entire bodies are technically classed as heads.",
                        "Somebody has been constipated for 45 days. In 2013, an unfortunate Indian woman had to undergo surgical removal of a faecal mass as large as a football.",
                        "You travel 2.5 million km a day around the Sun without realising. The Earth's orbit travels around 2.5 million kilometres with respect to the Sun's centre, and around 19 million km with respect to the centre of the Milky Way.",
                        "Fish form orderly queues in emergencies. When evacuating through narrow spaces in sketchy situations, schools of neon tetra fish queue so that they don't collide or clog up the line. Scientists interpreted this behaviour as showing that fish can respect social rules even in emergency situations, unlike us humans.",
                        "There are more bacterial cells in your body than human cells. The average human is around 56 per cent bacteria. This was discovered in a 2016 study and is far less than the earlier estimates of 90 per cent. As bacteria are so light, however, by weight, each person is over 99.7 per cent human.",
                        "Most ginger cats are male. There are roughly three ginger male cats to one ginger female. This is because the ginger gene is found on the X chromosome, meaning female cats would require two copies of the gene to become ginger whilst males only need one.",
                        "Your nails grow faster in hot summer. This is probably due to increased blood supply to the fingertips. It could also be because you're less stressed while on holiday so less likely to gnaw away at 'em.",
                        "The Bermuda Triangle is no more hazardous than any other busy ocean route. The mystery of this patch of sea gained legendary status in the 20th century, but the number of incidents in the Bermuda Triangle isn't significantly higher than in any other part of the ocean.",
                        "Insects can fly up to 3.25km above sea level, at least. Alpine bumblebees have been found living as high up as 3.25km above sea level and could even fly in lab conditions that replicate the air density and oxygen levels at 9km ‚Äì that's just higher than Mount Everest.",
                        "There's a planet mostly made from diamond. Called 55 Cancri e, it's around twice the size of Earth and some 40 light-years away from us within the Cancer constellation.",
                        "In the deep sea, male anglerfish don't just mate ‚Äì they fuse. The tiny males bite onto a much larger female and gradually dissolve into her body, leaving behind little more than a living sack of sperm she can use whenever she wants to lay eggs.",
                        "There's a condition in which your body can brew alcohol. Auto-brewery syndrome is a very rare condition which occurs when certain bacteria and yeasts in the gut break down carbohydrates into ethanol.",
                        "It's possible for two lucid dreamers to communicate mid-dream. Inter-brain neural synchronisation has been observed between people who are both asleep.",
                        "It's surprisingly easy to escape quicksand. Quicksand's density is higher than that of the human body, making it impossible to sink completely. To escape quicksand, sit or lie back, try to keep your arms up and out of the quicksand, and slowly wiggle your legs side-to-side or back-and-forth.",
                        "A penguin can reach depths of 550m in one dive. Typically, emperor penguins (the deepest-diving penguins) plunge to 100-200m, but the deepest penguin dive on record was more than 550m.",
                        "Animals can be allergic to humans. Animals can be allergic to our dead skin cells ‚Äì dander. These allergic reactions can be just like ours, too, including breathing difficulties and skin irritation.",
                        "Being bored is actually a 'high arousal state' physiologically. This is because when you're bored your heart rate increases.",
                        "Our immune systems can detect bad bacteria from good. The immune system detects pathogen patterns through receptors and will mount an attack. Simultaneously, it will cooperate with microbes and beneficial bacteria.",
                        "Platypuses sweat milk. This is because it doesn't have teats. Milk appears as sweat on a platypus, but it's an aquatic mammal so it doesn't actually sweat at all.",
                        "LEGO bricks withstand compression better than concrete. An ordinary plastic LEGO brick is able to support the weight of 375,000 other bricks before it fails. This, theoretically, would let you build a tower nearing 3.5km in height. Scaling this up to house-size bricks, however, would cost far too much.",
                        "Martial artists who smile before the start of a match are more likely to lose. This could be as a smile can convey fear or submissiveness.",
                        "It's almost impossible to get too much sugar from fresh fruit. While the sugar in fruit is mostly fructose and glucose (fructose is what's converted into fat in your body), you can't get too much sugar from fresh fruit. Fresh fruit contains a lot of fibre and water which slows down your digestion and makes you feel full.",
                        "You don't like the sound of your own voice because of the bones in your head. This may be because the bones in our head make our voice sound deeper.",
                        "A rainbow on Venus is called a glory. Appearing as a series of coloured concentric rings, these are caused by the interference of light waves within droplets, rather than the reflection, refraction and dispersion of light that makes a rainbow.",
                        "Protons look like peanuts, rugby balls, bagels, and spheres. Protons come in all different shapes and sizes, with their appearance changing based on the speed of smaller particles within them: Quarks.",
                        "Mirrors facing each other don't produce infinite reflections. Each reflection will be darker than the last and eventually fade into invisibility. Mirrors absorb a fraction of the energy of the light striking them. The total number of reflections mirrors can produce? A few hundred.",
                        "There might be a cure for 'evil'. Well, a cure for psychopathy, anyway. Psychologists argue that aspects of psychopathy can be 'cured' by cognitive behavioural therapy, which is said to reduce violent offences by those with the condition. Preliminary research suggests that computer-based cognitive training could help a psychopath experience empathy and regret, too.",
                        "All mammals get goosebumps. When your hair stands on end, tiny muscles contract at each hair's base which distorts the skin to create goosebumps. This process is called piloerection and is present in all mammals. Hair or fur is used to trap an insulating air layer.",
                        "Football players spit so much because exercise increases the amount of protein in saliva. When you exercise, the amount of protein secreted into the saliva increases. A protein mucus named MUC5B makes your saliva thicker when you're exercising which makes it more difficult to swallow so we tend to spit more. It may occur during exercise because we breathe through our mouths more. MUC5B could activate to stop our mouths from drying out, therefore.",
                        "Some animals display autistic-like traits. Autistic traits in animals include a tendency toward repetitive behaviour and atypical social habits.",
                        "The biggest butterfly in the world has a 31cm wingspan. It belongs to the Queen Alexandra's Birdwing butterfly, which you can find in the forests of the Oro Province, in the east of Papua New Guinea.",
                        "You remember more dreams when you sleep badly. Research suggests that if you sleep badly and wake up multiple times throughout the night you will be more likely to recall the content of any dreams you had. You are also more likely to remember a dream when woken from one.",
                        "You could sweat when you're anxious to alert others. One theory suggests we've evolved to sweat whilst anxious to alert the brains of other people around us so they are primed for whatever it is that's making us anxious. Brain scans have revealed that when you sniff the sweat of a panic-induced person, regions of the brain that handle emotional and social signals light up. When you're anxious your sympathetic nervous system releases hormones including adrenaline, which activates your sweat glands.",
                        "A lightning bolt is five times hotter than the surface of the Sun. The charge carried by a bolt of lightning is so intense that it has a temperature of 30,000¬∞C (54,000¬∞F).",
                        "The longest anyone has held their breath underwater is over 24.5 minutes. The world record for breath-holding underwater was achieved by Croatian Budimir ≈†obat on 27 March 2021, who held his breath for a total of 24 minutes and 37 seconds. On average, a human can hold their breath between 30-90 seconds.",
                        "The Moon is shrinking. But only very slightly ‚Äì by about 50m (164ft) in radius over the last several hundred million years. Mysterious seismic activity, known as moonquakes, could be to blame.",
                        "Dogs tilt their heads when you speak to them to better pinpoint familiar words. Your dog is tilting its head when you speak to it to pinpoint where noises are coming from more quickly. This is done to listen out more accurately for familiar words such as 'walkies' and helps them to better understand the tone of your voice. If a dog doesn't tilt its head that often (as those with shorter muzzles might), it's because it relies less on sound and more on sight.",
                        "If the Earth doubled in size, trees would immediately fall over. This is because surface gravity would be doubled. It would also mean dog-size and larger animals would not be able to run without breaking a leg.",
                        "Mercury, not Venus, is the closest planet to Earth on average. On average, Mercury is 1.04 astronomical units (AU) away from Earth compared to the 1.14 AU average distance between Earth and Venus. One AU is equal to the average distance between the Earth and the Sun. Venus still comes closest to Earth as part of its orbit around the Sun, however.",
                        "Flamingoes aren't born pink. They actually come into the world with grey/white feathers and only develop a pinkish hue after starting a diet of brine shrimp and blue-green algae.",
                        "You can smell ants. Many species of ants release strong-smelling chemicals when they're angry, threatened or being squished. Trap-jaw ants release a chocolatey smell when annoyed, while citronella ants earn their name from the lemony odour they give off.",
                        "People who eat whatever they want and stay slim have a slow metabolism, not fast. A skinny person tends to have less muscle mass than others, meaning their basal metabolic rate (BMR) is lower than those of a high muscle mass ‚Äì this gives them a slow metabolism, not a fast one.",
                        "There's a scientist who willingly let insects sting him to find out which hurt the most. Justin Schmidt turned his own body into a research tool to create the Schmidt Pain Scale ‚Äì and discovered the South American bullet ant delivers the most excruciating sting of all, describing it as like being shot.",
                        "Earth is 4.54 billion years old. Using radiometric dating, scientists have discovered that the Earth is 4.54 billion years old (give or take 50 million years). This makes our planet half the age of the Milky Way Galaxy (11-13 billion years old) and around a third of the age of the Universe (10-15 billion years old).",
                        "It's actually fine to drink alcohol on (most) antibiotics. It's unlikely that drinking alcohol in moderation will cause a big problem if you're taking a common antibiotic (although there are exceptions, particularly metronidazole).",
                        "Electrons might live forever. Scientists have estimated the minimum lifetime of the electron is about 6.6 √ó 1028 years ‚Äì this is 66,000 'yottayears'. Since this is about 5 quintillion times the age of the Universe, even if electrons don't live forever, they may as well do!",
                        "Beavers don't actually live in dams. Technically, beavers live in a lodge that they build behind a dam, within a deep pool of water.",
                        "The average dinosaur lifespan was surprisingly small. The Tyrannosaurus rex, for example, reached full size between 16-22 years old and lived up until 27-33. The largest dinosaurs such as the Brontosaurus and Diplodocus tended to live up to between 39-53 years old, maybe reaching the heights of 70.",
                        "Someone left a family photo on the Moon. When Apollo 16 astronaut Charles Duke landed on the Moon in 1972, he decided to leave behind a photo of him, his two sons and his wife. The photo remains on the Moon to this day.",
                        "It rains methane on Saturn's largest moon. Titan is the only moon in our Solar System with a dense atmosphere and the only body except Earth with liquid rivers, lakes and seas fed by rainfall. This rainfall isn't water, though; it's liquid methane.",
                        "Giraffes hum to communicate with each other. It's thought that the low-frequency humming could be a form of 'contact call' between individuals who have been separated from their herd, helping them to find each other in the dark. Some researchers think they sleep talk too.",
                        "Glass sponges can live for 15,000 years. This makes them one of the longest-living organisms on Earth. The immortal jellyfish, however, could theoretically live forever (but scientists aren't sure)",
                        "You have a 50 per cent chance of sharing a birthday with a friend. In any group of 23 people, two people will share a birthday, according to the maths. To find the probability of everyone in the group having a unique birthday, multiply all 23 probabilities together, giving 0.493. So the probability of a shared birthday is 1 - 0.493 = 0.507, or 50.7 per cent.",
                        "Murder rates rise in summer. Ever feel angry or in a bad mood when the weather is hot? Well, you're not alone. Violent crime goes up in hotter weather, and in the US, murder rates reportedly rise by 2.7 per cent over the summer.",
                        "'New car smell' is a mix of over 200 chemicals. These include the sickly-sweet, toxic hydrocarbons benzene and toluene.",
                        "'Sea level' isn't actually level. As the strength of the force generated by the Earth's spin is strongest at the equator, the average sea level bulges outward there, putting it further from the centre of the Earth than at the poles. Differences in the strength of the Earth's gravity at different points also cause variation.",
                        "You inhale 50 potentially harmful bacteria every time you breathe. Thankfully, your immune system is working hard all the time, so virtually all of these are promptly destroyed without you feeling a thing. Phew.",
                        "You can see stars as they were 4,000 years ago with the naked eye. Without a telescope, all the stars we can see lie within about 4,000 light-years of us. That means at most you're seeing stars as they were 4,000 years ago, around when the pyramids were being built in Egypt.",
                        "Plants came before seeds. According to the fossil record, early plants resembled moss and reproduced with single-celled spores. Multicellular seeds didn't evolve for another 150 million years.",
                        "Our dead cells are eaten by other cells in our body. Don't worry; it's meant to happen. When cells inside your body die, they're scavenged by phagocytes ‚Äì white blood cells whose job it is to digest other cells.",
                        "Smells can pass through liquid. Please don't try smelling underwater (your nose will not appreciate it), but smell does protrude through liquid.",
                        "Bats aren't blind. Despite the famous idiom, bats can indeed see, but they still use their even more famous echolocation to find prey.",
                        "Hibernating animals don't dream. Sleep is a more physiologically 'active' state than hibernation, which requires animals to substantially reduce all activities to conserve energy. There's simply not enough brain activity while an animal is hibernating to enable dreaming. The only exception to this rule is the fat-tailed lemur.",
                        "Pine trees can tell if it's about to rain. Next time you see a pine cone, take a close look. If it's closed, that's because the air is humid, which can indicate rain is on its way.",
                        "You can't fold a piece of A4 paper more than eight times. As the number of layers doubles each time, the paper rapidly gets too thick and too small to fold. The current world paper-folding record belongs to California high school student Britney Gallivan, who in 2002 managed to fold a 1.2km-long piece of tissue paper 12 times.",
                        "The sharpest teeth in history didn't belong to sharks or even dinosaurs. They came from conodonts ‚Äì tiny eel-like creatures that lived 500 to 200 million years ago. Their tooth tips were just two micrometres wide, about 1/20th the width of a human hair, making them the sharpest ever measured.",
                        "Laughing came before language. How do we know? Some researchers tickled baby apes, which, beyond being adorable, showed that they share the same structure as ours and likely arose in our common ancestors millions of years ago. Language came about much later.",
                        "The fastest jet in the world can fly almost 10 times the speed of sound (11,854km/h). The fastest jet is NASA's X-43 experimental plane, three of which were built in total. The design meant that they had to be dropped from a Boeing B-52 in order to fly.",
                        "Your brain burns 400-500 calories a day. That's about a fifth of your total energy requirements. Most of this is concerned with the largely automatic process of controlling your muscles and processing sensory input, although some studies show solving tricky problems increases your brain's metabolic requirements too."
                    ];
                    const fact = facts[Math.floor(Math.random() * facts.length)];
                    showCommandFeedback(originalCommand, `üí° ${fact}`);
                    commandInput.value = '';
                } else if (command === 'jumpscare') {
                    resetConfirm = false;
                    triggerJumpscare();
                    commandInput.value = '';
                    commandInput.placeholder = 'BOO! üëª';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'matrix') {
                    resetConfirm = false;
                    triggerMatrix();
                    showCommandFeedback(originalCommand, 'Matrix effect activated!');
                    commandInput.value = '';
                } else if (command === 'confetti') {
                    resetConfirm = false;
                    triggerConfetti();
                    showCommandFeedback(originalCommand, 'Confetti burst! üéâ');
                    commandInput.value = '';
                } else if (command === 'spin') {
                    resetConfirm = false;
                    triggerSpin();
                    showCommandFeedback(originalCommand, 'Spinning!');
                    commandInput.value = '';
                } else if (command === 'invert') {
                    resetConfirm = false;
                    triggerInvert();
                    showCommandFeedback(originalCommand, invertActive ? 'Colors inverted!' : 'Colors normal!');
                    commandInput.value = '';
                } else if (command === 'shake') {
                    resetConfirm = false;
                    triggerShake();
                    showCommandFeedback(originalCommand, 'Screen shaking!');
                    commandInput.value = '';
                } else if (command === 'upsidedown') {
                    resetConfirm = false;
                    triggerUpsideDown();
                    showCommandFeedback(originalCommand, upsidedownActive ? 'Page flipped upside down! üîÑ' : 'Page flipped back!');
                    commandInput.value = '';
                } else if (command === 'party') {
                    resetConfirm = false;
                    triggerParty();
                    showCommandFeedback(originalCommand, partyActive ? 'Party mode ON! üéâ' : 'Party mode OFF');
                    commandInput.value = '';
                } else if (command === 'chaos') {
                    resetConfirm = false;
                    triggerChaos();
                    showCommandFeedback(originalCommand, 'CHAOS! üí•‚ú®üé®');
                    commandInput.value = '';
                } else if (command === '67') {
                    resetConfirm = false;
                    // Get current count
                    let count67 = parseInt(localStorage.getItem('count67') || '0');
                    count67++;
                    localStorage.setItem('count67', count67.toString());
                    
                    commandInput.value = '';
                    commandInput.placeholder = 'DONT SAY THAT';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                    
                    // Block after 3 uses
                    if (count67 >= 3) {
                        localStorage.setItem('isBlocked', 'true');
                        showPage('limboPage');
                        const commandBar = document.querySelector('.command-bar');
                        if (commandBar) commandBar.style.display = 'none';
                    }
                } else if (command === 'cmds') {
                    resetConfirm = false;
                    toggleCommandsMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Commands menu toggled!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'rainbow') {
                    resetConfirm = false;
                    applyRainbowColors();
                    commandInput.value = '';
                    commandInput.placeholder = 'Rainbow colors applied!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (hasColorPalette) {
                    resetConfirm = false;
                    changeAllColors(command);
                    commandInput.value = '';
                    commandInput.placeholder = `Changed to ${command}!`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else {
                    resetConfirm = false; // Clear reset confirmation if invalid command
                    commandInput.value = '';
                    commandInput.placeholder = 'Command not found. Try: cmds, home, back, or a color name...';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                }
            }
        });
        
        // Minesweeper game code
        const GRID_SIZE = 10;
        const NUM_MINES = 10;
        const gridEl = document.getElementById('minesweeper-grid');
        const messageEl = document.getElementById('message');
        const restartBtn = document.getElementById('restart-btn');

        let board = [];
        let isGameOver = false;
        let flagsRemaining = NUM_MINES;
        let revealedCount = 0;

        function createBoard() {
            board = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill({ 
                    isMine: false, 
                    isRevealed: false, 
                    isFlagged: false, 
                    mineCount: 0,
                    el: null
                })
            );
            let minesPlaced = 0;
            while (minesPlaced < NUM_MINES) {
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);
                if (!board[r][c].isMine) {
                    board[r][c] = { ...board[r][c], isMine: true }; 
                    minesPlaced++;
                }
            }
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (!board[r][c].isMine) {
                        board[r][c] = { ...board[r][c], mineCount: countMines(r, c) };
                    }
                }
            }
        }

        function countMines(r, c) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                        if (board[nr][nc].isMine) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        function revealCell(r, c) {
            if (isGameOver || r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || board[r][c].isRevealed || board[r][c].isFlagged) {
                return;
            }
            const cell = board[r][c];
            cell.isRevealed = true;
            revealedCount++;
            cell.el.classList.add('revealed');
            cell.el.innerHTML = '';
            cell.el.style.borderColor = 'transparent';

            if (cell.isMine) {
                cell.el.classList.add('mine');
                cell.el.innerHTML = 'üí£';
                gameOver(false);
                return;
            } 
            
            if (cell.mineCount > 0) {
                cell.el.innerHTML = cell.mineCount;
                cell.el.classList.add(`number-${cell.mineCount}`);
                } else {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            checkWin();
        }

        function toggleFlag(r, c) {
            if (isGameOver || board[r][c].isRevealed) return;
            const cell = board[r][c];
            if (cell.isFlagged) {
                cell.isFlagged = false;
                flagsRemaining++;
                cell.el.innerHTML = '';
                cell.el.classList.remove('flag');
            } else if (flagsRemaining > 0) {
                cell.isFlagged = true;
                flagsRemaining--;
                cell.el.innerHTML = 'üö©';
                cell.el.classList.add('flag');
            }
            updateMessage();
        }

        function drawGrid() {
            if (!gridEl) return;
            gridEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = board[r][c];
                    const cellEl = document.createElement('div');
                    cellEl.classList.add('cell');
                    cellEl.dataset.r = r;
                    cellEl.dataset.c = c;
                    cell.el = cellEl;
                    cellEl.addEventListener('click', () => revealCell(r, c));
                    cellEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(r, c);
                    });
                    gridEl.appendChild(cellEl);
                }
            }
            updateMessage();
        }

        function updateMessage() {
            if (!messageEl) return;
            if (!isGameOver) {
                messageEl.innerHTML = `Flags Remaining: ${flagsRemaining}`;
            }
        }

        function checkWin() {
            if (revealedCount === (GRID_SIZE * GRID_SIZE) - NUM_MINES) {
                gameOver(true);
            }
        }

        function gameOver(win) {
            isGameOver = true;
            if (!messageEl) return;
            if (win) {
                messageEl.innerHTML = 'üéâ YOU WIN! üéâ';
                messageEl.style.color = 'green';
                } else {
                messageEl.innerHTML = 'üí£ GAME OVER! üí£';
                messageEl.style.color = 'red';
                board.flat().forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.el.classList.add('mine');
                        cell.el.innerHTML = 'üí£';
                    }
                });
            }
        }

        function initGame() {
            isGameOver = false;
            flagsRemaining = NUM_MINES;
            revealedCount = 0;
            if (messageEl) {
                messageEl.style.color = 'black';
            }
            createBoard();
            drawGrid();
        }

        function initMinesweeper() {
            if (restartBtn) {
                restartBtn.addEventListener('click', initGame);
            }
            initGame();
        }
        
        // Pong game code - placeholder for JavaScript
        function initPong() {
            // Pong game initialization will go here
            // Waiting for JavaScript code...
        }
        
        // Pong settings modal functions
        window.toggleSettingsModal = function() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.toggle('hidden');
            }
        };
        
        window.saveSettingsAndRestart = function() {
            // Settings save and restart will go here
            // Waiting for JavaScript code...
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };
        
        // Sandboxels close function
        function closeSandboxels() {
            showPage('mainPage');
        }
        
        // Pong close function
        function closePong() {
            showPage('mainPage');
        }
        
        // Jumpscare function
        function triggerJumpscare() {
            // Remove any existing jumpscare overlay
            const existing = document.getElementById('jumpscareOverlay');
            if (existing) {
                existing.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'jumpscareOverlay';
            overlay.className = 'jumpscare-overlay';
            
            // Create image element
            const img = document.createElement('img');
            img.className = 'jumpscare-image';
            img.src = 'jumpscare.jpg';
            img.alt = 'Jumpscare';
            
            // Handle image load and error
            img.onload = function() {
                // Image loaded successfully, trigger animation
                setTimeout(() => {
                    overlay.classList.add('active');
                }, 10);
            };
            
            img.onerror = function() {
                // If image fails to load, still show overlay but with error message
                overlay.innerHTML = '<div style="color: white; font-size: 24px; text-align: center;">Jumpscare image not found!<br>Make sure jumpscare.jpg is in the same folder as index.html</div>';
                overlay.classList.add('active');
            };
            
            overlay.appendChild(img);
            document.body.appendChild(overlay);
            
            // Remove overlay after animation completes (with delay for image load)
            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, 1500); // Give extra time for image to load
        }
        
        // Visual Effects Functions
        let matrixCanvas = null;
        let matrixCtx = null;
        let matrixInterval = null;
        let matrixChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()';
        let matrixColumns = [];
        
        function triggerMatrix() {
            // Remove existing matrix if any
            if (matrixCanvas) {
                matrixCanvas.remove();
                if (matrixInterval) clearInterval(matrixInterval);
            }
            
            // Set black background
            const originalBg = document.body.style.background;
            document.body.style.background = '#000000';
            
            // Create canvas overlay
            matrixCanvas = document.createElement('canvas');
            matrixCanvas.className = 'matrix-canvas';
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            matrixCtx = matrixCanvas.getContext('2d');
            document.body.appendChild(matrixCanvas);
            
            // Initialize columns
            const fontSize = 14;
            const columns = Math.floor(window.innerWidth / fontSize);
            matrixColumns = [];
            for (let i = 0; i < columns; i++) {
                matrixColumns[i] = Math.random() * window.innerHeight;
            }
            
            // Draw matrix effect
            function drawMatrix() {
                matrixCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                matrixCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                
                matrixCtx.fillStyle = '#00ff00';
                matrixCtx.font = fontSize + 'px monospace';
                
                for (let i = 0; i < columns; i++) {
                    const text = matrixChars[Math.floor(Math.random() * matrixChars.length)];
                    const x = i * fontSize;
                    const y = matrixColumns[i] * fontSize;
                    
                    matrixCtx.fillText(text, x, y);
                    
                    if (y > window.innerHeight && Math.random() > 0.975) {
                        matrixColumns[i] = 0;
                    }
                    
                    matrixColumns[i]++;
                }
            }
            
            matrixInterval = setInterval(drawMatrix, 50);
            
            // Stop after 10 seconds
            setTimeout(() => {
                if (matrixCanvas) {
                    matrixCanvas.remove();
                    matrixCanvas = null;
                }
                if (matrixInterval) {
                    clearInterval(matrixInterval);
                    matrixInterval = null;
                }
                document.body.style.background = originalBg;
            }, 10000);
        }
        
        function triggerConfetti() {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#800080'];
            const particleCount = 100;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'confetti-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = '-10px';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.width = (Math.random() * 10 + 5) + 'px';
                particle.style.height = particle.style.width;
                document.body.appendChild(particle);
                
                const angle = (Math.random() - 0.5) * Math.PI * 0.5;
                const velocity = Math.random() * 5 + 5;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity + 5;
                let x = parseFloat(particle.style.left) / 100 * window.innerWidth;
                let y = -10;
                
                const animate = () => {
                    y += vy;
                    x += vx;
                    particle.style.left = (x / window.innerWidth * 100) + '%';
                    particle.style.top = y + 'px';
                    
                    if (y < window.innerHeight + 50) {
                        requestAnimationFrame(animate);
                } else {
                        particle.remove();
                    }
                };
                
                requestAnimationFrame(animate);
            }
        }
        
        function triggerSpin() {
            document.body.classList.add('spin-effect');
            setTimeout(() => {
                document.body.classList.remove('spin-effect');
            }, 1000);
        }
        
        let invertActive = false;
        function triggerInvert() {
            invertActive = !invertActive;
            if (invertActive) {
                document.body.classList.add('invert-effect');
                        } else {
                document.body.classList.remove('invert-effect');
            }
        }
        
        function triggerShake() {
            document.body.classList.add('shake-effect');
            setTimeout(() => {
                document.body.classList.remove('shake-effect');
            }, 500);
        }
        
        let partyInterval = null;
        let partyActive = false;
        const partyColors = ['black', 'red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'cyan'];
        let partyColorIndex = 0;
        
        function triggerParty() {
            partyActive = !partyActive;
            
            if (partyActive) {
                // Start party mode
                partyColorIndex = 0;
                function cyclePartyColors() {
                    if (!partyActive) return;
                    const colorName = partyColors[partyColorIndex % partyColors.length];
                    const colorMap = {
                        'black': '#000000',
                        'red': '#ff0000',
                        'blue': '#0000ff',
                        'green': '#00ff00',
                        'yellow': '#ffff00',
                        'purple': '#800080',
                        'orange': '#ffa500',
                        'pink': '#ff69b4',
                        'cyan': '#00ffff'
                    };
                    document.body.style.background = colorMap[colorName];
                    partyColorIndex++;
                    partyInterval = setTimeout(cyclePartyColors, 100);
                }
                cyclePartyColors();
            } else {
                // Stop party mode
                if (partyInterval) {
                    clearTimeout(partyInterval);
                    partyInterval = null;
                }
                // Restore background
                loadBackgroundPreferences();
            }
        }
        
        function triggerChaos() {
            // Pool of possible chaos actions
            const actions = [];
            
            // Visual effects
            actions.push(() => triggerSpin());
            actions.push(() => triggerShake());
            actions.push(() => triggerConfetti());
            
            // Color changes (random color from available colors)
            const availableColors = Object.keys(colorPalettes);
            actions.push(() => {
                const randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                changeAllColors(randomColor);
            });
            actions.push(() => {
                const randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                changeAllColors(randomColor);
            }); // Add color change twice since it's fun
            
            // Randomly pick 3 different actions
            const selectedActions = [];
            const usedIndices = new Set();
            
            while (selectedActions.length < 3 && selectedActions.length < actions.length) {
                const randomIndex = Math.floor(Math.random() * actions.length);
                if (!usedIndices.has(randomIndex)) {
                    usedIndices.add(randomIndex);
                    selectedActions.push(actions[randomIndex]);
                }
            }
            
            // Trigger all 3 actions at once
            selectedActions.forEach(action => {
                try {
                    action();
                } catch (e) {
                    console.error('Chaos action error:', e);
                }
            });
        }
        
        // Background selection system
        let bgMode = 'solid'; // 'solid' or 'gradient'
        let selectedGradientColor1 = null;
        let selectedGradientColor2 = null;
        let selectedSolidColor = null;
        
        // Map color names to hex values (use first color from each palette)
        const bgColorMap = {
            'black': '#000000',
            'red': '#ff0000',
            'blue': '#0000ff',
            'green': '#00ff00',
            'yellow': '#ffff00',
            'purple': '#800080',
            'orange': '#ffa500',
            'white': '#ffffff',
            'pink': '#ff69b4',
            'cyan': '#00ffff',
            'lime': '#00ff00',
            'magenta': '#ff00ff',
            'brown': '#a52a2a',
            'gray': '#808080',
            'grey': '#808080',
            'gold': '#ffd700',
            'silver': '#c0c0c0'
        };
        
        // Load background preferences
        function loadBackgroundPreferences() {
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
                if (prefs.mode === 'solid' && prefs.color) {
                    document.body.style.background = prefs.color;
                    selectedSolidColor = prefs.color;
                } else if (prefs.mode === 'gradient' && prefs.color1 && prefs.color2) {
                    document.body.style.background = `linear-gradient(to bottom, ${prefs.color1}, ${prefs.color2})`;
                    selectedGradientColor1 = prefs.color1;
                    selectedGradientColor2 = prefs.color2;
                }
            }
        }
        
        // Save background preferences
        function saveBackgroundPreferences() {
            const prefs = {
                mode: bgMode,
                color: bgMode === 'solid' ? selectedSolidColor : null,
                color1: bgMode === 'gradient' ? selectedGradientColor1 : null,
                color2: bgMode === 'gradient' ? selectedGradientColor2 : null
            };
            localStorage.setItem('backgroundPrefs', JSON.stringify(prefs));
        }
        
        // Initialize background page
        function initBackground() {
            // Load saved preferences
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
            }
            
            setBgMode(bgMode);
            renderColorButtons();
        }
        
        // Set background mode (solid or gradient)
        function setBgMode(mode) {
            bgMode = mode;
            
            const solidSection = document.getElementById('bg-solid-section');
            const gradientSection = document.getElementById('bg-gradient-section');
            const solidBtn = document.getElementById('bg-solid-btn');
            const gradientBtn = document.getElementById('bg-gradient-btn');
            
            if (mode === 'solid') {
                if (solidSection) solidSection.style.display = 'block';
                if (gradientSection) gradientSection.style.display = 'none';
                if (solidBtn) solidBtn.style.background = '#238636';
                if (gradientBtn) gradientBtn.style.background = '#30363d';
                } else {
                if (solidSection) solidSection.style.display = 'none';
                if (gradientSection) gradientSection.style.display = 'block';
                if (solidBtn) solidBtn.style.background = '#30363d';
                if (gradientBtn) gradientBtn.style.background = '#238636';
                selectedGradientColor1 = null;
                selectedGradientColor2 = null;
                updateGradientSelection();
            }
        }
        
        // Render color buttons
        function renderColorButtons() {
            const solidColors = document.getElementById('bg-solid-colors');
            const gradientColors = document.getElementById('bg-gradient-colors');
            
            if (solidColors) {
                solidColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => applySolidBackground(colorName);
                    btn.title = colorName;
                    solidColors.appendChild(btn);
                });
            }
            
            if (gradientColors) {
                gradientColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => selectGradientColor(colorName);
                    btn.title = colorName;
                    gradientColors.appendChild(btn);
                });
            }
        }
        
        // Apply solid background
        function applySolidBackground(colorName) {
            const color = bgColorMap[colorName];
            if (color) {
                document.body.style.background = color;
                selectedSolidColor = color;
                saveBackgroundPreferences();
            }
        }
        
        // Select gradient color
        function selectGradientColor(colorName) {
            const color = bgColorMap[colorName];
            if (!color) return;
            
            if (!selectedGradientColor1) {
                selectedGradientColor1 = color;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
            } else if (!selectedGradientColor2) {
                selectedGradientColor2 = color;
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color2NameEl) color2NameEl.textContent = colorName;
                
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = false;
                    applyBtn.style.cursor = 'pointer';
                    applyBtn.style.background = '#238636';
                }
                                    } else {
                // Reset and select first color again
                selectedGradientColor1 = color;
                selectedGradientColor2 = null;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
                if (color2NameEl) color2NameEl.textContent = 'Not selected';
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = true;
                    applyBtn.style.cursor = 'not-allowed';
                    applyBtn.style.background = '#30363d';
                }
            }
        }
        
        // Update gradient selection display
        function updateGradientSelection() {
            const color1NameEl = document.getElementById('bg-gradient-color1-name');
            const color2NameEl = document.getElementById('bg-gradient-color2-name');
            const applyBtn = document.getElementById('bg-apply-gradient-btn');
            
            if (color1NameEl) color1NameEl.textContent = 'Not selected';
            if (color2NameEl) color2NameEl.textContent = 'Not selected';
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.style.cursor = 'not-allowed';
                applyBtn.style.background = '#30363d';
            }
        }
        
        // Apply gradient background
        function applyGradientBackground() {
            if (selectedGradientColor1 && selectedGradientColor2) {
                document.body.style.background = `linear-gradient(to bottom, ${selectedGradientColor1}, ${selectedGradientColor2})`;
                saveBackgroundPreferences();
            }
        }
        
        // Load background on page load
        loadBackgroundPreferences();
        
        // Wooperbird goose on main page
        let wooperbirdCanvas, wooperbirdCtx;
        let wooperbirdGoose = null;
        let wooperbirdDragged = false;
        let wooperbirdMousePos = { x: 0, y: 0 };
        let wooperbirdLastMousePos = { x: 0, y: 0 };
        let wooperbirdAnimationId = null;
        
        function initWooperbirdCanvas() {
            wooperbirdCanvas = document.getElementById('wooperbirdCanvas');
            if (!wooperbirdCanvas) return;
            
            wooperbirdCanvas.width = window.innerWidth;
            wooperbirdCanvas.height = window.innerHeight;
            wooperbirdCtx = wooperbirdCanvas.getContext('2d');
            wooperbirdCanvas.style.pointerEvents = wooperbirdGoose ? 'auto' : 'none';
            
            // Mouse/touch events for dragging
            wooperbirdCanvas.addEventListener('mousedown', handleWooperbirdMouseDown);
            wooperbirdCanvas.addEventListener('mousemove', handleWooperbirdMouseMove);
            wooperbirdCanvas.addEventListener('mouseup', handleWooperbirdMouseUp);
            wooperbirdCanvas.addEventListener('touchstart', handleWooperbirdTouchStart, { passive: false });
            wooperbirdCanvas.addEventListener('touchmove', handleWooperbirdTouchMove, { passive: false });
            wooperbirdCanvas.addEventListener('touchend', handleWooperbirdTouchEnd);
            
            if (wooperbirdGoose) {
                animateWooperbird();
            }
        }
        
        function spawnWooperbirdGoose() {
            if (!wooperbirdCanvas) {
                initWooperbirdCanvas();
            }
            
            wooperbirdGoose = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2,
                size: 30,
                rotation: 0,
                rotationSpeed: 0.02
            };
            
            wooperbirdCanvas.style.pointerEvents = 'auto';
            
            if (!wooperbirdAnimationId) {
                animateWooperbird();
            }
        }
        
        function drawWooperbirdGoose(goose) {
            if (!wooperbirdCtx || !goose) return;
            
            wooperbirdCtx.save();
            wooperbirdCtx.translate(goose.x, goose.y);
            wooperbirdCtx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            wooperbirdCtx.fillStyle = '#0000ff'; // Blue instead of white
            wooperbirdCtx.beginPath();
            wooperbirdCtx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#ff69b4'; // Pink instead of black
            wooperbirdCtx.lineWidth = 2;
            wooperbirdCtx.stroke();
            
            // Draw goose head
            wooperbirdCtx.fillStyle = '#0000ff'; // Blue instead of white
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.stroke();
            
            // Draw beak
            wooperbirdCtx.fillStyle = '#FFA500';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            wooperbirdCtx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            wooperbirdCtx.lineTo(goose.size * 0.7, -goose.size * 0.1);
            wooperbirdCtx.closePath();
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#ff69b4'; // Pink instead of black
            wooperbirdCtx.stroke();
            
            // Draw eye
            wooperbirdCtx.fillStyle = '#ff69b4'; // Pink instead of black
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            
            wooperbirdCtx.restore();
        }
        
        function handleWooperbirdMouseDown(e) {
            if (!wooperbirdGoose) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdMouseMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdMouseUp() {
            wooperbirdDragged = false;
        }
        
        function handleWooperbirdTouchStart(e) {
            if (!wooperbirdGoose) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdTouchMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdTouchEnd() {
            wooperbirdDragged = false;
        }
        
        function animateWooperbird() {
            if (!wooperbirdCtx || !wooperbirdGoose) {
                wooperbirdAnimationId = null;
                return;
            }
            
            wooperbirdCtx.clearRect(0, 0, wooperbirdCanvas.width, wooperbirdCanvas.height);
            
            if (!wooperbirdDragged) {
                wooperbirdGoose.rotation += wooperbirdGoose.rotationSpeed;
            }
            
            drawWooperbirdGoose(wooperbirdGoose);
            
            wooperbirdAnimationId = requestAnimationFrame(animateWooperbird);
        }
        
        // Initialize wooperbird canvas on page load
        initWooperbirdCanvas();
        
        // Handle window resize for wooperbird canvas
        window.addEventListener('resize', () => {
            if (wooperbirdCanvas) {
                wooperbirdCanvas.width = window.innerWidth;
                wooperbirdCanvas.height = window.innerHeight;
            }
        });
        
        // Panic Menu system
        let panicHotkey = null;
        let panicUrl = '';
        
        function loadPanicSettings() {
            const saved = localStorage.getItem('panicSettings');
            if (saved) {
                const data = JSON.parse(saved);
                panicHotkey = data.hotkey || null;
                panicUrl = data.url || '';
            }
            setupPanicHotkey();
        }
        
        function savePanicSettings() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            if (!hotkeyInput || !urlInput) return;
            
            const url = urlInput.value.trim();
            
            if (!panicHotkey || !url) {
                if (statusEl) statusEl.textContent = 'Please set both hotkey and URL!';
                return;
            }
            
            localStorage.setItem('panicSettings', JSON.stringify({
                hotkey: panicHotkey,
                url: url
            }));
            panicUrl = url;
            setupPanicHotkey();
            
            if (statusEl) statusEl.textContent = 'Settings saved! Press your hotkey to swap tabs.';
            setTimeout(() => {
                if (statusEl) statusEl.textContent = '';
            }, 3000);
        }
        
        function setupPanicHotkey() {
            // Remove existing listener if any
            document.removeEventListener('keydown', handlePanicHotkey);
            
            if (panicHotkey && panicUrl) {
                document.addEventListener('keydown', handlePanicHotkey);
            }
        }
        
        function handlePanicHotkey(e) {
            // Check if the pressed key matches the panic hotkey
            if (e.key.toLowerCase() === panicHotkey.toLowerCase() || e.code.toLowerCase() === panicHotkey.toLowerCase()) {
                // Swap to the panic URL
                window.location.href = panicUrl;
            }
        }
        
        function initPanicMenu() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            loadPanicSettings();
            
            if (hotkeyInput) {
                hotkeyInput.value = panicHotkey || '';
                
                hotkeyInput.addEventListener('focus', () => {
                    hotkeyInput.value = '';
                    hotkeyInput.placeholder = 'Press a key...';
                });
                
                hotkeyInput.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    // Get the key code or key name
                    const key = e.key.length === 1 ? e.key.toLowerCase() : e.code;
                    panicHotkey = key;
                    hotkeyInput.value = e.key.length === 1 ? e.key.toUpperCase() : e.code;
                    hotkeyInput.placeholder = 'Hotkey';
                });
            }
            
            if (urlInput) {
                urlInput.value = panicUrl;
            }
            
            if (statusEl) {
                statusEl.textContent = '';
            }
        }
        
        // Make savePanicSettings globally accessible
        window.savePanicSettings = savePanicSettings;
        
        // Load panic settings on page load
        loadPanicSettings();
        
        // Goose Rain game with physics
        let geese = [];
        let animationId = null;
        let canvas, ctx;
        let draggedGoose = null;
        let mousePos = { x: 0, y: 0 };
        let lastGooseMousePos = { x: 0, y: 0 };
        let gooseDragStartPos = { x: 0, y: 0 };
        
        // Stones game with physics
        let stones = [];
        let stonesAnimationId = null;
        let stonesCanvas, stonesCtx;
        let draggedStone = null;
        let stonesMousePos = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };
        
        function initGooseRain() {
            canvas = document.getElementById('gooseCanvas');
            if (!canvas) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx = canvas.getContext('2d');
            
            geese = [];
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = 0;
            
            // Stop previous animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Mouse/touch events for dragging
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Spawn geese
            spawnGoose();
            const spawnInterval = setInterval(() => {
                if (document.getElementById('gooserainPage').classList.contains('hidden')) {
                    clearInterval(spawnInterval);
                    return;
                }
                spawnGoose();
            }, 500);
            
            // Start animation loop
            animate();
        }
        
        function spawnGoose() {
            geese.push({
                x: Math.random() * canvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: Math.random() * 30 + 20,
                rotation: (Math.random() - 0.5) * 0.2,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                dragged: false,
                targetX: 0,
                targetY: 0,
                mass: Math.random() * 30 + 20 // Weight based on size
            });
            
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = geese.length;
        }
        
        function drawGoose(goose) {
                    ctx.save();
            ctx.translate(goose.x, goose.y);
            ctx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
            ctx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw goose head
            ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
            ctx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
                        ctx.stroke();
            
            // Draw beak
            ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
            ctx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            ctx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            ctx.lineTo(goose.size * 0.7, -goose.size * 0.1);
                    ctx.closePath();
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.stroke();
            
            // Draw eye
            ctx.fillStyle = '#000000';
                    ctx.beginPath();
            ctx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
                    ctx.fill();
            
                    ctx.restore();
        }
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            // Check if clicking on a goose
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleMouseUp() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleTouchEnd() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw geese
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                
                if (goose.dragged) {
                    // Position is updated directly in mouse/touch handlers
                    // Keep rotation while dragging
                    goose.rotation += goose.rotationSpeed * 0.5;
                } else {
                    // Physics
                    goose.vy += 0.1; // Gravity
                    goose.vx *= 0.99; // Air resistance
                    goose.vy *= 0.99;
                    
                    goose.x += goose.vx;
                    goose.y += goose.vy;
                    goose.rotation += goose.rotationSpeed;
                    
                    // Collision with ground
                    if (goose.y > canvas.height - goose.size) {
                        goose.y = canvas.height - goose.size;
                        goose.vy *= -0.6; // Bounce
                        goose.vx *= 0.8; // Friction
                        if (Math.abs(goose.vy) < 0.5) {
                            goose.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (goose.x < goose.size || goose.x > canvas.width - goose.size) {
                        goose.vx *= -0.8;
                        goose.x = Math.max(goose.size, Math.min(canvas.width - goose.size, goose.x));
                    }
                }
                
                // Collision with other geese (works for both dragged and non-dragged)
                for (let j = 0; j < geese.length; j++) {
                    if (i !== j) {
                        const other = geese[j];
                        const dx = goose.x - other.x;
                        const dy = goose.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = goose.size + other.size;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass (heavier geese push more)
                            const totalMass = goose.mass + other.mass;
                            const goosePush = (other.mass / totalMass) * overlap;
                            const otherPush = (goose.mass / totalMass) * overlap;
                            
                            // Only move non-dragged geese, or both if both are dragged
                            if (!goose.dragged) {
                                goose.x += Math.cos(angle) * goosePush;
                                goose.y += Math.sin(angle) * goosePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                        } else {
                                // If other is dragged, push the dragged goose back a bit
                                goose.x += Math.cos(angle) * goosePush * 0.3;
                                goose.y += Math.sin(angle) * goosePush * 0.3;
                            }
                            
                            // Bounce for non-dragged geese
                            if (!goose.dragged && !other.dragged) {
                                const relativeVx = goose.vx - other.vx;
                                const relativeVy = goose.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                goose.vx -= Math.cos(angle) * dot * 0.5;
                                goose.vy -= Math.sin(angle) * dot * 0.5;
                                other.vx += Math.cos(angle) * dot * 0.5;
                                other.vy += Math.sin(angle) * dot * 0.5;
                            }
                        }
                    }
                }
                
                drawGoose(goose);
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Handle window resize for goose rain
        window.addEventListener('resize', () => {
            if (canvas && !document.getElementById('gooserainPage').classList.contains('hidden')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            if (stonesCanvas && !document.getElementById('stonesPage').classList.contains('hidden')) {
                stonesCanvas.width = window.innerWidth;
                stonesCanvas.height = window.innerHeight;
            }
        });
        
        // Paint game with canvas
        let paintCanvas, paintCtx;
        let isPainting = false;
        let paintBrushSize = 5;
        let paintColor = '#000000';
        let lastPaintX = 0;
        let lastPaintY = 0;
        
        function initPaint() {
            paintCanvas = document.getElementById('paintCanvas');
            if (!paintCanvas) return;
            
            paintCanvas.width = window.innerWidth;
            paintCanvas.height = window.innerHeight;
            paintCtx = paintCanvas.getContext('2d');
            paintCtx.fillStyle = '#ffffff';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            
            // Color picker event listener
            const colorPicker = document.getElementById('paint-color-picker');
            const colorDisplay = document.getElementById('paint-color-display');
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    paintColor = e.target.value;
                    if (colorDisplay) colorDisplay.textContent = paintColor;
                });
            }
            
            // Mouse/touch events for drawing
            paintCanvas.addEventListener('mousedown', handlePaintMouseDown);
            paintCanvas.addEventListener('mousemove', handlePaintMouseMove);
            paintCanvas.addEventListener('mouseup', handlePaintMouseUp);
            paintCanvas.addEventListener('mouseleave', handlePaintMouseUp);
            paintCanvas.addEventListener('touchstart', handlePaintTouchStart, { passive: false });
            paintCanvas.addEventListener('touchmove', handlePaintTouchMove, { passive: false });
            paintCanvas.addEventListener('touchend', handlePaintTouchEnd);
        }
        
        function handlePaintMouseDown(e) {
            isPainting = true;
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = e.clientX - rect.left;
            lastPaintY = e.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintMouseMove(e) {
            if (!isPainting) return;
            const rect = paintCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintMouseUp() {
            isPainting = false;
        }
        
        function handlePaintTouchStart(e) {
            e.preventDefault();
            isPainting = true;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = touch.clientX - rect.left;
            lastPaintY = touch.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintTouchMove(e) {
            e.preventDefault();
            if (!isPainting) return;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintTouchEnd(e) {
            e.preventDefault();
            isPainting = false;
        }
        
        function drawPaintPoint(x, y) {
            paintCtx.fillStyle = paintColor;
            paintCtx.beginPath();
            paintCtx.arc(x, y, paintBrushSize / 2, 0, Math.PI * 2);
            paintCtx.fill();
        }
        
        function drawPaintLine(x1, y1, x2, y2) {
            paintCtx.strokeStyle = paintColor;
            paintCtx.lineWidth = paintBrushSize;
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            paintCtx.beginPath();
            paintCtx.moveTo(x1, y1);
            paintCtx.lineTo(x2, y2);
            paintCtx.stroke();
        }
        
        // Handle window resize for paint canvas
        window.addEventListener('resize', () => {
            if (paintCanvas && !document.getElementById('paintPage').classList.contains('hidden')) {
                // Save current canvas content
                const imageData = paintCtx.getImageData(0, 0, paintCanvas.width, paintCanvas.height);
                paintCanvas.width = window.innerWidth;
                paintCanvas.height = window.innerHeight;
                paintCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Stones game initialization
        function initStones() {
            stonesCanvas = document.getElementById('stonesCanvas');
            if (!stonesCanvas) return;
            
            stonesCanvas.width = window.innerWidth;
            stonesCanvas.height = window.innerHeight;
            stonesCtx = stonesCanvas.getContext('2d');
            
            stones = [];
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = 0;
            
            // Stop previous animation
            if (stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
            }
            
            // Mouse/touch events for dragging and throwing
            stonesCanvas.addEventListener('mousedown', handleStonesMouseDown);
            stonesCanvas.addEventListener('mousemove', handleStonesMouseMove);
            stonesCanvas.addEventListener('mouseup', handleStonesMouseUp);
            stonesCanvas.addEventListener('touchstart', handleStonesTouchStart, { passive: false });
            stonesCanvas.addEventListener('touchmove', handleStonesTouchMove, { passive: false });
            stonesCanvas.addEventListener('touchend', handleStonesTouchEnd);
            
            // Key event for spawning stones with 'e'
            stonesKeyHandler = handleStonesKeyDown;
            document.addEventListener('keydown', stonesKeyHandler);
            
            // Start animation loop
            animateStones();
        }
        
        // Handle 'e' key to spawn stones (only when on stones page)
        let stonesKeyHandler = null;
        
        function handleStonesKeyDown(e) {
            if (document.getElementById('stonesPage').classList.contains('hidden')) return;
            
            if (e.key === 'e' || e.key === 'E') {
                spawnStone();
            }
        }
        
        // Stone shape types
        const STONE_SHAPES = ['circle', 'square', 'triangle', 'irregular'];
        
        function spawnStone() {
            const size = Math.random() * 40 + 40; // Increased from 15-40 to 40-80 (bigger)
            const shape = STONE_SHAPES[Math.floor(Math.random() * STONE_SHAPES.length)];
            const stoneColor = `rgb(${Math.floor(Math.random() * 60 + 80)}, ${Math.floor(Math.random() * 40 + 60)}, ${Math.floor(Math.random() * 40 + 60)})`;
            
            // Add random scaling for stretched shapes
            const scaleX = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            const scaleY = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            
            stones.push({
                x: Math.random() * stonesCanvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: size,
                scaleX: scaleX,
                scaleY: scaleY,
                dragged: false,
                shape: shape,
                color: stoneColor,
                mass: size * scaleX * scaleY * 3, // Increased mass (3x heavier)
                lastX: 0,
                lastY: 0,
                collisionRadius: size * Math.max(scaleX, scaleY) // Collision radius based on max scaled dimension
            });
            
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = stones.length;
        }
        
        function drawStone(stone) {
            stonesCtx.save();
            stonesCtx.translate(stone.x, stone.y);
            stonesCtx.scale(stone.scaleX || 1, stone.scaleY || 1); // Apply scaling for stretched shapes (no rotation)
            
            stonesCtx.fillStyle = stone.color;
            stonesCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            stonesCtx.lineWidth = 2;
            
            stonesCtx.beginPath();
            
            if (stone.shape === 'circle') {
                stonesCtx.arc(0, 0, stone.size, 0, Math.PI * 2);
            } else if (stone.shape === 'square') {
                stonesCtx.rect(-stone.size, -stone.size, stone.size * 2, stone.size * 2);
            } else if (stone.shape === 'triangle') {
                stonesCtx.moveTo(0, -stone.size);
                stonesCtx.lineTo(-stone.size * 0.866, stone.size * 0.5);
                stonesCtx.lineTo(stone.size * 0.866, stone.size * 0.5);
                stonesCtx.closePath();
            } else if (stone.shape === 'irregular') {
                // Draw irregular polygon with random variations
                const sides = 5 + Math.floor(Math.random() * 6); // 5-10 sides
                const seed = stone.x * 1000 + stone.y; // Use position as seed for consistency
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const radiusVariation = 0.5 + ((seed + i * 137) % 50) / 100; // 0.5 to 1.0
                    const radius = stone.size * radiusVariation;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) {
                        stonesCtx.moveTo(x, y);
                } else {
                        stonesCtx.lineTo(x, y);
                    }
                }
                stonesCtx.closePath();
            }
            
            stonesCtx.fill();
            stonesCtx.stroke();
            stonesCtx.restore();
        }
        
        function handleStonesMouseDown(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            // Check if clicking on a stone
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesMouseMove(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            
            if (draggedStone) {
                // Update position directly while dragging
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesMouseUp() {
            if (draggedStone) {
                // Calculate velocity based on movement while dragging
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                const dt = 0.016; // Approximate frame time
                
                // Set velocity based on drag distance and direction (throwing) - reduced power
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function handleStonesTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            
            if (draggedStone) {
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesTouchEnd() {
            if (draggedStone) {
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function animateStones() {
            // Clear canvas with water/shore background
            const gradient = stonesCtx.createLinearGradient(0, 0, 0, stonesCanvas.height);
            gradient.addColorStop(0, '#4682B4'); // Sky blue (water)
            gradient.addColorStop(0.6, '#5F9EA0'); // Cadet blue (shallow water)
            gradient.addColorStop(0.6, '#D2B48C'); // Tan (shore)
            gradient.addColorStop(1, '#CD853F'); // Peru (sand)
            stonesCtx.fillStyle = gradient;
            stonesCtx.fillRect(0, 0, stonesCanvas.width, stonesCanvas.height);
            
            // Update and draw stones
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                
                if (!stone.dragged) {
                    // Physics
                    stone.vy += 0.2; // Gravity
                    stone.vx *= 0.98; // Air resistance
                    stone.vy *= 0.98;
                    
                    stone.x += stone.vx;
                    stone.y += stone.vy;
                    
                    // Collision with ground (shore)
                    const shoreLevel = stonesCanvas.height * 0.6;
                    const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                    if (stone.y > shoreLevel - collisionRadius) {
                        stone.y = shoreLevel - collisionRadius;
                        stone.vy *= -0.5; // Bounce
                        stone.vx *= 0.7; // Friction
                        if (Math.abs(stone.vy) < 0.5) {
                            stone.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (stone.x < collisionRadius || stone.x > stonesCanvas.width - collisionRadius) {
                        stone.vx *= -0.7;
                        stone.x = Math.max(collisionRadius, Math.min(stonesCanvas.width - collisionRadius, stone.x));
                    }
                }
                
                // Collision with other stones
                for (let j = 0; j < stones.length; j++) {
                    if (i !== j) {
                        const other = stones[j];
                        const dx = stone.x - other.x;
                        const dy = stone.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const stoneCollisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                        const otherCollisionRadius = other.collisionRadius || (other.size * Math.max(other.scaleX || 1, other.scaleY || 1));
                        const minDist = stoneCollisionRadius + otherCollisionRadius;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass
                            const totalMass = stone.mass + other.mass;
                            const stonePush = (other.mass / totalMass) * overlap;
                            const otherPush = (stone.mass / totalMass) * overlap;
                            
                            // Only move non-dragged stones
                            if (!stone.dragged) {
                                stone.x += Math.cos(angle) * stonePush;
                                stone.y += Math.sin(angle) * stonePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                    } else {
                                // If other is dragged, push the dragged stone back a bit
                                stone.x += Math.cos(angle) * stonePush * 0.3;
                                stone.y += Math.sin(angle) * stonePush * 0.3;
                            }
                            
                            // Bounce for non-dragged stones
                            if (!stone.dragged && !other.dragged) {
                                const relativeVx = stone.vx - other.vx;
                                const relativeVy = stone.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                stone.vx -= Math.cos(angle) * dot * 0.6;
                                stone.vy -= Math.sin(angle) * dot * 0.6;
                                other.vx += Math.cos(angle) * dot * 0.6;
                                other.vy += Math.sin(angle) * dot * 0.6;
                            }
                        }
                    }
                }
                
                drawStone(stone);
            }
            
            stonesAnimationId = requestAnimationFrame(animateStones);
        }
        
        // Clicker game
        function clickMoney() {
            addMoney(clickerPerClick);
            // Button animation
            const btn = document.getElementById('clicker-button');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                }, 100);
            }
        }
        
        // Coinflip game
        let coinflipStreak = 0;
        let isCoinFlipping = false;
        let winChanceUpgrades = 0; // Number of upgrades purchased
        const BASE_WIN_CHANCE = 50; // Base 50% chance
        
        // Load saved data
        function loadCoinflipData() {
            const saved = localStorage.getItem('coinflipData');
            if (saved) {
                const data = JSON.parse(saved);
                winChanceUpgrades = data.upgrades || 0;
                coinflipStreak = data.streak || 0;
            }
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
        }
        
        // Save data
        function saveCoinflipData() {
            localStorage.setItem('coinflipData', JSON.stringify({
                upgrades: winChanceUpgrades,
                streak: coinflipStreak
            }));
        }
        
        // Calculate win chance
        function getWinChance() {
            return Math.min(BASE_WIN_CHANCE + winChanceUpgrades, 99); // Cap at 99%
        }
        
        // Update win chance display
        function updateWinChanceDisplay() {
            const winChancePercent = document.getElementById('win-chance-percent');
            const chance = getWinChance();
            if (winChancePercent) winChancePercent.textContent = chance;
            if (shopWinChance) shopWinChance.textContent = chance;
        }
        
        function resetCoinFlip() {
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            
            loadCoinflipData(); // Reload data when page is shown
            
            if (coin) {
                coin.style.transform = 'rotateY(0deg)';
                coin.classList.remove('coin-flipping');
            }
            if (result) {
                result.textContent = '';
            }
            if (streakCount) {
                streakCount.textContent = coinflipStreak;
            }
            
            // Enable buttons
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            if (headsBtn) headsBtn.disabled = false;
            if (tailsBtn) tailsBtn.disabled = false;
        }
        
        function guessCoin(guess) {
            if (isCoinFlipping) return;
            
            isCoinFlipping = true;
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            
            // Disable buttons
            if (headsBtn) headsBtn.disabled = true;
            if (tailsBtn) tailsBtn.disabled = true;
            
            // Add flipping animation
            coin.classList.add('coin-flipping');
            
            // Calculate win chance
            const winChance = getWinChance() / 100;
            const isCorrect = Math.random() < winChance;
            
            // Determine result (if we win, the coin lands on our guess, otherwise opposite)
            const isHeads = isCorrect ? (guess === 'heads') : (guess === 'tails');
            const resultText = isHeads ? 'Heads' : 'Tails';
            
            // Set final rotation
            setTimeout(() => {
                coin.classList.remove('coin-flipping');
                coin.style.transform = isHeads ? 'rotateY(0deg)' : 'rotateY(180deg)';
                
                if (isCorrect) {
                    coinflipStreak++;
                    // Calculate reward: base 2x multiplier, +0.5x per streak
                    // Base reward is $10, multiplied by (2 + streak * 0.5)
                    const multiplier = 2 + (coinflipStreak * 0.5);
                    const baseReward = 10;
                    const reward = Math.floor(baseReward * multiplier);
                    
                    addMoney(reward);
                    
                    if (result) {
                        result.textContent = `‚úÖ Correct! It's ${resultText}! +$${reward} (${multiplier.toFixed(1)}x)`;
                        result.style.color = '#3fb950';
                        }
                } else {
                    coinflipStreak = 0;
                    if (result) {
                        result.textContent = `‚ùå Wrong! It was ${resultText}`;
                        result.style.color = '#f85149';
                    }
                }
                
                if (streakCount) {
                    streakCount.textContent = coinflipStreak;
                }
                
                saveCoinflipData();
                
                // Re-enable buttons after a delay
                setTimeout(() => {
                    isCoinFlipping = false;
                    if (headsBtn) headsBtn.disabled = false;
                    if (tailsBtn) tailsBtn.disabled = false;
                }, 500);
            }, 1000);
        }
        
        // Shop functions
        function getUpgradeCost(upgradeLevel) {
            return 20 * Math.pow(2, upgradeLevel);
        }
        
        function showShop() {
            showPage('shopPage');
            loadCoinflipData();
            renderShop();
        }
        
        function closeShop() {
            showPage('mainPage');
        }
        
        function buyUpgrade() {
            const cost = getUpgradeCost(winChanceUpgrades);
            if (spendMoney(cost)) {
                winChanceUpgrades++;
                updateWinChanceDisplay();
                saveCoinflipData();
                renderShop();
            }
        }
        
        function buyColor(colorName) {
            const cost = colorCosts[colorName];
            if (cost && spendMoney(cost)) {
                unlockedColors.add(colorName);
                saveGlobalData();
                renderShop();
            }
        }
        
        function buyClickerUpgrade() {
            const cost = clickerPerClick * 10;
            if (spendMoney(cost)) {
                clickerPerClick++;
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
                saveGlobalData();
                renderShop();
            }
        }
        
        function renderShop() {
            const container = document.getElementById('upgrade-container');
            if (!container) return;
            
            let html = '';
            
            // Win Chance Upgrade
            const winChanceCost = getUpgradeCost(winChanceUpgrades);
            const canAffordWinChance = globalMoney >= winChanceCost;
            const nextChance = Math.min(getWinChance() + 1, 99);
            html += `
                <div class="upgrade-item">
                    <h3>Win Chance Upgrade</h3>
                    <p>Increase your win chance by +1%</p>
                    <p>Current: ${getWinChance()}% ‚Üí Next: ${nextChance}%</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${winChanceCost}</p>
                    <button class="upgrade-btn" onclick="buyUpgrade()" ${!canAffordWinChance ? 'disabled' : ''}>
                        ${canAffordWinChance ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Clicker Upgrade
            const clickerCost = clickerPerClick * 10;
            const canAffordClicker = globalMoney >= clickerCost;
            html += `
                <div class="upgrade-item">
                    <h3>Clicker Upgrade</h3>
                    <p>Increase money per click by +$1</p>
                    <p>Current: $${clickerPerClick} ‚Üí Next: $${clickerPerClick + 1}</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${clickerCost}</p>
                    <button class="upgrade-btn" onclick="buyClickerUpgrade()" ${!canAffordClicker ? 'disabled' : ''}>
                        ${canAffordClicker ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Colors section
            html += `<div class="upgrade-item" style="margin-top: 30px;"><h3>Colors</h3>`;
            Object.keys(colorPalettes).forEach(colorName => {
                const cost = colorCosts[colorName];
                const isUnlocked = unlockedColors.has(colorName);
                const canAfford = globalMoney >= cost;
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: ${isUnlocked ? '#3fb950' : '#8b949e'}; text-transform: capitalize;">${colorName}</strong>
                            ${isUnlocked ? '<span style="color: #3fb950; margin-left: 10px;">‚úì Unlocked</span>' : ''}
                        </div>
                        ${!isUnlocked ? `
                            <button class="upgrade-btn" onclick="buyColor('${colorName}')" ${!canAfford ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                                ${canAfford ? `Buy ($${cost})` : `$${cost}`}
                            </button>
                        ` : ''}
                    </div>
                `;
            });
            // Rainbow color
            const rainbowCost = colorCosts['rainbow'];
            const rainbowUnlocked = unlockedColors.has('rainbow');
            const canAffordRainbow = globalMoney >= rainbowCost;
            html += `
                <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: ${rainbowUnlocked ? '#3fb950' : '#8b949e'};">Rainbow</strong>
                        ${rainbowUnlocked ? '<span style="color: #3fb950; margin-left: 10px;">‚úì Unlocked</span>' : ''}
                    </div>
                    ${!rainbowUnlocked ? `
                        <button class="upgrade-btn" onclick="buyColor('rainbow')" ${!canAffordRainbow ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                            ${canAffordRainbow ? `Buy ($${rainbowCost})` : `$${rainbowCost}`}
                        </button>
                    ` : ''}
                </div>
            `;
            html += `</div>`;
            
            container.innerHTML = html;
        }
        
        // Blocking system
        function checkBlocked() {
            if (localStorage.getItem('isBlocked') === 'true') {
                showPage('limboPage');
                const commandBar = document.querySelector('.command-bar');
                if (commandBar) commandBar.style.display = 'none';
                return true;
            }
            return false;
        }
        
        function unblock() {
            localStorage.removeItem('isBlocked');
            localStorage.removeItem('count67');
            showPage('mainPage');
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) commandBar.style.display = 'flex';
        }
        
        // Password check function for limbo page
        function checkLimboPassword() {
            const passwordInput = document.getElementById('limboPasswordInput');
            const errorEl = document.getElementById('limboError');
            
            if (!passwordInput) return;
            
            const password = passwordInput.value.trim();
            
            if (password === 'OG') {
                // Correct password - unblock
                unblock();
                if (passwordInput) passwordInput.value = '';
                if (errorEl) errorEl.textContent = '';
                } else {
                // Wrong password
                if (errorEl) errorEl.textContent = 'Incorrect password!';
                if (passwordInput) passwordInput.value = '';
                setTimeout(() => {
                    if (errorEl) errorEl.textContent = '';
                }, 2000);
            }
        }
        
        // Allow Enter key to submit password
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('limboPasswordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        checkLimboPassword();
                    }
                });
            }
        });
        
        // Initialize global data on page load
        loadGlobalData();
        loadCoinflipData();
        
        // Check if blocked on page load
        if (checkBlocked()) {
            // Already showing limbo page
        }
        
        // Update clicker display
        const clickerAmount = document.getElementById('clicker-amount');
        if (clickerAmount) clickerAmount.textContent = clickerPerClick;
        
        // Achievements system
        const TOTAL_ACHIEVEMENTS = 256;
        let foundAchievements = new Set();
        
        // Achievement data - only name, emoji, and description
        const achievementData = [
            { id: 0, name: "Welcome", emoji: "üëã", desc: "Visit the site for the first time" },
            { id: 1, name: "Explorer", emoji: "üó∫Ô∏è", desc: "Visit the home page" },
            { id: 2, name: "Color Master", emoji: "üé®", desc: "Change colors 10 times" },
            { id: 3, name: "Rainbow", emoji: "üåà", desc: "Apply rainbow colors" },
            { id: 4, name: "Sweeper Pro", emoji: "üí£", desc: "Win a game of Minesweeper" },
            { id: 5, name: "Pong Champion", emoji: "üèì", desc: "Play Pong" },
            { id: 6, name: "Coinflip Streak", emoji: "ü™ô", desc: "Get a 5 streak in coinflip" },
            { id: 7, name: "Rich", emoji: "üí∞", desc: "Earn $100 in coinflip" },
            { id: 8, name: "Lucky", emoji: "üçÄ", desc: "Win 10 coinflips in a row" },
            { id: 9, name: "Upgrade Master", emoji: "‚¨ÜÔ∏è", desc: "Buy 5 upgrades in the shop" },
            { id: 10, name: "Sandbox", emoji: "üèóÔ∏è", desc: "Open Sandboxels" },
            { id: 11, name: "Commander", emoji: "üéÆ", desc: "Use 10 different commands" },
            // Add more achievements with placeholders...
        ];
        
        // Generate placeholder achievements for the remaining slots
        for (let i = achievementData.length; i < TOTAL_ACHIEVEMENTS; i++) {
            const emojis = ["‚≠ê", "üéØ", "üèÜ", "üî•", "üíé", "üöÄ", "üé™", "üé≠", "üé∏", "üé¨", "üé≤", "üé¥", "üé®", "üé≠", "üé™", "üéØ"];
            achievementData.push({
                id: i,
                name: `Achievement ${i + 1}`,
                emoji: emojis[i % emojis.length],
                desc: `Mystery achievement #${i + 1} - discover to find out more!`
            });
        }
        
        // Load found achievements from localStorage
        function loadAchievements() {
            const saved = localStorage.getItem('achievements');
            if (saved) {
                foundAchievements = new Set(JSON.parse(saved));
                    } else {
                // First visit - unlock welcome achievement
                unlockAchievement(0);
            }
            updateAchievementStats();
        }
        
        // Save achievements to localStorage
        function saveAchievements() {
            localStorage.setItem('achievements', JSON.stringify(Array.from(foundAchievements)));
            updateAchievementStats();
        }
        
        // Unlock an achievement
        function unlockAchievement(id) {
            if (!foundAchievements.has(id)) {
                foundAchievements.add(id);
                saveAchievements();
                renderAchievements();
            }
        }
        
        // Update achievement statistics
        function updateAchievementStats() {
            const foundCount = document.getElementById('found-count');
            const totalCount = document.getElementById('total-count');
            if (foundCount) foundCount.textContent = foundAchievements.size;
            if (totalCount) totalCount.textContent = TOTAL_ACHIEVEMENTS;
        }
        
        // Generate 16x16 pixel art patterns for achievements
        function generatePixelPattern(achievementId) {
            const patterns = {
                0: (() => {
                    // Welcome - smiley face
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 3 && x <= 12 && y >= 3 && y <= 10) p[i] = '#FFA500'; // Face
                            if ((x === 5 || x === 10) && (y === 5 || y === 6)) p[i] = '#000000'; // Eyes
                            if (x >= 6 && x <= 9 && y === 9) p[i] = '#000000'; // Mouth
                        }
                    }
                    return p;
                })(),
                1: (() => {
                    // Explorer - compass
                    const p = Array(256).fill('#000000');
                    const center = 8;
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - center;
                            const dy = y - center;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= 6) p[i] = '#C0C0C0';
                            if (dist <= 5) p[i] = '#808080';
                            if ((x === center || y === center) && dist <= 7) p[i] = '#FFD700';
                        }
                    }
                    return p;
                })(),
                2: (() => {
                    // Color Master - palette
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 2 && x <= 13 && y >= 2 && y <= 13) {
                                const section = Math.floor((x - 2) / 3);
                                const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                                p[i] = colors[section % 4];
                            }
                        }
                    }
                    return p;
                })(),
                4: (() => {
                    // Sweeper Pro - bomb
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 36) p[i] = '#333333';
                            if (dx*dx + dy*dy <= 25) p[i] = '#000000';
                            if (x >= 7 && x <= 9 && y >= 2 && y <= 5) p[i] = '#FF0000';
                        }
                    }
                    return p;
                })(),
                5: (() => {
                    // Pong Champion - paddle
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 13) p[i] = '#FFFFFF';
                            if (x === 7 || x === 8) {
                                if (y >= 4 && y <= 6) p[i] = '#000000';
                                if (y >= 9 && y <= 11) p[i] = '#000000';
                            }
                        }
                    }
                    return p;
                })(),
                6: (() => {
                    // Coinflip Streak - coin
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 49) p[i] = '#FFD700';
                            if (dx*dx + dy*dy <= 42) p[i] = '#FFA500';
                            if (x === 8 && y >= 3 && y <= 12) p[i] = '#000000';
                        }
                    }
                    return p;
                })(),
                7: (() => {
                    // Rich - money bag
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 4 && x <= 11 && y >= 4 && y <= 12) p[i] = '#00AA00';
                            if (x >= 5 && x <= 10 && y >= 5 && y <= 11) p[i] = '#008800';
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 4) p[i] = '#888888';
                            if (x === 7 || x === 8) {
                                if (y === 6 || y === 8 || y === 10) p[i] = '#FFD700';
                            }
                        }
                    }
                    return p;
                })(),
            };
            
            // Use specific pattern or generate unique one
            if (patterns[achievementId]) {
                return patterns[achievementId];
            }
            
            // Generate unique pattern for each achievement
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#FF69B4', '#00FF7F'];
            const seed = achievementId * 137; // Unique seed per achievement
            return Array(256).fill(0).map((_, i) => {
                const x = i % 16;
                const y = Math.floor(i / 16);
                const hash = ((x * seed + y) * 17) % 100;
                if (hash < 30) return colors[achievementId % colors.length];
                if (hash < 50) return colors[(achievementId * 3) % colors.length];
                if (hash < 60) return colors[(achievementId * 7) % colors.length];
                return '#202020';
            });
        }
        
        // Render achievements grid
        function renderAchievements() {
            const grid = document.getElementById('achievements-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let i = 0; i < TOTAL_ACHIEVEMENTS; i++) {
                const achievement = achievementData[i];
                const isFound = foundAchievements.has(i);
                
                const sprite = document.createElement('div');
                sprite.className = `achievement-sprite ${isFound ? 'found' : ''}`;
                sprite.dataset.id = i;
                
                // Create pixel sprite
                const pixelPattern = generatePixelPattern(i);
                for (let j = 0; j < 256; j++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.backgroundColor = pixelPattern[j];
                    sprite.appendChild(pixel);
                }
                
                // Tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'tooltip-name';
                nameSpan.textContent = achievement.name;
                tooltip.appendChild(nameSpan);
                
                if (isFound) {
                    const descSpan = document.createElement('span');
                    descSpan.className = 'tooltip-desc';
                    descSpan.textContent = achievement.desc;
                    tooltip.appendChild(descSpan);
                }
                
                sprite.appendChild(tooltip);
                grid.appendChild(sprite);
            }
            
            updateAchievementStats();
        }
        
        // Initialize achievements on page load
        loadAchievements();
        
        // Achievement triggers
        let colorChangeCount = 0;
        let commandsUsed = new Set();
        
        // Override changeAllColors to track achievements
        const originalChangeAllColors = changeAllColors;
        changeAllColors = function(colorName) {
            originalChangeAllColors(colorName);
            colorChangeCount++;
            if (colorChangeCount >= 10) unlockAchievement(2);
            
            if (colorName === 'rainbow') {
                unlockAchievement(3);
            }
        };
        
        // Track navigation for achievements - override showPage
        const originalShowPageForAchievements = showPage;
        showPage = function(pageId) {
            originalShowPageForAchievements(pageId);
            
            // Stop goose rain animation if leaving
            if (pageId !== 'gooserainPage' && animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Stop stones animation if leaving
            if (pageId !== 'stonesPage' && stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
                stonesAnimationId = null;
                // Remove key handler when leaving
                if (stonesKeyHandler) {
                    document.removeEventListener('keydown', stonesKeyHandler);
                    stonesKeyHandler = null;
                }
            }
            
            // Update money displays on page change
            updateAllMoneyDisplays();
            
            if (pageId === 'homePage') {
                unlockAchievement(1);
            } else if (pageId === 'minesweeperPage') {
                commandsUsed.add('sweeper');
            } else if (pageId === 'pongPage') {
                unlockAchievement(5);
                commandsUsed.add('pong');
            } else if (pageId === 'sandboxelsPage') {
                unlockAchievement(10);
                commandsUsed.add('sandboxles');
            } else if (pageId === 'coinflipPage') {
                commandsUsed.add('coinflip');
            } else if (pageId === 'clickerPage') {
                commandsUsed.add('clicker');
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            } else if (pageId === 'stonesPage') {
                commandsUsed.add('stones');
            }
            
            if (commandsUsed.size >= 10) {
                unlockAchievement(11);
            }
        };
        
        // Track Minesweeper win
        const originalGameOver = gameOver;
        gameOver = function(win) {
            originalGameOver(win);
            if (win) {
                unlockAchievement(4);
            }
        };
        
        // Track coinflip achievements - hook into guessCoin function
        let coinflipWins = 0;
        const originalGuessCoinFunc = guessCoin;
        guessCoin = function(guess) {
            const oldStreak = coinflipStreak;
            originalGuessCoinFunc(guess);
            
            // Check achievements after the coin flip completes
            setTimeout(() => {
                if (coinflipStreak > oldStreak) {
                    coinflipWins++;
                    if (coinflipStreak >= 5) unlockAchievement(6);
                    if (coinflipWins >= 10 && coinflipStreak >= 10) unlockAchievement(8);
                }
                
                if (globalMoney >= 100) unlockAchievement(7);
            }, 1500);
        };
        
        // Track shop upgrades - hook into buyUpgrade function
        const originalBuyUpgradeFunc = buyUpgrade;
        buyUpgrade = function() {
            originalBuyUpgradeFunc();
            setTimeout(() => {
                if (winChanceUpgrades >= 5) {
                    unlockAchievement(9);
                }
            }, 100);
        };
    </script>
</body>
</html>
