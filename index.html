<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinHub - Finley Chang</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #0d1117;
            min-height: 100vh;
            padding: 20px;
        }
        
        .page {
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .page.hidden {
            display: none;
        }
        
        .home-page {
            text-align: center;
        }
        
        .home-page h1 {
            color: #c9d1d9;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .home-page p {
            color: #8b949e;
            font-size: 18px;
        }
        
        .home-page a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 20px;
            margin-top: 20px;
            display: inline-block;
            padding: 12px 24px;
            border: 1px solid #58a6ff;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .home-page a:hover {
            background: rgba(88, 166, 255, 0.1);
            color: #79c0ff;
            transform: translateY(-2px);
        }
        
        /* Minesweeper game styles */
        .minesweeper-page {
            background-color: #eee;
            font-family: Arial, sans-serif;
        }
        
        #minesweeper-game-container {
            display: inline-block;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
        }
        
        .minesweeper-grid {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
        }
        
        .cell {
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            background-color: #d1d1d1;
            border: 1px solid transparent;
            border-color: #fff #808080 #808080 #fff;
        }
        
        .cell.revealed {
            background-color: #c0c0c0;
            border: 1px solid #808080;
            border-color: #808080 #fff #fff #808080;
        }
        
        .cell.flag {
            color: red;
            font-size: 18px;
        }
        
        .cell.mine {
            background-color: red;
            color: black;
        }
        
        .cell.number-1 { color: blue; }
        .cell.number-2 { color: green; }
        .cell.number-3 { color: red; }
        .cell.number-4 { color: darkblue; }
        .cell.number-5 { color: darkred; }
        .cell.number-6 { color: teal; }
        .cell.number-7 { color: black; }
        .cell.number-8 { color: gray; }
        
        #message {
            margin-top: 5px;
            font-size: 20px;
            font-weight: bold;
            height: 25px;
            color: #333;
        }
        
        #restart-btn {
            padding: 8px 15px;
            margin-bottom: 15px;
            font-size: 16px;
            cursor: pointer;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
            background-color: #d1d1d1;
            font-weight: bold;
        }
        
        #restart-btn:active {
            border-top: 4px solid #808080;
            border-left: 4px solid #808080;
            border-bottom: 4px solid #fff;
            border-right: 4px solid #fff;
        }
        
        /* Pong game styles */
        .pong-page {
            background-color: #1a1a1a;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            color: white;
        }
        
        #pongCanvas {
            border: 4px solid #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            background-color: #000;
        }
        
        .pong-info {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .pong-button-style {
            transition: all 0.1s;
            box-shadow: 0 4px #2c2c2c;
            position: relative;
            top: 0;
        }
        
        .pong-button-style:active {
            box-shadow: 0 0 #2c2c2c;
            top: 4px;
        }
        
        .pong-settings-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .pong-settings-modal.hidden {
            display: none;
        }
        
        .pong-settings-content {
            background: #1f2937;
            padding: 24px;
            border-radius: 12px; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 320px;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content h3 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
            color: white;
            text-align: center;
        }
        
        .pong-settings-content label {
            display: block;
            color: #e5e7eb;
            margin-bottom: 4px;
        }
        
        .pong-settings-content select,
        .pong-settings-content input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: #111827;
            color: white;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content select:focus,
        .pong-settings-content input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 1px white;
        }
        
        .pong-settings-content button {
            width: 100%;
            margin-top: 16px;
        }
        
        /* Sandboxels page styles */
        .sandboxels-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            background-color: white;
            border: none;
            display: flex;
            flex-direction: column;
        }
        
        .sandboxels-iframe {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            padding: 0;
        }
        
        .sandboxels-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100000;
            padding: 10px 15px;
            background-color: #d9534f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .sandboxels-close-btn:hover {
            background-color: #c9302c;
        }
        
        /* Coinflip page styles */
        .coinflip-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        .coinflip-page button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .coinflip-page button:active {
            transform: scale(0.95);
        }
        
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(900deg); }
            100% { transform: rotateY(1800deg); }
        }
        
        .coin-flipping {
            animation: coinFlip 1s ease-in-out;
        }
        
        /* Jumpscare overlay */
        .jumpscare-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
        }
        
        .jumpscare-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .jumpscare-overlay.active .jumpscare-image {
            animation: jumpscarePop 0.3s ease-out, jumpscareFade 0.5s ease-in 0.8s forwards;
        }
        
        .jumpscare-image {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            transform: scale(0.1);
            opacity: 0;
        }
        
        @keyframes jumpscarePop {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes jumpscareFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.9);
            }
        }
        
        /* Shop page styles */
        .shop-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .upgrade-item {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 20px;
            margin: 15px auto;
            max-width: 400px;
            color: #c9d1d9;
        }
        
        .upgrade-item h3 {
            color: #58a6ff;
            margin: 0 0 10px 0;
            font-size: 20px;
        }
        
        .upgrade-item p {
            margin: 5px 0;
            font-size: 14px;
            color: #8b949e;
        }
        
        .upgrade-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upgrade-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .upgrade-btn:disabled {
            background: #30363d;
            color: #8b949e;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Limbo page styles */
        .limbo-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Panic menu page styles */
        .panicmenu-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Achievements page styles */
        .achievements-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            grid-template-rows: repeat(16, 32px);
            gap: 4px;
            background: #161b22;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #30363d;
            margin: 20px auto;
            max-width: fit-content;
        }
        
        .achievement-sprite {
            width: 32px;
            height: 32px;
            border: 2px solid #30363d;
            border-radius: 4px;
            background: #21262d;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: grid;
            grid-template-columns: repeat(16, 2px);
            grid-template-rows: repeat(16, 2px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            filter: grayscale(100%) brightness(0.3);
        }
        
        .achievement-sprite.found {
            filter: none;
            border-color: #58a6ff;
            background: #161b22;
        }
        
        .pixel {
            width: 2px;
            height: 2px;
        }
        
        /* Clicker page styles */
        .clicker-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        #clicker-button:active {
            transform: scale(0.95);
        }
        
        #clicker-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(35, 134, 54, 0.5);
        }
        
        .achievement-sprite:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.5);
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .achievement-sprite:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-tooltip .tooltip-name {
            font-weight: bold;
            color: #58a6ff;
            margin-bottom: 4px;
            display: block;
        }
        
        .achievement-tooltip .tooltip-desc {
            color: #8b949e;
            font-size: 11px;
            white-space: normal;
            max-width: 200px;
            text-align: left;
        }
        
        .finhub-title {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .big-letter {
            display: grid;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            color: #c9d1d9;
            gap: 0;
        }
        
        .big-letter .small-letter {
            display: inline-block;
            width: 8px;
            height: 8px;
            text-align: center;
        }
        
        /* Big F made of small letters - 3 thick, 2x tall */
        .letter-f {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big i made of small letters - 3 thick, 2x tall */
        .letter-i {
            grid-template-columns: repeat(9, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big n made of small letters - 3 thick, 2x tall */
        .letter-n {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big H made of small letters - 3 thick, 2x tall */
        .letter-h {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big u made of small letters - 3 thick, 2x tall */
        .letter-u {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big b made of small letters - 3 thick, 2x tall */
        .letter-b {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Colors for small letters */
        .small-letter.f { color: #58a6ff; }
        .small-letter.i { color: #f0883e; }
        .small-letter.n { color: #bc8cff; }
        .small-letter.l { color: #3fb950; }
        .small-letter.e { color: #f85149; }
        .small-letter.y { color: #ffa657; }
        
        .subtitle {
            color: #8b949e;
            font-size: 18px;
            text-align: center;
            margin-top: 20px;
        }
        
        .letters-source {
            color: #6e7681;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        /* Clock display in top left */
        .clock-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 15px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .clock-display.hidden {
            display: none;
        }
        
        /* Command feedback display */
        .command-feedback {
            position: fixed;
            bottom: 70px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 400px;
            z-index: 998;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-feedback.hidden {
            display: none;
        }
        
        .command-feedback .command-text {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-feedback .feedback-text {
            color: #8b949e;
            margin-left: 8px;
        }
        
        .command-feedback.success {
            border-color: #3fb950;
        }
        
        .command-feedback.success .command-text {
            color: #3fb950;
        }
        
        .command-feedback.error {
            border-color: #f85149;
        }
        
        .command-feedback.error .command-text,
        .command-feedback.error .feedback-text {
            color: #f85149;
        }
        
        /* Terms and Agreements Modal */
        .terms-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .terms-modal.show {
            display: flex;
        }
        
        .terms-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .terms-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .terms-text {
            line-height: 1.8;
            margin-bottom: 25px;
        }
        
        .terms-text p {
            margin-bottom: 15px;
        }
        
        .terms-text ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .terms-text li {
            margin-bottom: 10px;
        }
        
        .terms-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .terms-agree-btn,
        .terms-disagree-btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .terms-agree-btn {
            background: #238636;
            color: white;
        }
        
        .terms-agree-btn:hover {
            background: #2ea043;
        }
        
        .terms-disagree-btn {
            background: #30363d;
            color: #c9d1d9;
        }
        
        .terms-disagree-btn:hover {
            background: #484f58;
        }
        
        /* Edit Profile Modal */
        .edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .edit-modal.show {
            display: flex;
        }
        
        .edit-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .edit-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 25px;
            font-size: 24px;
        }
        
        .edit-field {
            margin-bottom: 20px;
        }
        
        .edit-field label {
            display: block;
            color: #c9d1d9;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .edit-field input,
        .edit-field textarea {
            width: 100%;
            padding: 10px 15px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        .edit-field input:focus,
        .edit-field textarea:focus {
            outline: none;
            border-color: #58a6ff;
        }
        
        .edit-field textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .edit-field small {
            display: block;
            color: #8b949e;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .emoji-picker {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .emoji-preview {
            width: 80px;
            height: 80px;
            background: #0d1117;
            border: 2px solid #30363d;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .emoji-preview:hover {
            border-color: #58a6ff;
            transform: scale(1.1);
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
        }
        
        .emoji-option {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .emoji-option:hover {
            background: #21262d;
            border-color: #58a6ff;
            transform: scale(1.2);
        }
        
        .emoji-option.selected {
            background: #1f6feb;
            border-color: #58a6ff;
        }
        
        .edit-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 25px;
        }
        
        .edit-save-btn,
        .edit-cancel-btn {
            padding: 10px 25px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-save-btn {
            background: #238636;
            color: white;
        }
        
        .edit-save-btn:hover {
            background: #2ea043;
        }
        
        .edit-cancel-btn {
            background: #30363d;
            color: #c9d1d9;
        }
        
        .edit-cancel-btn:hover {
            background: #484f58;
        }
        
        /* Command History Display */
        .command-history {
            position: fixed;
            bottom: 110px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 500px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 997;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: none;
        }
        
        .command-history.visible {
            display: block;
        }
        
        /* Chat Page Styles */
        .chat-container {
            width: 90%;
            max-width: 900px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .chat-header {
            padding: 15px 20px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-header h2 {
            color: #c9d1d9;
            font-size: 20px;
            margin: 0;
        }
        
        .online-users {
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .online-users-title {
            color: #58a6ff;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }
        
        .online-user-item {
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(48, 54, 61, 0.5);
            border-radius: 4px;
            cursor: pointer;
            color: #c9d1d9;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .online-user-item:hover {
            background: rgba(48, 54, 61, 0.8);
        }
        
        .online-user-item .user-id {
            font-weight: bold;
            color: #58a6ff;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #0d1117;
        }
        
        .chat-message {
            margin-bottom: 15px;
            padding: 10px 15px;
            background: rgba(22, 27, 34, 0.8);
            border-left: 3px solid #58a6ff;
            border-radius: 6px;
        }
        
        .chat-message.own-message {
            border-left-color: #3fb950;
            background: rgba(13, 17, 23, 0.9);
        }
        
        .chat-message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .chat-message-user {
            font-weight: bold;
            color: #58a6ff;
            font-size: 13px;
            cursor: pointer;
        }
        
        .chat-message.own-message .chat-message-user {
            color: #3fb950;
        }
        
        .chat-message-time {
            color: #8b949e;
            font-size: 11px;
        }
        
        .chat-message-text {
            color: #c9d1d9;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        .chat-input-container {
            display: flex;
            padding: 15px 20px;
            background: #161b22;
            border-top: 1px solid #30363d;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px 15px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 14px;
            font-family: inherit;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #58a6ff;
        }
        
        .chat-send-btn {
            padding: 10px 20px;
            background: #238636;
            border: 1px solid #2ea043;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .chat-send-btn:hover {
            background: #2ea043;
        }
        
        .chat-send-btn:disabled {
            background: #30363d;
            border-color: #30363d;
            cursor: not-allowed;
        }
        
        .chat-back-btn {
            padding: 8px 15px;
            background: #30363d;
            border: 1px solid #484f58;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-back-btn:hover {
            background: #484f58;
        }
        
        /* Friends Modal */
        .friends-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .friends-modal.show {
            display: flex;
        }
        
        .friends-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .friends-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .friends-list {
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .friend-item {
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid #30363d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .friend-item:hover {
            background: rgba(22, 27, 34, 0.9);
            border-color: #58a6ff;
            transform: translateX(5px);
        }
        
        .friend-avatar {
            font-size: 32px;
        }
        
        .friend-info {
            flex: 1;
        }
        
        .friend-name {
            font-weight: bold;
            color: #58a6ff;
            font-size: 14px;
        }
        
        .friend-bio {
            color: #8b949e;
            font-size: 12px;
            margin-top: 2px;
        }
        
        .friends-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
        }
        
        .friends-close-btn {
            padding: 10px 25px;
            background: #30363d;
            border: none;
            border-radius: 6px;
            color: #c9d1d9;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .friends-close-btn:hover {
            background: #484f58;
        }
        
        /* Visit Counter */
        .visit-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 2px solid #58a6ff;
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 998;
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.3);
            text-align: center;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 20px rgba(88, 166, 255, 0.3);
            }
            50% {
                box-shadow: 0 4px 30px rgba(88, 166, 255, 0.6), 0 0 40px rgba(88, 166, 255, 0.3);
            }
        }
        
        .visit-counter-number {
            font-size: 32px;
            font-weight: bold;
            color: #58a6ff;
            text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% {
                text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            }
            50% {
                text-shadow: 0 0 20px rgba(88, 166, 255, 0.8), 0 0 30px rgba(88, 166, 255, 0.4);
            }
        }
        
        .visit-counter-label {
            font-size: 11px;
            color: #8b949e;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .command-history-header {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #30363d;
            font-size: 12px;
        }
        
        .command-history-entry {
            margin-bottom: 6px;
            padding: 4px 0;
            line-height: 1.4;
        }
        
        .command-history-entry .command-text {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-history-entry .feedback-text {
            color: #8b949e;
            margin-left: 8px;
        }
        
        .command-history-entry.success .command-text,
        .command-history-entry.success .feedback-text {
            color: #3fb950;
        }
        
        .command-history-entry.error .command-text,
        .command-history-entry.error .feedback-text {
            color: #f85149;
        }
        
        .command-history-toggle {
            position: fixed;
            bottom: 70px;
            left: 420px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 4px 8px;
            color: #8b949e;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            z-index: 996;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            user-select: none;
        }
        
        .command-history-toggle:hover {
            color: #c9d1d9;
            border-color: #58a6ff;
        }
        
        @media (max-width: 768px) {
            .command-history-toggle {
                left: 20px;
                bottom: 110px;
            }
        }
        
        /* Command bar in bottom left */
        .command-bar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-bar::before {
            content: '>';
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-input {
            background: transparent;
            border: none;
            outline: none;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex: 1;
        }
        
        .command-input::placeholder {
            color: #6e7681;
        }
        
        /* Commands menu - draggable tab */
        .commands-menu {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            right: -300px;
            width: 300px;
            max-height: 500px;
            background: rgba(13, 17, 23, 0.98);
            border: 1px solid #30363d;
            border-right: none;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .commands-menu.open {
            right: 0;
        }
        
        .commands-menu.dragging {
            transform: none;
            transition: none;
        }
        
        .commands-menu-header {
            background: #161b22;
            padding: 12px 16px;
            border-bottom: 1px solid #30363d;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .commands-menu-header h3 {
            color: #c9d1d9;
            font-size: 16px;
            margin: 0;
        }
        
        .commands-menu-close {
            background: none;
            border: none;
            color: #8b949e;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .commands-menu-close:hover {
            color: #c9d1d9;
        }
        
        .commands-list {
            padding: 16px;
        }
        
        .command-category {
            margin-bottom: 20px;
        }
        
        .command-category h4 {
            color: #58a6ff;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .command-item {
            color: #c9d1d9;
            font-size: 13px;
            padding: 6px 0;
            font-family: 'Courier New', monospace;
        }
        
        .command-item .command-name {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-item .command-desc {
            color: #8b949e;
            margin-left: 8px;
        }
        
        @media (max-width: 768px) {
            .finhub-title {
                font-size: 48px;
            }
            .command-bar {
                min-width: 200px;
                bottom: 10px;
                left: 10px;
            }
            .commands-menu {
                width: 250px;
                right: -250px;
            }
        }

/* Theme System Styles */
body.theme-1995 {
    font-family: 'MS Sans Serif', 'MS Sans Serif', sans-serif;
    background: #c0c0c0 !important;
    color: #000000;
}

body.theme-1995 .command-bar,
body.theme-1995 .clock-display,
body.theme-1995 .command-feedback,
body.theme-1995 .commands-menu {
    background: #c0c0c0 !important;
    border: 2px outset #c0c0c0 !important;
    box-shadow: inset -1px -1px 0px 0px #808080, inset 1px 1px 0px 0px #ffffff !important;
}

body.theme-1995 .command-input {
    background: #ffffff !important;
    border: 1px inset #c0c0c0 !important;
    color: #000000 !important;
}

body.theme-1995 .page {
    background: #c0c0c0 !important;
}

body.theme-1995 .home-page h1,
body.theme-1995 .subtitle,
body.theme-1995 .letters-source {
    color: #000000 !important;
}

body.theme-1995 button {
    background: #c0c0c0 !important;
    border: 2px outset #c0c0c0 !important;
    color: #000000 !important;
    font-family: 'MS Sans Serif', sans-serif !important;
}

body.theme-1995 button:active {
    border: 2px inset #c0c0c0 !important;
}

body.theme-cyberpunk {
    font-family: 'Orbitron', 'Courier New', monospace;
    background: #0a0a0f !important;
    color: #ff00ff;
    position: relative;
}

body.theme-cyberpunk::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        linear-gradient(90deg, rgba(0, 255, 255, 0.03) 50%, transparent 50%),
        linear-gradient(rgba(255, 0, 255, 0.03) 50%, transparent 50%);
    background-size: 4px 4px;
    pointer-events: none;
    z-index: 1;
}

body.theme-cyberpunk * {
    text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
}

body.theme-cyberpunk .command-bar,
body.theme-cyberpunk .clock-display,
body.theme-cyberpunk .command-feedback,
body.theme-cyberpunk .commands-menu {
    background: rgba(10, 10, 15, 0.95) !important;
    border: 2px solid #00ffff !important;
    box-shadow: 0 0 20px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1) !important;
    color: #ff00ff !important;
}

body.theme-cyberpunk .command-input {
    background: rgba(10, 10, 15, 0.8) !important;
    border: 1px solid #ff00ff !important;
    color: #00ffff !important;
    text-shadow: 0 0 5px #00ffff !important;
}

body.theme-cyberpunk .command-bar::before {
    color: #ff00ff !important;
    text-shadow: 0 0 10px #ff00ff !important;
}

body.theme-cyberpunk .page {
    background: #0a0a0f !important;
}

body.theme-cyberpunk .home-page h1 {
    color: #ff00ff !important;
    text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff !important;
}

body.theme-cyberpunk .subtitle {
    color: #00ffff !important;
    text-shadow: 0 0 10px #00ffff !important;
}

body.theme-cyberpunk button {
    background: rgba(10, 10, 15, 0.9) !important;
    border: 2px solid #ff00ff !important;
    color: #00ffff !important;
    text-shadow: 0 0 10px #00ffff !important;
    box-shadow: 0 0 20px rgba(255, 0, 255, 0.5) !important;
}

body.theme-cyberpunk button:hover {
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.8) !important;
    border-color: #00ffff !important;
}

@keyframes glitch {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-2px, 2px); }
    40% { transform: translate(-2px, -2px); }
    60% { transform: translate(2px, 2px); }
    80% { transform: translate(2px, -2px); }
}

body.theme-cyberpunk .finhub-title {
    animation: glitch 0.3s infinite;
}

body.theme-terminal {
    font-family: 'Courier New', monospace;
    background: #000000 !important;
    color: #00ff00;
    position: relative;
}

body.theme-terminal::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
        0deg,
        rgba(0, 255, 0, 0.03),
        rgba(0, 255, 0, 0.03) 1px,
        transparent 1px,
        transparent 2px
    );
    pointer-events: none;
    z-index: 1;
    animation: scanline 8s linear infinite;
}

@keyframes scanline {
    0% { transform: translateY(0); }
    100% { transform: translateY(100vh); }
}

body.theme-terminal .command-bar,
body.theme-terminal .clock-display,
body.theme-terminal .command-feedback,
body.theme-terminal .commands-menu {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 1px solid #00ff00 !important;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5), inset 0 0 10px rgba(0, 255, 0, 0.1) !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .command-input {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid #00ff00 !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .command-bar::before {
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .page {
    background: #000000 !important;
}

body.theme-terminal .home-page h1,
body.theme-terminal .subtitle,
body.theme-terminal .letters-source {
    color: #00ff00 !important;
    text-shadow: 0 0 10px #00ff00 !important;
}

body.theme-terminal button {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 1px solid #00ff00 !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.3) !important;
}

body.theme-terminal button:hover {
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.6) !important;
}

body.theme-matrix {
    font-family: 'Courier New', monospace;
    background: #000000 !important;
    color: #00ff41;
    position: relative;
    overflow: hidden;
}

body.theme-matrix .command-bar,
body.theme-matrix .clock-display,
body.theme-matrix .command-feedback,
body.theme-matrix .commands-menu {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 1px solid #00ff41 !important;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.5), inset 0 0 10px rgba(0, 255, 65, 0.1) !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .command-input {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid #00ff41 !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .command-bar::before {
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .page {
    background: #000000 !important;
}

body.theme-matrix .home-page h1,
body.theme-matrix .subtitle,
body.theme-matrix .letters-source {
    color: #00ff41 !important;
    text-shadow: 0 0 10px #00ff41 !important;
}

body.theme-matrix button {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 1px solid #00ff41 !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3) !important;
}

body.theme-matrix button:hover {
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.6) !important;
}

/* Matrix falling characters */
.matrix-column {
    position: fixed;
    top: -50px;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    color: #00ff41;
    text-shadow: 0 0 5px #00ff41;
    pointer-events: none;
    z-index: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}

.matrix-column .char {
    display: block;
    opacity: 1;
    height: 18px;
    text-align: center;
}

.matrix-column .char.fade {
    opacity: 0.3;
}

body.theme-coffee {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #3e2723 !important;
    color: #d7ccc8;
    filter: sepia(30%) saturate(80%);
}

body.theme-coffee .command-bar,
body.theme-coffee .clock-display,
body.theme-coffee .command-feedback,
body.theme-coffee .commands-menu {
    background: rgba(94, 53, 45, 0.95) !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee .command-input {
    background: rgba(94, 53, 45, 0.8) !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee .page {
    background: #3e2723 !important;
}

body.theme-coffee .home-page h1,
body.theme-coffee .subtitle,
body.theme-coffee .letters-source {
    color: #d7ccc8 !important;
}

body.theme-coffee button {
    background: #5d4037 !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee button:hover {
    background: #6d4c41 !important;
}

body.theme-light {
    background: #ffffff !important;
    color: #000000;
}

body.theme-light .command-bar,
body.theme-light .clock-display,
body.theme-light .command-feedback,
body.theme-light .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light .command-bar::before {
    color: #0066cc !important;
}

body.theme-light .page {
    background: #ffffff !important;
}

body.theme-light .home-page h1,
body.theme-light .subtitle,
body.theme-light .letters-source {
    color: #000000 !important;
}

body.theme-light button {
    background: #f5f5f5 !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light button:hover {
    background: #e8e8e8 !important;
}

body.theme-dark {
    background: #0d1117 !important;
    color: #c9d1d9;
}

body.theme-dark .command-bar,
body.theme-dark .clock-display,
body.theme-dark .command-feedback,
body.theme-dark .commands-menu {
    background: rgba(13, 17, 23, 0.95) !important;
    border: 1px solid #30363d !important;
    color: #c9d1d9 !important;
}

body.theme-dark .command-input {
    background: transparent !important;
    border: none !important;
    color: #c9d1d9 !important;
}

body.theme-dark .command-bar::before {
    color: #58a6ff !important;
}

body.theme-dark .page {
    background: #0d1117 !important;
}

body.theme-dark .home-page h1,
body.theme-dark .subtitle,
body.theme-dark .letters-source {
    color: #c9d1d9 !important;
}

body.theme-dark button {
    background: #238636 !important;
    border: none !important;
    color: #ffffff !important;
}

body.theme-paper {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px),
        repeating-linear-gradient(90deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
    color: #2c2c2c;
}

body.theme-paper .command-bar,
body.theme-paper .clock-display,
body.theme-paper .command-feedback,
body.theme-paper .commands-menu {
    background: rgba(245, 245, 220, 0.95) !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

body.theme-paper .command-input {
    background: rgba(255, 255, 255, 0.8) !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
}

body.theme-paper .command-bar::before {
    color: #8b4513 !important;
}

body.theme-paper .page {
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px),
        repeating-linear-gradient(90deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
}

body.theme-paper .home-page h1,
body.theme-paper .subtitle,
body.theme-paper .letters-source {
    color: #2c2c2c !important;
}

body.theme-paper button {
    background: #faf0e6 !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

body.theme-paper button:hover {
    background: #f5e6d3 !important;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15) !important;
}

body.theme-space {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #000428 !important;
    background-image: 
        radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-space::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(2px 2px at 20% 30%, #fff, transparent),
        radial-gradient(2px 2px at 60% 70%, #fff, transparent),
        radial-gradient(1px 1px at 50% 50%, #fff, transparent),
        radial-gradient(1px 1px at 80% 10%, #fff, transparent),
        radial-gradient(2px 2px at 90% 40%, #fff, transparent),
        radial-gradient(1px 1px at 33% 60%, #fff, transparent),
        radial-gradient(1px 1px at 70% 80%, #fff, transparent);
    background-size: 200% 200%;
    background-position: 0% 0%;
    pointer-events: none;
    z-index: 1;
    animation: starfield 20s linear infinite;
}

@keyframes starfield {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
}

body.theme-space .command-bar,
body.theme-space .clock-display,
body.theme-space .command-feedback,
body.theme-space .commands-menu {
    background: rgba(0, 4, 40, 0.95) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 15px rgba(74, 144, 226, 0.3) !important;
}

body.theme-space .command-input {
    background: rgba(0, 4, 40, 0.8) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
}

body.theme-space .command-bar::before {
    color: #4a90e2 !important;
}

body.theme-space .page {
    background: #000428 !important;
    background-image: 
        radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
}

body.theme-space .home-page h1,
body.theme-space .subtitle,
body.theme-space .letters-source {
    color: #ffffff !important;
    text-shadow: 0 0 10px rgba(74, 144, 226, 0.5) !important;
}

body.theme-space button {
    background: rgba(0, 4, 40, 0.9) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 10px rgba(74, 144, 226, 0.3) !important;
}

body.theme-space button:hover {
    box-shadow: 0 0 20px rgba(74, 144, 226, 0.6) !important;
}

/* Space theme stars that react to cursor */
.space-star {
    position: fixed;
    width: 2px;
    height: 2px;
    background: #ffffff;
    border-radius: 50%;
    pointer-events: none;
    z-index: 1;
    box-shadow: 0 0 2px #fff;
    transition: transform 0.1s ease-out;
}

body.theme-ocean {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #1e3a5f 100%) !important;
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-ocean::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(255, 255, 255, 0.03) 2px,
            rgba(255, 255, 255, 0.03) 4px
        );
    pointer-events: none;
    z-index: 1;
    animation: oceanWave 3s ease-in-out infinite;
}

@keyframes oceanWave {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

body.theme-ocean .command-bar,
body.theme-ocean .clock-display,
body.theme-ocean .command-feedback,
body.theme-ocean .commands-menu {
    background: rgba(30, 58, 95, 0.95) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 15px rgba(74, 144, 226, 0.3) !important;
}

body.theme-ocean .command-input {
    background: rgba(30, 58, 95, 0.8) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
}

body.theme-ocean .command-bar::before {
    color: #87ceeb !important;
}

body.theme-ocean .page {
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #1e3a5f 100%) !important;
}

body.theme-ocean .home-page h1,
body.theme-ocean .subtitle,
body.theme-ocean .letters-source {
    color: #ffffff !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
}

body.theme-ocean button {
    background: rgba(30, 58, 95, 0.9) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 10px rgba(74, 144, 226, 0.3) !important;
}

body.theme-ocean button:hover {
    box-shadow: 0 0 20px rgba(74, 144, 226, 0.6) !important;
}

/* Ocean theme fish */
.ocean-fish {
    position: fixed;
    pointer-events: none;
    z-index: 2;
    font-size: 30px;
    animation: fishSwim 15s linear infinite;
}

@keyframes fishSwim {
    0% {
        transform: translateX(-100px) translateY(0) scaleX(1);
    }
    49% {
        transform: translateX(calc(100vw + 100px)) translateY(0) scaleX(1);
    }
    50% {
        transform: translateX(calc(100vw + 100px)) translateY(0) scaleX(-1);
    }
    99% {
        transform: translateX(-100px) translateY(0) scaleX(-1);
    }
    100% {
        transform: translateX(-100px) translateY(0) scaleX(1);
    }
}

.ocean-fish.small {
    font-size: 20px;
    animation-duration: 12s;
}

.ocean-fish.medium {
    font-size: 30px;
    animation-duration: 15s;
}

.ocean-fish.large {
    font-size: 40px;
    animation-duration: 18s;
}

body.theme-clouds {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 50%, #B0E0E6 100%) !important;
    color: #2c3e50;
    position: relative;
    overflow: hidden;
}

body.theme-clouds .command-bar,
body.theme-clouds .clock-display,
body.theme-clouds .command-feedback,
body.theme-clouds .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

body.theme-clouds .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
}

body.theme-clouds .command-bar::before {
    color: #4682B4 !important;
}

body.theme-clouds .page {
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 50%, #B0E0E6 100%) !important;
}

body.theme-clouds .home-page h1,
body.theme-clouds .subtitle,
body.theme-clouds .letters-source {
    color: #2c3e50 !important;
    text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5) !important;
}

body.theme-clouds button {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

body.theme-clouds button:hover {
    background: rgba(255, 255, 255, 1) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* Clouds theme - animated clouds */
.cloud {
    position: fixed;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50px;
    pointer-events: none;
    z-index: 1;
    opacity: 0.7;
    animation: cloudFloat 20s linear infinite;
}

@keyframes cloudFloat {
    0% {
        transform: translateX(-200px) translateY(0);
    }
    100% {
        transform: translateX(calc(100vw + 200px)) translateY(0);
    }
}

.cloud::before,
.cloud::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50px;
}

.cloud::before {
    width: 50px;
    height: 50px;
    top: -25px;
    left: 10px;
}

.cloud::after {
    width: 60px;
    height: 60px;
    top: -35px;
    right: 10px;
}

body.theme-flashcard {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
    color: #2c2c2c;
    position: relative;
}

body.theme-flashcard .command-bar,
body.theme-flashcard .clock-display,
body.theme-flashcard .command-feedback,
body.theme-flashcard .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
}

body.theme-flashcard .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
}

body.theme-flashcard .command-bar::before {
    color: #8b4513 !important;
}

body.theme-flashcard .page {
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
}

body.theme-flashcard .home-page h1,
body.theme-flashcard .subtitle,
body.theme-flashcard .letters-source {
    color: #2c2c2c !important;
}

body.theme-flashcard button {
    background: #fffef7 !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
}

body.theme-flashcard button:hover {
    background: #f5f5dc !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
}

/* Flashcard theme - interactive flashcards */
.flashcard {
    position: fixed;
    width: 300px;
    height: 200px;
    background: #fffef7;
    border: 3px solid #8b7355;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    padding: 20px;
    cursor: pointer;
    z-index: 10;
    font-family: 'Georgia', serif;
    font-size: 18px;
    color: #2c2c2c;
    overflow: hidden;
    resize: both;
    min-width: 200px;
    min-height: 150px;
}

.flashcard.dragging {
    opacity: 0.8;
    z-index: 1000;
}

.flashcard-header {
    font-weight: bold;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 2px solid #8b7355;
    user-select: none;
    cursor: move;
}

.flashcard-content {
    min-height: 100px;
    outline: none;
    overflow-y: auto;
}

.flashcard-close {
    position: absolute;
    top: 5px;
    right: 10px;
    background: #f85149;
    color: white;
    border: none;
    border-radius: 4px;
    width: 24px;
    height: 24px;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    z-index: 11;
}

.flashcard-close:hover {
    background: #d73a49;
}

/* Remote Desktop - Windows 95 style */
.desktop-icon {
    width: 80px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    padding: 4px;
    margin: 4px;
    position: relative;
}

.desktop-icon:hover {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 2px;
}

.desktop-icon.selected {
    background: rgba(0, 0, 128, 0.3);
    border: 1px dashed #000080;
    border-radius: 2px;
}

.desktop-icon-icon {
    width: 32px;
    height: 32px;
    margin: 0 auto 4px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.desktop-icon-label {
    font-size: 11px;
    color: #fff;
    text-shadow: 1px 1px 1px #000;
    word-break: break-word;
    line-height: 1.2;
}

.context-menu {
    font-family: 'MS Sans Serif', Arial, sans-serif;
}

.context-menu-item {
    padding: 4px 20px;
    cursor: pointer;
    font-size: 11px;
    background: transparent;
    border: none;
    text-align: left;
    width: 100%;
}

.context-menu-item:hover {
    background: #000080;
    color: #fff;
}

.context-menu.hidden {
    display: none;
}

/* Windows 95 style windows */
.win95-window {
    position: fixed;
    background: #c0c0c0;
    border: 2px outset #c0c0c0;
    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    z-index: 100;
    min-width: 300px;
    min-height: 200px;
    display: flex;
    flex-direction: column;
}

.win95-window-header {
    background: #000080;
    color: #fff;
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    user-select: none;
}

.win95-window-title {
    flex: 1;
}

.win95-window-controls {
    display: flex;
    gap: 2px;
}

.win95-window-button {
    width: 16px;
    height: 14px;
    background: #c0c0c0;
    border: 1px outset #c0c0c0;
    cursor: pointer;
    font-size: 10px;
    line-height: 12px;
    text-align: center;
    padding: 0;
}

.win95-window-button:hover {
    background: #d4d0c8;
}

.win95-window-button:active {
    border: 1px inset #c0c0c0;
}

.win95-window-content {
    flex: 1;
    background: #c0c0c0;
    padding: 8px;
    overflow: auto;
    border: 2px inset #c0c0c0;
}

.win95-window.minimized {
    display: none;
}

/* Paper app window */
.paper-app-content {
    background: #fff;
    width: 100%;
    height: 100%;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    border: 1px inset #c0c0c0;
    outline: none;
    overflow: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Paint app window */
.paint-app-content {
    background: #fff;
    width: 100%;
    height: 100%;
    border: 1px inset #c0c0c0;
    position: relative;
}

.paint-app-canvas {
    width: 100%;
    height: 100%;
    cursor: crosshair;
    display: block;
}

.paint-app-toolbar {
    background: #c0c0c0;
    border-bottom: 1px solid #808080;
    padding: 4px;
    display: flex;
    gap: 4px;
    align-items: center;
}

.paint-app-color-picker {
    width: 30px;
    height: 20px;
    border: 1px inset #c0c0c0;
    cursor: pointer;
}

.paint-app-brush-size {
    width: 60px;
    height: 20px;
    border: 1px inset #c0c0c0;
    font-size: 11px;
    padding: 0 4px;
}

/* Trash can drag over effect */
.trash-can-drag-over {
    background: rgba(255, 0, 0, 0.3) !important;
    border: 2px dashed #ff0000 !important;
}
    </style>
</head>
<body>
    <!-- Main page with FinHub title -->
    <div class="page" id="mainPage">
        <div class="finhub-title">
            <!-- Big F made of small letters -->
            <div class="big-letter letter-f" id="letter-f"></div>
            <!-- Big i made of small letters -->
            <div class="big-letter letter-i" id="letter-i"></div>
            <!-- Big n made of small letters -->
            <div class="big-letter letter-n" id="letter-n"></div>
            <!-- Big H made of small letters -->
            <div class="big-letter letter-h" id="letter-h"></div>
            <!-- Big u made of small letters -->
            <div class="big-letter letter-u" id="letter-u"></div>
            <!-- Big b made of small letters -->
            <div class="big-letter letter-b" id="letter-b"></div>
        </div>
        
        <p class="subtitle">Built with code, powered by Finley</p>
        <p class="letters-source">Spelled with letters from: F-I-N-L-E-Y</p>
        <!-- Canvas for wooperbird goose on main page -->
        <canvas id="wooperbirdCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></canvas>
                </div>
    
    <!-- Home page -->
    <div class="page home-page hidden" id="homePage">
        <h1>Welcome to the home</h1>
        <p>Type "back" in the command bar to return</p>
        <a href="https://sso.browardschools.com/" target="_blank">Broward Schools Login</a>
            </div>
    
    <!-- Minesweeper page -->
    <div class="page minesweeper-page hidden" id="minesweeperPage" oncontextmenu="return false;">
        <button id="restart-btn">Restart Game</button>
        <div id="message">Flags Remaining: 10</div>
        <div id="minesweeper-game-container">
            <div class="minesweeper-grid" id="minesweeper-grid"></div>
        </div>
    </div>

    <!-- Pong page -->
    <div class="page sandboxels-page hidden" id="pongPage">
        <iframe id="pong-iframe" class="sandboxels-iframe" src="https://web-pong.com/" name="pong_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closePong()">X CLOSE VIEW (Return to finleychang.com)</button>
                    </div>
    
    <!-- Sandboxels page -->
    <div class="page sandboxels-page hidden" id="sandboxelsPage">
        <iframe id="sandboxels-iframe" class="sandboxels-iframe" src="https://shalbito.vercel.app/" name="sandboxels_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closeSandboxels()">X CLOSE VIEW (Return to finleychang.com)</button>
        </div>
        
    <!-- Paint page -->
    <div class="page sandboxels-page hidden" id="paintPage">
        <canvas id="paintCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: black; font-size: 16px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); z-index: 1000; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px;">
            <div>Brush Size: <span id="paint-brush-size">5</span></div>
            <div style="margin-top: 10px;">
                <label for="paint-color-picker" style="display: block; margin-bottom: 5px;">Color:</label>
                <input type="color" id="paint-color-picker" value="#000000" style="width: 60px; height: 30px; cursor: pointer; border: 2px solid #333; border-radius: 4px;">
                <span id="paint-color-display" style="margin-left: 10px;">#000000</span>
            </div>
            </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
        
    <!-- Collaborative Drawing Board page -->
    <div class="page sandboxels-page hidden" id="drawingBoardPage">
        <canvas id="drawingBoardCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: black; font-size: 16px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); z-index: 1000; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; min-width: 250px;">
            <div style="margin-bottom: 10px;">
                <strong>Collaborative Drawing Board</strong>
            </div>
            <div style="margin-bottom: 10px;">
                <div>Brush Size: <span id="drawing-brush-size">5</span></div>
                <input type="range" id="drawing-brush-size-slider" min="1" max="50" value="5" style="width: 100%; margin-top: 5px;">
            </div>
            <div style="margin-top: 10px;">
                <label for="drawing-color-picker" style="display: block; margin-bottom: 5px;">Color:</label>
                <input type="color" id="drawing-color-picker" value="#000000" style="width: 60px; height: 30px; cursor: pointer; border: 2px solid #333; border-radius: 4px;">
                <span id="drawing-color-display" style="margin-left: 10px;">#000000</span>
            </div>
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ccc;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Active Users: <span id="drawing-user-count">1</span></div>
                <button onclick="clearDrawingBoard()" style="padding: 8px 15px; font-size: 14px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px;">Clear Canvas</button>
            </div>
        </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
    </div>
    
    <!-- Remote Desktop page -->
    <div class="page remote-desktop-page hidden" id="remoteDesktopPage">
        <div id="remoteDesktop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #008080; font-family: 'MS Sans Serif', Arial, sans-serif; overflow: hidden;">
            <!-- Desktop Icons Container -->
            <div id="desktopIcons" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 40px); padding: 10px;">
                <!-- Icons will be added here dynamically -->
            </div>
            
            <!-- Taskbar -->
            <div id="taskbar" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40px; background: #c0c0c0; border-top: 2px solid #ffffff; display: flex; align-items: center; padding: 0 4px; z-index: 1000;">
                <button id="startButton" style="height: 32px; padding: 0 12px; background: #c0c0c0; border: 2px outset #c0c0c0; font-family: 'MS Sans Serif', Arial, sans-serif; font-size: 11px; font-weight: bold; cursor: pointer; margin-right: 4px;">Start</button>
                <div id="taskbarApps" style="flex: 1; display: flex; align-items: center; gap: 2px;"></div>
            </div>
            
            <!-- Context Menu -->
            <div id="desktopContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" data-action="add-paper" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">New Paper</div>
                <div class="context-menu-item" data-action="add-paint" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">New Paint</div>
            </div>
            
            <!-- Icon Context Menu -->
            <div id="iconContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" onclick="openSelectedIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Open</div>
                <div class="context-menu-item" onclick="renameDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Rename</div>
                <div class="context-menu-item" onclick="deleteDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Delete</div>
            </div>
            
            <!-- Computer Context Menu -->
            <div id="computerContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" onclick="powerOffDesktop()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Power Off</div>
            </div>
        </div>
    </div>
        
    <!-- Coinflip page -->
    <div class="page coinflip-page hidden" id="coinflipPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Coin Flip</h1>
        <div id="money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="money-count">0</span>
            </div>
        <div id="win-chance-display" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Win Chance: <span id="win-chance-percent">50</span>%
        </div>
        <div id="coin-container" style="width: 200px; height: 200px; margin: 20px auto; position: relative; perspective: 1000px;">
            <div id="coin" style="width: 200px; height: 200px; position: relative; transform-style: preserve-3d; transition: transform 0.6s;">
                <div id="coin-front" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(0deg);">H</div>
                <div id="coin-back" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(180deg);">T</div>
            </div>
        </div>
        <div id="coinflip-result" style="color: #c9d1d9; font-size: 24px; margin: 20px 0; min-height: 30px;"></div>
        <div style="margin: 30px 0;">
            <button id="heads-btn" onclick="guessCoin('heads')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Heads</button>
            <button id="tails-btn" onclick="guessCoin('tails')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Tails</button>
        </div>
        <div id="streak-display" style="color: #58a6ff; font-size: 20px; margin-top: 20px;">
            Streak: <span id="streak-count">0</span>
        </div>
    </div>
    
    <!-- Clicker page -->
    <div class="page clicker-page hidden" id="clickerPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Clicker Game</h1>
        <div id="clicker-money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="clicker-money-count">0</span>
        </div>
        <div id="clicker-per-click" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Money Per Click: $<span id="clicker-amount">1</span>
        </div>
        <div style="margin: 40px 0;">
            <button id="clicker-button" onclick="clickMoney()" style="padding: 30px 60px; font-size: 32px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.1s; user-select: none;">CLICK ME!</button>
        </div>
    </div>
    
    <!-- Achievements page -->
    <div class="page achievements-page hidden" id="achievementsPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 10px;">Achievements</h1>
        <div id="achievements-stats" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Found: <span id="found-count">0</span> / <span id="total-count">256</span>
                </div>
        <div id="achievements-grid" class="achievements-grid">
            <!-- Achievements will be generated here -->
            </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>

    <!-- Goose Rain page -->
    <div class="page gooserain-page hidden" id="gooserainPage">
        <canvas id="gooseCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Geese: <span id="goose-count">0</span>
                </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
    
    <!-- Stones page -->
    <div class="page stones-page hidden" id="stonesPage">
        <canvas id="stonesCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #4682B4 0%, #5F9EA0 60%, #D2B48C 60%, #CD853F 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Stones: <span id="stones-count">0</span>
        </div>
        <div style="position: fixed; top: 50px; left: 20px; color: white; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Press E to spawn stones
        </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
    </div>
    
    <!-- Limbo page (blocked) -->
    <div class="page limbo-page hidden" id="limboPage">
        <h1 style="color: #f85149; font-size: 48px; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);"> BLOCKED </h1>
        <p style="color: #c9d1d9; font-size: 24px; margin-bottom: 40px; text-align: center;">Your blocked from this website</p>
        <p style="color: #8b949e; font-size: 18px; margin-bottom: 30px;">Enter the password to be unblocked:</p>
        <input type="text" id="limboPasswordInput" placeholder="Password" style="padding: 15px 20px; font-size: 20px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; margin-bottom: 20px; text-align: center; min-width: 250px;">
        <button id="limboSubmitBtn" onclick="checkLimboPassword()" style="padding: 15px 40px; font-size: 20px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Submit</button>
        <p id="limboError" style="color: #f85149; font-size: 16px; margin-top: 20px; min-height: 24px;"></p>
    </div>
    
    <!-- Panic Menu page -->
    <div class="page panicmenu-page hidden" id="panicmenuPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Panic Menu</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">Set a hotkey and URL to quickly swap tabs</p>
        <div style="max-width: 500px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Hotkey:</label>
                <input type="text" id="panicHotkeyInput" placeholder="Press a key..." style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; text-align: center;" readonly>
                <p style="color: #8b949e; font-size: 14px; margin-top: 5px;">Click the input and press a key to set</p>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Website URL:</label>
                <input type="text" id="panicUrlInput" placeholder="https://example.com" style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9;">
            </div>
            <button onclick="savePanicSettings()" style="width: 100%; padding: 15px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 20px;">Save Settings</button>
            <div id="panicStatus" style="color: #58a6ff; font-size: 16px; text-align: center; min-height: 24px; margin-bottom: 20px;"></div>
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer;">Back</button>
        </div>
    </div>
    
    <!-- Changelog page -->
    <div class="page changelog-page hidden" id="changelogPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;"> Changelog</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">Track of all additions and updates to the website</p>
        <div style="max-width: 800px; margin: 0 auto; text-align: left;">
            <div id="changelog-content" style="background: #161b22; border: 2px solid #30363d; border-radius: 8px; padding: 20px; color: #c9d1d9;">
                <!-- Changelog entries will be displayed here -->
            </div>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Background Selection page -->
    <div class="page background-page hidden" id="backgroundPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Background Selection</h1>
        <div id="bg-theme-warning" style="display: none; padding: 15px; margin-bottom: 20px; background: #f85149; color: white; border-radius: 8px; font-size: 16px; max-width: 600px;">
            <strong> Background colors only work on Dark or Light theme.</strong> Switch to one of those themes to use custom backgrounds.
        </div>
        <div style="margin-bottom: 30px;">
            <button id="bg-solid-btn" onclick="setBgMode('solid')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer;">Solid Color</button>
            <button id="bg-gradient-btn" onclick="setBgMode('gradient')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 6px; cursor: pointer;">Gradient (2 Colors)</button>
        </div>
        <div id="bg-solid-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select Color</h2>
            <div id="bg-solid-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
        </div>
        <div id="bg-gradient-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select 2 Colors</h2>
            <div style="margin-bottom: 15px;">
                <p style="color: #8b949e; font-size: 16px;">Color 1: <span id="bg-gradient-color1-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
                <p style="color: #8b949e; font-size: 16px;">Color 2: <span id="bg-gradient-color2-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
            </div>
            <div id="bg-gradient-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
            <button id="bg-apply-gradient-btn" onclick="applyGradientBackground()" disabled style="padding: 12px 24px; font-size: 18px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 8px; cursor: not-allowed; margin-top: 20px;">Apply Gradient</button>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Remote Desktop page -->
    <div class="page remote-desktop-page hidden" id="remoteDesktopPage">
        <div id="remoteDesktop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #008080; font-family: 'MS Sans Serif', Arial, sans-serif; overflow: hidden;">
            <!-- Desktop icons container -->
            <div id="desktopIcons" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 40px); padding: 10px; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 20px;">
                <!-- Icons will be added here dynamically -->
            </div>
            
            <!-- Taskbar -->
            <div id="taskbar" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40px; background: #c0c0c0; border-top: 2px solid #ffffff; display: flex; align-items: center; padding: 0 4px; z-index: 1000; box-shadow: 0 -2px 4px rgba(0,0,0,0.3);">
                <div style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; margin: 2px; cursor: pointer; font-size: 11px; font-weight: bold; user-select: none;" onclick="showPage('mainPage')">
                    Start
                </div>
                <div id="taskbarApps" style="flex: 1; display: flex; gap: 2px; padding: 0 4px;">
                    <!-- Taskbar buttons will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Right-click context menu -->
        <div id="desktopContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
            <div class="context-menu-item" onclick="addDesktopApp('paper')" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">New Paper</div>
            <div class="context-menu-item" onclick="addDesktopApp('paint')" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">New Paint</div>
        </div>
        
        <!-- Icon right-click menu -->
        <div id="iconContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
            <div class="context-menu-item" onclick="renameDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">Rename</div>
            <div class="context-menu-item" onclick="deleteDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">Delete</div>
        </div>
        
        <!-- Trash can -->
        <div id="trashCan" class="desktop-icon" style="position: absolute; bottom: 50px; right: 10px; width: 80px; text-align: center; cursor: pointer; user-select: none;" draggable="false">
            <div style="width: 32px; height: 32px; margin: 0 auto 4px; background: url('data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 32 32%22><rect x=%228%22 y=%228%22 width=%2216%22 height=%2216%22 fill=%22%23000%22/><rect x=%2210%22 y=%2210%22 width=%2212%22 height=%222%22 fill=%22%23000%22/><rect x=%2212%22 y=%2212%22 width=%228%22 height=%222%22 fill=%22%23fff%22/></svg>') no-repeat center; background-size: contain;"></div>
            <div style="font-size: 11px; color: #fff; text-shadow: 1px 1px 1px #000;">Trash</div>
        </div>
    </div>
    
    <!-- Clock display (top left) -->
    <div class="clock-display hidden" id="clockDisplay"></div>
    
    <!-- Edit Profile Modal -->
    <div class="edit-modal" id="editModal">
        <div class="edit-modal-content">
            <h2> Edit Profile</h2>
            <div class="edit-form">
                <div class="edit-field">
                    <label>User ID:</label>
                    <input type="text" id="editUserId" placeholder="Your user ID" maxlength="20">
                    <small>3-20 characters (letters, numbers, _, -)</small>
                </div>
                <div class="edit-field">
                    <label>Bio:</label>
                    <textarea id="editBio" placeholder="Tell us about yourself..." maxlength="200"></textarea>
                    <small><span id="bioCharCount">0</span>/200 characters</small>
                </div>
                <div class="edit-field">
                    <label>Avatar Emoji:</label>
                    <div class="emoji-picker">
                        <div class="emoji-preview" id="emojiPreview"></div>
                        <div class="emoji-grid" id="emojiGrid">
                            <!-- Emojis will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="edit-buttons">
                    <button class="edit-save-btn" id="editSaveBtn">Save</button>
                    <button class="edit-cancel-btn" id="editCancelBtn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Terms and Agreements Modal -->
    <div class="terms-modal" id="termsModal">
        <div class="terms-modal-content">
            <h2> Terms and Agreements</h2>
            <div class="terms-text">
                <p><strong>Welcome to FinHub!</strong></p>
                <p>By using this website, you agree to the following terms:</p>
                <ul>
                    <li><strong>Be Respectful:</strong> No inappropriate content, harassment, or offensive language</li>
                    <li><strong>No Inappropriate Drawings:</strong> Keep drawings appropriate and respectful</li>
                    <li><strong>No Bad Words:</strong> Keep chat clean and friendly</li>
                    <li><strong>Respect Others:</strong> Be kind to other users</li>
                    <li><strong>No Spam:</strong> Don't spam messages or flood the chat</li>
                    <li><strong>Privacy:</strong> Don't share personal information</li>
                </ul>
                <p><strong>Violations may result in being banned from the service.</strong></p>
                <p>By clicking "I Agree", you acknowledge that you have read and agree to these terms.</p>
            </div>
            <div class="terms-buttons">
                <button class="terms-agree-btn" id="termsAgreeBtn">I Agree</button>
                <button class="terms-disagree-btn" id="termsDisagreeBtn">I Disagree</button>
            </div>
        </div>
    </div>
    
    <!-- Command feedback display -->
    <div class="command-feedback hidden" id="commandFeedback">
        <span class="command-text"></span><span class="feedback-text"></span>
    </div>
    
    <!-- Chat Page -->
    <div class="page hidden" id="chatPage">
        <div class="chat-container">
            <div class="chat-header">
                <h2> Online Chat</h2>
                <div class="online-users" id="onlineUsers">
                    <div class="online-users-title"> Online Users</div>
                    <div id="onlineUsersList"></div>
                </div>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." maxlength="500">
                <button class="chat-send-btn" id="chatSendBtn">Send</button>
            </div>
        </div>
    </div>
    
    <!-- Friends List Modal -->
    <div class="friends-modal" id="friendsModal">
        <div class="friends-modal-content">
            <h2> My Friends</h2>
            <div class="friends-list" id="friendsList">
                <!-- Friends will be populated here -->
            </div>
            <div class="friends-buttons">
                <button class="friends-close-btn" id="friendsCloseBtn">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Private Chat Page -->
    <div class="page hidden" id="privateChatPage">
        <div class="chat-container">
            <div class="chat-header">
                <h2 id="privateChatTitle"> Private Chat</h2>
                <button class="chat-back-btn" id="privateChatBackBtn"> Back to Friends</button>
            </div>
            <div class="chat-messages" id="privateChatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="privateChatInput" placeholder="Type a message..." maxlength="500">
                <button class="chat-send-btn" id="privateChatSendBtn">Send</button>
            </div>
        </div>
    </div>
    
    <!-- Visit Counter -->
    <div class="visit-counter" id="visitCounter">
        <div class="visit-counter-number" id="visitCounterNumber">0</div>
        <div class="visit-counter-label">Total Visits</div>
    </div>
    
    <!-- Command history toggle -->
    <div class="command-history-toggle" id="commandHistoryToggle" title="Click to toggle command history"> History</div>
    
    <!-- Command history display -->
    <div class="command-history" id="commandHistory">
        <div class="command-history-header">Command History (Last 10)</div>
        <div id="commandHistoryEntries"></div>
    </div>
    
    <!-- Command bar in bottom left -->
    <div class="command-bar">
        <input type="text" class="command-input" id="commandInput" placeholder="Type a color or 'home'..." autocomplete="off">
    </div>
    
        <!-- Commands menu - draggable -->
    <div class="commands-menu" id="commandsMenu">
        <div class="commands-menu-header" id="commandsMenuHeader">
            <h3>Commands</h3>
            <button class="commands-menu-close" id="commandsMenuClose"></button>
        </div>
        <div class="commands-list" id="commandsList">
            <!-- Commands will be dynamically generated based on unlocks -->
        </div>
    </div>

    <script>
        // Letters from "finley" to use
        const finleyLetters = ['f', 'i', 'n', 'l', 'e', 'y'];
        
        // Function to expand pattern: make 3x wider and 2x taller
        function expandPattern(pattern) {
            const expanded = [];
            // Make each row 3x wider
            pattern.forEach(row => {
                const wideRow = [];
                row.forEach(cell => {
                    // Repeat each cell 3 times
                    wideRow.push(cell, cell, cell);
                });
                expanded.push(wideRow);
            });
            // Make 2x taller by duplicating each row
            const tallExpanded = [];
            expanded.forEach(row => {
                tallExpanded.push(row); // Original row
                tallExpanded.push(row); // Duplicate row
            });
            return tallExpanded;
        }
        
        // Function to create letter patterns
        function createLetterPattern(letter, pattern, sourceLetters = finleyLetters) {
            const container = document.getElementById(`letter-${letter}`);
            if (!container) return;
            container.innerHTML = ''; // Clear existing
            const expandedPattern = expandPattern(pattern);
            expandedPattern.forEach(row => {
                row.forEach(cell => {
                    const span = document.createElement('span');
                    span.className = 'small-letter';
                    if (cell === 1) {
                        // Randomly pick a letter from source
                        const randomLetter = sourceLetters[Math.floor(Math.random() * sourceLetters.length)];
                        span.textContent = randomLetter;
                        span.classList.add(randomLetter);
                } else {
                        span.textContent = ' ';
                    }
                    container.appendChild(span);
                });
            });
        }
        
        // Letters for GooseHub (TYLER)
        const tylerLetters = ['t', 'y', 'l', 'e', 'r'];
        
        // Letter patterns for GOOSEHUB
        const gPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const oPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const sPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [0,1,1,1,1,1,0],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const ePattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,1,1]
        ];
        
        // Transform to FinHub mode (revert from GooseHub)
        function transformToFinHubMode() {
            isGooseMode = false;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with code, powered by Finley';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            }
            
            // Clear and recreate title with FINHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for F, I, N, H, U, B
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern, finleyLetters);
                createLetterPattern('i', iPattern, finleyLetters);
                createLetterPattern('n', nPattern, finleyLetters);
                createLetterPattern('h', hPattern, finleyLetters);
                createLetterPattern('u', uPattern, finleyLetters);
                createLetterPattern('b', bPattern, finleyLetters);
            }
            
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Transform to GooseHub mode
        function transformToGooseMode() {
            isGooseMode = true;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with feathers, powered by birds';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: T-Y-L-E-R';
            }
            
            // Clear and recreate title with GOOSEHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for G, O, O, S, E, H, U, B (need unique IDs for the two O's)
                const gooseLetters = ['g', 'o', 'o2', 's', 'e', 'h', 'u', 'b'];
                gooseLetters.forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter.replace('2', '')}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                // Wait a tiny bit for DOM to update, then create patterns
                setTimeout(() => {
                    createLetterPattern('g', gPattern, tylerLetters);
                    createLetterPattern('o', oPattern, tylerLetters);
                    createLetterPattern('o2', oPattern, tylerLetters);
                    createLetterPattern('s', sPattern, tylerLetters);
                    createLetterPattern('e', ePattern, tylerLetters);
                    createLetterPattern('h', hPattern, tylerLetters);
                    createLetterPattern('u', uPattern, tylerLetters);
                    createLetterPattern('b', bPattern, tylerLetters);
                }, 10);
            }
            
            // Unlock honk and gooserain commands
            unlockCommand('honk');
            unlockCommand('gooserain');
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Render commands menu dynamically - show all commands except goose ones until unlocked
        function renderCommandsMenu() {
            const commandsList = document.getElementById('commandsList');
            if (!commandsList) return;
            
            const gooseCommands = ['goose', 'honk', 'gooserain']; // Goose commands that need to be unlocked
            
            const commandDefinitions = {
                'Navigation': [
                    { name: 'home', desc: 'Go to home page' },
                    { name: 'back', desc: 'Return to main page' },
                    { name: 'sweeper', desc: 'Play Minesweeper' },
                    { name: 'pong', desc: 'Play Pong' },
                    { name: 'sandboxles', desc: 'Open Sandboxels' },
                    { name: 'paint', desc: 'Open Paint game' },
                    { name: 'drawing board', desc: 'Open collaborative drawing board' },
                    { name: 'remote desktop', desc: 'Open Windows 95 style desktop' },
                    { name: 'desktop', desc: 'Open Windows 95 style desktop' },
                    { name: 'snake', desc: 'Play Google Snake' },
                    { name: 'coinflip', desc: 'Flip a coin' },
                    { name: 'clicker', desc: 'Play clicker game' },
                    { name: 'finley', desc: 'Transform back to FinHub' },
                    { name: 'achievements', desc: 'View achievements' },
                    { name: 'changelog', desc: 'View changelog and updates' },
                    { name: 'background', desc: 'Change background' },
                    { name: 'bg', desc: 'Change background' },
                    { name: 'goose', desc: 'Transform to GooseHub' },
                    { name: 'gooserain', desc: 'Make it rain geese!', isGoose: true },
                    { name: 'stones', desc: 'Throw stones!' },
                    { name: 'wooper', desc: 'Wooper colors!' },
                    { name: 'wooperbird', desc: 'WooperBird command', isWooper: true },
                    { name: 'panicmenu', desc: 'Panic menu settings' },
                ],
                'Colors': [
                    { name: 'rainbow', desc: 'Rainbow colors' },
                    { name: 'black', desc: 'Black' },
                    { name: 'red', desc: 'Red' },
                    { name: 'blue', desc: 'Blue' },
                    { name: 'green', desc: 'Green' },
                    { name: 'yellow', desc: 'Yellow' },
                    { name: 'purple', desc: 'Purple' },
                    { name: 'orange', desc: 'Orange' },
                    { name: 'white', desc: 'White' },
                    { name: 'pink', desc: 'Pink' },
                    { name: 'cyan', desc: 'Cyan' },
                    { name: 'gold', desc: 'Gold' },
                    { name: 'silver', desc: 'Silver' },
                ],
                'Actions': [
                    { name: 'honk', desc: 'Play honk sound', isGoose: true },
                    { name: 'clock', desc: 'Toggle clock (true/false)' },
                    { name: 'whoami', desc: 'Display your user profile' },
                    { name: 'whoami [id]', desc: 'Display another user\'s profile by ID' },
                    { name: 'iam [bio]', desc: 'Set your bio/profile text' },
                ],
                'Themes': [
                    { name: 'theme 1995', desc: 'Windows 95 grey boxed look' },
                    { name: 'theme cyberpunk', desc: 'Neon pink/blue with glitch font' },
                    { name: 'theme terminal', desc: 'CRT green with scanlines' },
                    { name: 'theme coffee', desc: 'Warm brown/cream sepia mode' },
                    { name: 'theme dark', desc: 'Dark mode (default)' },
                    { name: 'theme light', desc: 'Light mode' },
                    { name: 'theme matrix', desc: 'Matrix style - press keys to create falling columns' },
                    { name: 'theme paper', desc: 'Paper notebook with grid lines' },
                    { name: 'theme space', desc: 'Space theme with interactive stars' },
                    { name: 'theme ocean', desc: 'Ocean theme with wave animation' },
                    { name: 'theme clouds', desc: 'Clouds theme with animated clouds' },
                    { name: 'theme flashcard', desc: 'Flashcard theme with writable flashcards' },
                    { name: 'stars', desc: 'Spawn more stars (space theme only)' },
                    { name: 'flashcard', desc: 'Create a new flashcard (flashcard theme only)' },
                    { name: 'fc', desc: 'Create a new flashcard (flashcard theme only)' },
                ],
                'Menu': [
                    { name: 'cmds', desc: 'Show/hide this menu' },
                    { name: 'clock', desc: 'Toggle clock (true/false)' },
                    { name: 'whoami', desc: 'Display your user profile' },
                    { name: 'whoami [id]', desc: 'Display another user\'s profile by ID' },
                    { name: 'iam [bio]', desc: 'Set your bio/profile text' },
                ]
            };
            
            let html = '';
            Object.keys(commandDefinitions).forEach(category => {
                const commands = commandDefinitions[category];
                const visibleCommands = commands.filter(cmd => {
                    // Hide goose commands if not unlocked
                    if (cmd.isGoose && !unlockedCommands.has(cmd.name)) {
                        return false;
                    }
                    // Hide wooper commands if not unlocked
                    if (cmd.isWooper && !unlockedCommands.has(cmd.name)) {
                        return false;
                    }
                    return true;
                });
                
                if (visibleCommands.length > 0) {
                    html += `<div class="command-category"><h4>${category}</h4>`;
                    visibleCommands.forEach(cmd => {
                        html += `<div class="command-item"><span class="command-name">${cmd.name}</span><span class="command-desc">- ${cmd.desc}</span></div>`;
                    });
                    html += `</div>`;
                }
            });
            
            commandsList.innerHTML = html;
        }
        
        // Unlock a command
        function unlockCommand(commandName) {
            unlockedCommands.add(commandName);
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Play honk sound
        function playHonkSound() {
            try {
                // Generate honk sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(180, audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Could not play honk sound:', e);
            }
        }
        
        // Big F pattern (original - will be expanded to 3x wide, 2x tall)
        const fPattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0]
        ];
        
        // Big i pattern
        const iPattern = [
            [1,1,1],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [1,1,1]
        ];
        
        // Big n pattern
        const nPattern = [
            [1,0,0,0,0,0,1],
            [1,1,0,0,0,0,1],
            [1,0,1,0,0,0,1],
            [1,0,0,1,0,0,1],
            [1,0,0,0,1,0,1],
            [1,0,0,0,0,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big H pattern
        const hPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big u pattern
        const uPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        // Big b pattern
        const bPattern = [
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,1,0],
            [1,1,1,1,1,0,0]
        ];
        
        // Create all letters
        createLetterPattern('f', fPattern);
        createLetterPattern('i', iPattern);
        createLetterPattern('n', nPattern);
        createLetterPattern('h', hPattern);
        createLetterPattern('u', uPattern);
        createLetterPattern('b', bPattern);
        
        // Global money system - shared across all tabs
        let globalMoney = 0;
        let unlockedColors = new Set(); // Colors are unlocked by default (not used anymore but keeping for compatibility)
        let clickerPerClick = 1; // Clicker base money per click
        let unlockedCommands = new Set(); // Only goose commands need to be unlocked
        let isGooseMode = false; // Track if in goose mode
        let resetConfirm = false; // Track if reset command was just used (needs confirmation)
        let resetUsed = false; // Track if reset has been used (can only use once)
        
        // Load global data
        function loadGlobalData() {
            const saved = localStorage.getItem('globalData');
            if (saved) {
                const data = JSON.parse(saved);
                globalMoney = data.money || 0;
                unlockedColors = new Set(data.unlockedColors || []);
                clickerPerClick = data.clickerPerClick || 1;
                unlockedCommands = new Set(data.unlockedCommands || []); // Only goose commands stored
                isGooseMode = data.isGooseMode || false;
            }
            // Check if reset was used in this session
            if (sessionStorage.getItem('resetUsed') === 'true') {
                resetUsed = true;
            }
            updateAllMoneyDisplays();
            renderCommandsMenu();
            if (isGooseMode) {
                transformToGooseMode();
            }
        }
        
        // Save global data
        function saveGlobalData() {
            localStorage.setItem('globalData', JSON.stringify({
                money: globalMoney,
                unlockedColors: Array.from(unlockedColors),
                clickerPerClick: clickerPerClick,
                unlockedCommands: Array.from(unlockedCommands),
                isGooseMode: isGooseMode
            }));
        }
        
        // Reset everything - clears all progress
        function resetEverything() {
            // Mark reset as used - can only use once
            resetUsed = true;
            sessionStorage.setItem('resetUsed', 'true');
            
            // Clear all localStorage
            localStorage.removeItem('globalData');
            localStorage.removeItem('coinflipData');
            localStorage.removeItem('achievements');
            
            // Reset all variables
            globalMoney = 0;
            unlockedColors = new Set();
            clickerPerClick = 1;
            unlockedCommands = new Set(); // Reset goose command unlocks
            isGooseMode = false;
            resetConfirm = false;
            
            // Reset coinflip data
            coinflipStreak = 0;
            winChanceUpgrades = 0;
            
            // Reset achievements
            foundAchievements = new Set();
            colorChangeCount = 0;
            commandsUsed = new Set();
            coinflipWins = 0;
            
            // Recreate FinHub letters (reset from GooseHub if needed)
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern);
                createLetterPattern('i', iPattern);
                createLetterPattern('n', nPattern);
                createLetterPattern('h', hPattern);
                createLetterPattern('u', uPattern);
                createLetterPattern('b', bPattern);
            }
            
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            if (subtitle) subtitle.textContent = 'Built with code, powered by Finley';
            if (lettersSource) lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            
            // Update displays
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
            const clickerAmount = document.getElementById('clicker-amount');
            if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            
            // Re-render menu and achievements
            renderCommandsMenu();
            renderAchievements();
            
            // Clear color changes
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                letter.style.color = '';
            });
            
            // Go back to main page
            showPage('mainPage');
            
            // Show success message
            commandInput.placeholder = ' Everything has been reset!';
            setTimeout(() => {
                commandInput.placeholder = 'Type a color or "home"...';
            }, 3000);
        }
        
        // Update all money displays across all pages
        function updateAllMoneyDisplays() {
            const displays = ['money-count', 'clicker-money-count'];
            displays.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = globalMoney;
            });
        }
        
        // Add money (global)
        function addMoney(amount) {
            globalMoney += amount;
            updateAllMoneyDisplays();
            saveGlobalData();
        }
        
        // Spend money (global)
        function spendMoney(amount) {
            if (globalMoney >= amount) {
                globalMoney -= amount;
                updateAllMoneyDisplays();
                saveGlobalData();
                return true;
            }
            return false;
        }
        
        // Color command system with multiple shades
        const colorPalettes = {
            'black': ['#000000', '#1a1a1a', '#333333', '#4d4d4d', '#666666', '#000000', '#0d0d0d', '#262626'],
            'red': ['#ff0000', '#cc0000', '#ff3333', '#990000', '#ff6666', '#ff1a1a', '#b30000', '#ff4d4d'],
            'blue': ['#0000ff', '#0000cc', '#3333ff', '#000099', '#6666ff', '#1a1aff', '#0000b3', '#4d4dff'],
            'green': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'yellow': ['#ffff00', '#cccc00', '#ffff33', '#999900', '#ffff66', '#ffff1a', '#b3b300', '#ffff4d'],
            'purple': ['#800080', '#660066', '#993399', '#4d004d', '#b366b3', '#8c1a8c', '#5c005c', '#cc66cc'],
            'orange': ['#ffa500', '#cc8400', '#ffb833', '#996300', '#ffcc66', '#ffad1a', '#b37500', '#ffd24d'],
            'white': ['#ffffff', '#e6e6e6', '#cccccc', '#f5f5f5', '#ffffff', '#fafafa', '#d9d9d9', '#ffffff'],
            'pink': ['#ff69b4', '#cc5490', '#ff7fc4', '#993f6c', '#ff99d4', '#ff73ba', '#b34a85', '#ff8fce'],
            'cyan': ['#00ffff', '#00cccc', '#33ffff', '#009999', '#66ffff', '#1affff', '#00b3b3', '#4dffff'],
            'lime': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'magenta': ['#ff00ff', '#cc00cc', '#ff33ff', '#990099', '#ff66ff', '#ff1aff', '#b300b3', '#ff4dff'],
            'brown': ['#a52a2a', '#842121', '#b84d4d', '#661919', '#cc7070', '#ad3333', '#8b1f1f', '#c55c5c'],
            'gray': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'grey': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'gold': ['#ffd700', '#ccac00', '#ffdd33', '#998000', '#ffe666', '#ffdb1a', '#b39900', '#ffe84d'],
            'silver': ['#c0c0c0', '#999999', '#d4d4d4', '#737373', '#e6e6e6', '#b8b8b8', '#8c8c8c', '#d9d9d9']
        };
        
        // Color costs in shop
        const colorCosts = {
            'black': 10,
            'red': 20,
            'blue': 20,
            'green': 20,
            'yellow': 25,
            'purple': 30,
            'orange': 30,
            'white': 15,
            'pink': 35,
            'cyan': 25,
            'lime': 20,
            'magenta': 35,
            'brown': 25,
            'gray': 15,
            'grey': 15,
            'gold': 50,
            'silver': 40,
            'rainbow': 100
        };
        
        // Function to change all letter colors with different shades (all colors unlocked)
        function changeAllColors(colorName) {
            const palette = colorPalettes[colorName];
            if (!palette) {
                // Special case for rainbow
                if (colorName === 'rainbow') {
                    applyRainbowColors();
                }
                return;
            }
            
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    // Randomly pick a shade from the palette
                    const randomShade = palette[Math.floor(Math.random() * palette.length)];
                    letter.style.color = randomShade;
                }
            });
        }

        // Function to apply rainbow colors
        function applyRainbowColors() {
            const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = rainbowColors[colorIndex % rainbowColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Function to apply wooper colors (blue and pink)
        function applyWooperColors() {
            const wooperColors = ['#0000ff', '#ff69b4']; // Blue and pink
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = wooperColors[colorIndex % wooperColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Navigation system
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            document.getElementById(pageId).classList.remove('hidden');
            
            // Show/hide command bar based on page
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) {
                if (pageId === 'remoteDesktopPage') {
                    commandBar.style.display = 'none';
                } else {
                    commandBar.style.display = 'flex';
                }
            }
        }
        
        // Commands menu functionality
        const commandsMenu = document.getElementById('commandsMenu');
        const commandsMenuHeader = document.getElementById('commandsMenuHeader');
        const commandsMenuClose = document.getElementById('commandsMenuClose');
        
        function toggleCommandsMenu() {
            commandsMenu.classList.toggle('open');
        }
        
        // Close menu button
        commandsMenuClose.addEventListener('click', () => {
            commandsMenu.classList.remove('open');
        });
        
        // Make menu draggable
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        commandsMenuHeader.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.target === commandsMenuClose || !commandsMenu.classList.contains('open')) return;
            const rect = commandsMenu.getBoundingClientRect();
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;
            isDragging = true;
            commandsMenu.classList.add('dragging');
            commandsMenu.style.transition = 'none';
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                // Keep menu within viewport
                const maxX = window.innerWidth - commandsMenu.offsetWidth;
                const maxY = window.innerHeight - commandsMenu.offsetHeight;
                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));
                
                commandsMenu.style.right = 'auto';
                commandsMenu.style.left = `${currentX}px`;
                commandsMenu.style.top = `${currentY}px`;
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                isDragging = false;
                commandsMenu.classList.remove('dragging');
                commandsMenu.style.transition = 'right 0.3s ease';
            }
        }
        
        // Clock system
        let clockEnabled = false;
        let clockInterval = null;
        const clockDisplay = document.getElementById('clockDisplay');
        
        function loadClockSetting() {
            const saved = localStorage.getItem('clockEnabled');
            clockEnabled = saved === 'true';
            if (clockEnabled) {
                showClock();
            } else {
                hideClock();
            }
        }
        
        function saveClockSetting() {
            localStorage.setItem('clockEnabled', clockEnabled.toString());
        }
        
        function updateClock() {
            if (!clockDisplay) return;
            const now = new Date();
            // Florida timezone (America/New_York - EST/EDT)
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false, // Military time
                timeZone: 'America/New_York'
            };
            const timeString = new Intl.DateTimeFormat('en-US', options).format(now);
            clockDisplay.textContent = timeString;
        }
        
        function showClock() {
            if (!clockDisplay) return;
            clockEnabled = true;
            clockDisplay.classList.remove('hidden');
            updateClock();
            if (clockInterval) clearInterval(clockInterval);
            clockInterval = setInterval(updateClock, 1000);
            saveClockSetting();
        }
        
        function hideClock() {
            if (!clockDisplay) return;
            clockEnabled = false;
            clockDisplay.classList.add('hidden');
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
            saveClockSetting();
        }
        
        // Command history storage (last 10 commands)
        let commandHistory = [];
        const MAX_HISTORY = 10;
        
        // Command feedback helper with history
        function showCommandFeedback(command, feedback, isSuccess = true) {
            const feedbackEl = document.getElementById('commandFeedback');
            const commandTextEl = feedbackEl?.querySelector('.command-text');
            const feedbackTextEl = feedbackEl?.querySelector('.feedback-text');
            
            // Remove previous success/error classes
            feedbackEl.classList.remove('success', 'error');
            
            if (feedbackEl && commandTextEl && feedbackTextEl) {
                commandTextEl.textContent = `> ${command}`;
                feedbackTextEl.textContent = feedback ? ` ${feedback}` : '';
                
                // Add success/error styling
                if (isSuccess) {
                    feedbackEl.classList.add('success');
                } else {
                    feedbackEl.classList.add('error');
                }
                
                feedbackEl.classList.remove('hidden');
                
                // Store in history
                addToHistory(command, feedback, isSuccess);
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    feedbackEl.classList.add('hidden');
                }, 3000);
            }
        }
        
        // Add command to history
        function addToHistory(command, feedback, isSuccess) {
            // Add to beginning of array
            commandHistory.unshift({
                command: command,
                feedback: feedback || (isSuccess ? 'Success' : 'Error'),
                success: isSuccess,
                timestamp: new Date().toLocaleTimeString()
            });
            
            // Keep only last 10
            if (commandHistory.length > MAX_HISTORY) {
                commandHistory.pop();
            }
            
            // Save to localStorage
            saveCommandHistory();
            
            // Update history display
            renderCommandHistory();
        }
        
        // Render command history
        function renderCommandHistory() {
            const historyEntries = document.getElementById('commandHistoryEntries');
            if (!historyEntries) return;
            
            if (commandHistory.length === 0) {
                historyEntries.innerHTML = '<div style="color: #6e7681; font-style: italic;">No commands yet...</div>';
                return;
            }
            
            let html = '';
            commandHistory.forEach(entry => {
                const statusClass = entry.success ? 'success' : 'error';
                html += `
                    <div class="command-history-entry ${statusClass}">
                        <span class="command-text">> ${entry.command}</span>
                        <span class="feedback-text">${entry.feedback}</span>
                        <span style="color: #6e7681; margin-left: 8px; font-size: 10px;">(${entry.timestamp})</span>
                    </div>
                `;
            });
            
            historyEntries.innerHTML = html;
        }
        
        // Toggle command history visibility
        function toggleCommandHistory() {
            const historyEl = document.getElementById('commandHistory');
            if (historyEl) {
                historyEl.classList.toggle('visible');
            }
        }
        
        // Terms and Agreements
        function checkTermsAgreement() {
            // Only show on finleychang.com, not localhost
            const hostname = window.location.hostname;
            if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.')) {
                return; // Don't show on localhost
            }
            
            const termsAccepted = localStorage.getItem('termsAccepted');
            const termsVersion = localStorage.getItem('termsVersion') || '1.0';
            const currentTermsVersion = '1.0'; // Update this when you change terms
            
            if (!termsAccepted || termsVersion !== currentTermsVersion) {
                showTermsModal();
            }
        }
        
        function showTermsModal() {
            const modal = document.getElementById('termsModal');
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideTermsModal() {
            const modal = document.getElementById('termsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function acceptTerms() {
            localStorage.setItem('termsAccepted', 'true');
            localStorage.setItem('termsVersion', '1.0');
            hideTermsModal();
        }
        
        function rejectTerms() {
            alert('You must accept the terms to use this website.');
        }
        
        // Edit Profile Menu
        const popularEmojis = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
        
        function openEditMenu() {
            const modal = document.getElementById('editModal');
            const userIdInput = document.getElementById('editUserId');
            const bioInput = document.getElementById('editBio');
            const emojiPreview = document.getElementById('emojiPreview');
            const emojiGrid = document.getElementById('emojiGrid');
            
            if (!modal) return;
            
            const currentUserId = getUserId();
            const currentBio = getUserBio(currentUserId) || '';
            const currentAvatar = getUserAvatar(currentUserId);
            
            // Populate fields
            userIdInput.value = currentUserId;
            bioInput.value = currentBio;
            emojiPreview.textContent = currentAvatar;
            updateBioCharCount();
            
            // Populate emoji grid
            emojiGrid.innerHTML = '';
            popularEmojis.forEach(emoji => {
                const emojiBtn = document.createElement('div');
                emojiBtn.className = 'emoji-option';
                if (emoji === currentAvatar) {
                    emojiBtn.classList.add('selected');
                }
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = () => {
                    // Remove previous selection
                    emojiGrid.querySelectorAll('.emoji-option').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    // Select this one
                    emojiBtn.classList.add('selected');
                    emojiPreview.textContent = emoji;
                };
                emojiGrid.appendChild(emojiBtn);
            });
            
            // Show modal
            modal.classList.add('show');
        }
        
        function closeEditMenu() {
            const modal = document.getElementById('editModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function saveEditProfile() {
            const userIdInput = document.getElementById('editUserId');
            const bioInput = document.getElementById('editBio');
            const emojiPreview = document.getElementById('emojiPreview');
            
            if (!userIdInput || !bioInput || !emojiPreview) return;
            
            const newUserId = userIdInput.value.trim();
            const newBio = bioInput.value.trim();
            const newAvatar = emojiPreview.textContent;
            
            // Validate user ID
            if (newUserId.length < 3 || newUserId.length > 20) {
                showCommandFeedback('edit', 'User ID must be 3-20 characters', false);
                return;
            }
            
            const validIdPattern = /^[a-zA-Z0-9_-]+$/;
            if (!validIdPattern.test(newUserId)) {
                showCommandFeedback('edit', 'User ID can only contain letters, numbers, _, and -', false);
                return;
            }
            
            const oldUserId = getUserId();
            
            // Change user ID if different
            if (newUserId !== oldUserId) {
                const result = setUserId(newUserId);
                if (result === false) {
                    showCommandFeedback('edit', 'User ID already taken. Choose a different one.', false);
                    return;
                } else if (result === true) {
                    finishSaving(newUserId, newBio, newAvatar);
                } else {
                    // Promise result
                    result.then((success) => {
                        if (success) {
                            finishSaving(newUserId, newBio, newAvatar);
                        } else {
                            showCommandFeedback('edit', 'User ID already taken. Choose a different one.', false);
                        }
                    });
                    return;
                }
            } else {
                finishSaving(newUserId, newBio, newAvatar);
            }
        }
        
        function finishSaving(userId, bio, avatar) {
            // Save bio
            setUserBio(userId, bio);
            
            // Save avatar
            setUserAvatar(userId, avatar);
            
            // Sync to Firebase if available
            if (database) {
                try {
                    database.ref(`users/${userId}`).update({
                        bio: bio,
                        avatar: avatar,
                        lastSeen: Date.now()
                    });
                } catch (e) {
                    console.warn('Could not sync profile to Firebase:', e);
                }
            }
            
            showCommandFeedback('edit', 'Profile saved successfully!', true);
            closeEditMenu();
        }
        
        function updateBioCharCount() {
            const bioInput = document.getElementById('editBio');
            const charCount = document.getElementById('bioCharCount');
            if (bioInput && charCount) {
                charCount.textContent = bioInput.value.length;
            }
        }
        
        // Initialize command history toggle
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('commandHistoryToggle');
            if (toggle) {
                toggle.addEventListener('click', toggleCommandHistory);
            }
            
            // Load history from localStorage
            loadCommandHistory();
            
            // Check terms agreement
            checkTermsAgreement();
            
            // Terms modal buttons
            const agreeBtn = document.getElementById('termsAgreeBtn');
            const disagreeBtn = document.getElementById('termsDisagreeBtn');
            if (agreeBtn) {
                agreeBtn.addEventListener('click', acceptTerms);
            }
            if (disagreeBtn) {
                disagreeBtn.addEventListener('click', rejectTerms);
            }
            
            // Edit modal buttons
            const editSaveBtn = document.getElementById('editSaveBtn');
            const editCancelBtn = document.getElementById('editCancelBtn');
            const editBio = document.getElementById('editBio');
            
            if (editSaveBtn) {
                editSaveBtn.addEventListener('click', saveEditProfile);
            }
            if (editCancelBtn) {
                editCancelBtn.addEventListener('click', closeEditMenu);
            }
            if (editBio) {
                editBio.addEventListener('input', updateBioCharCount);
            }
            
            // Close edit modal when clicking outside
            const editModal = document.getElementById('editModal');
            if (editModal) {
                editModal.addEventListener('click', (e) => {
                    if (e.target === editModal) {
                        closeEditMenu();
                    }
                });
            }
            
            // Friends modal
            const friendsCloseBtn = document.getElementById('friendsCloseBtn');
            if (friendsCloseBtn) {
                friendsCloseBtn.addEventListener('click', closeFriendsList);
            }
            
            const friendsModal = document.getElementById('friendsModal');
            if (friendsModal) {
                friendsModal.addEventListener('click', (e) => {
                    if (e.target === friendsModal) {
                        closeFriendsList();
                    }
                });
            }
            
            // Private chat
            const privateChatBackBtn = document.getElementById('privateChatBackBtn');
            if (privateChatBackBtn) {
                privateChatBackBtn.addEventListener('click', () => {
                    showPage('mainPage');
                    openFriendsList();
                });
            }
            
            const privateChatSendBtn = document.getElementById('privateChatSendBtn');
            const privateChatInput = document.getElementById('privateChatInput');
            
            if (privateChatSendBtn && privateChatInput) {
                privateChatSendBtn.onclick = () => {
                    if (currentPrivateChatWith) {
                        const text = privateChatInput.value;
                        if (text.trim()) {
                            sendPrivateMessage(text, currentPrivateChatWith);
                            privateChatInput.value = '';
                        }
                    }
                };
                
                privateChatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && currentPrivateChatWith) {
                        const text = privateChatInput.value;
                        if (text.trim()) {
                            sendPrivateMessage(text, currentPrivateChatWith);
                            privateChatInput.value = '';
                        }
                    }
                });
            }
            
            // Update visit counter
            updateVisitCounter();
        });
        
        // Load command history from localStorage
        function loadCommandHistory() {
            const saved = localStorage.getItem('commandHistory');
            if (saved) {
                try {
                    commandHistory = JSON.parse(saved);
                    // Ensure we only keep last 10
                    if (commandHistory.length > MAX_HISTORY) {
                        commandHistory = commandHistory.slice(0, MAX_HISTORY);
                    }
                    renderCommandHistory();
                } catch (e) {
                    console.error('Error loading command history:', e);
                    commandHistory = [];
                }
            }
        }
        
        // Save command history to localStorage
        function saveCommandHistory() {
            localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
        }
        
        // Firebase Configuration
        // Your Firebase config for online chat and profile sharing
        const firebaseConfig = {
            apiKey: "AIzaSyB_jv2W9Hvt0QFJlVN4ZcdrT1mtwP-fWFE",
            authDomain: "finhub-41eaf.firebaseapp.com",
            databaseURL: "https://finhub-41eaf-default-rtdb.firebaseio.com",
            projectId: "finhub-41eaf",
            storageBucket: "finhub-41eaf.firebasestorage.app",
            messagingSenderId: "96393027883",
            appId: "1:96393027883:web:4db59a7a6d020c7eba256e",
            measurementId: "G-GDEJMDDEG6"
        };
        
        // Initialize Firebase (only if config is provided)
        let firebaseApp, database;
        if (firebaseConfig && typeof firebase !== 'undefined') {
            try {
                if (!firebase.apps || firebase.apps.length === 0) {
                    firebaseApp = firebase.initializeApp(firebaseConfig);
                    database = firebase.database();
                    console.log(' Firebase connected - Online features enabled!');
                } else {
                    firebaseApp = firebase.app();
                    database = firebase.database();
                }
            } catch (e) {
                console.warn(' Firebase initialization failed, using localStorage fallback:', e);
                database = null;
            }
        } else {
            database = null;
            console.log(' Running in offline mode (localStorage). To enable online chat, configure Firebase.');
        }
        
        // User Profile System
        function getUserId() {
            let userId = localStorage.getItem('userId');
            if (!userId) {
                // Generate a unique ID (8 character alphanumeric)
                userId = 'user_' + Math.random().toString(36).substr(2, 8);
                localStorage.setItem('userId', userId);
            }
            return userId;
        }
        
        function setUserId(newUserId) {
            if (!newUserId || newUserId.trim() === '') {
                return false;
            }
            
            // Validate user ID format (alphanumeric, underscore, dash, 3-20 chars)
            const validIdPattern = /^[a-zA-Z0-9_-]{3,20}$/;
            if (!validIdPattern.test(newUserId.trim())) {
                return false;
            }
            
            const oldUserId = getUserId();
            const newUserIdTrimmed = newUserId.trim();
            
            // Don't allow changing to someone else's ID if they exist in Firebase
            if (database) {
                return new Promise((resolve) => {
                    database.ref(`users/${newUserIdTrimmed}`).once('value', (snapshot) => {
                        if (snapshot.exists() && newUserIdTrimmed !== oldUserId) {
                            resolve(false); // ID already taken
                        } else {
                            // Update localStorage
                            localStorage.setItem('userId', newUserIdTrimmed);
                            
                            // Migrate bio if exists
                            const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
                            if (bios[oldUserId]) {
                                bios[newUserIdTrimmed] = bios[oldUserId];
                                delete bios[oldUserId];
                                localStorage.setItem('userBios', JSON.stringify(bios));
                            }
                            
                            // Update Firebase if connected
                            const userRef = database.ref(`users/${oldUserId}`);
                            userRef.once('value', (oldSnapshot) => {
                                const oldData = oldSnapshot.val();
                                if (oldData) {
                                    // Move data to new ID
                                    database.ref(`users/${newUserIdTrimmed}`).set({
                                        ...oldData,
                                        id: newUserIdTrimmed
                                    });
                                    // Remove old ID
                                    userRef.remove();
                                }
                            });
                            
                            resolve(true);
                        }
                    });
                });
            } else {
                // Just update localStorage if no Firebase
                localStorage.setItem('userId', newUserIdTrimmed);
                
                // Migrate bio
                const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
                if (bios[oldUserId]) {
                    bios[newUserIdTrimmed] = bios[oldUserId];
                    delete bios[oldUserId];
                    localStorage.setItem('userBios', JSON.stringify(bios));
                }
                
                return true;
            }
        }
        
        function getUserBio(userId) {
            const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
            return bios[userId] || null;
        }
        
        function setUserBio(userId, bio) {
            const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
            bios[userId] = bio;
            localStorage.setItem('userBios', JSON.stringify(bios));
        }
        
        function getUserAvatar(userId) {
            const avatars = JSON.parse(localStorage.getItem('userAvatars') || '{}');
            return avatars[userId] || '';
        }
        
        function setUserAvatar(userId, emoji) {
            const avatars = JSON.parse(localStorage.getItem('userAvatars') || '{}');
            avatars[userId] = emoji;
            localStorage.setItem('userAvatars', JSON.stringify(avatars));
        }
        
        // Friends System
        function getFriends() {
            const friends = JSON.parse(localStorage.getItem('friends') || '[]');
            return friends;
        }
        
        function addFriend(friendId) {
            const friends = getFriends();
            if (!friends.includes(friendId)) {
                friends.push(friendId);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function removeFriend(friendId) {
            const friends = getFriends();
            const index = friends.indexOf(friendId);
            if (index > -1) {
                friends.splice(index, 1);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function isFriend(userId) {
            const friends = getFriends();
            return friends.includes(userId);
        }
        
        function openFriendsList() {
            const modal = document.getElementById('friendsModal');
            const friendsList = document.getElementById('friendsList');
            
            if (!modal || !friendsList) return;
            
            const friends = getFriends();
            
            if (friends.length === 0) {
                friendsList.innerHTML = '<div style="color: #8b949e; text-align: center; padding: 40px;">No friends yet. Use "friend [id]" to add someone!</div>';
            } else {
                friendsList.innerHTML = '';
                friends.forEach(friendId => {
                    const friendItem = document.createElement('div');
                    friendItem.className = 'friend-item';
                    
                    const avatar = getUserAvatar(friendId);
                    const bio = getUserBio(friendId) || 'No bio';
                    
                    friendItem.innerHTML = `
                        <div class="friend-avatar">${avatar}</div>
                        <div class="friend-info">
                            <div class="friend-name">${friendId}</div>
                            <div class="friend-bio">${bio.substring(0, 50)}${bio.length > 50 ? '...' : ''}</div>
                        </div>
                    `;
                    
                    friendItem.onclick = () => {
                        openPrivateChat(friendId);
                        closeFriendsList();
                    };
                    
                    friendsList.appendChild(friendItem);
                });
            }
            
            modal.classList.add('show');
        }
        
        function closeFriendsList() {
            const modal = document.getElementById('friendsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function openPrivateChat(friendId) {
            currentPrivateChatWith = friendId;
            const title = document.getElementById('privateChatTitle');
            const avatar = getUserAvatar(friendId);
            if (title) {
                title.textContent = ` Private Chat with ${avatar} ${friendId}`;
            }
            showPage('privateChatPage');
            loadPrivateChatMessages(friendId);
        }
        
        function loadPrivateChatMessages(friendId) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            
            if (database) {
                const messagesRef = database.ref(`privateChats/${chatId}/messages`).limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addPrivateMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messagesContainer.innerHTML = '';
                messages.forEach(msg => {
                    addPrivateMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addPrivateMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const avatar = getUserAvatar(message.userId);
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user">${avatar} ${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendPrivateMessage(text, friendId) {
            if (!text || !text.trim()) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            const message = {
                userId: currentUserId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                database.ref(`privateChats/${chatId}/messages`).push(message);
            } else {
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messages.push(message);
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem(`privateChat_${chatId}`, JSON.stringify(messages));
                addPrivateMessageToUI(message, true);
            }
        }
        
        // Visit Counter
        function updateVisitCounter() {
            const counter = document.getElementById('visitCounterNumber');
            if (!counter) return;
            
            if (database) {
                const visitsRef = database.ref('siteStats/visits');
                visitsRef.transaction((current) => {
                    return (current || 0) + 1;
                }, (error, committed, snapshot) => {
                    if (!error && committed && snapshot) {
                        counter.textContent = snapshot.val().toLocaleString();
                    }
                });
                
                // Listen for updates
                visitsRef.on('value', (snapshot) => {
                    const visits = snapshot.val() || 0;
                    counter.textContent = visits.toLocaleString();
                });
            } else {
                // Fallback to localStorage
                let visits = parseInt(localStorage.getItem('siteVisits') || '0');
                visits++;
                localStorage.setItem('siteVisits', visits.toString());
                counter.textContent = visits.toLocaleString();
            }
        }
        
        function getAllUserBios() {
            return JSON.parse(localStorage.getItem('userBios') || '{}');
        }
        
        // Friends System
        let currentPrivateChatWith = null;
        function getFriends() {
            const friends = JSON.parse(localStorage.getItem('friends') || '[]');
            return friends;
        }
        
        function addFriend(friendId) {
            const friends = getFriends();
            if (!friends.includes(friendId)) {
                friends.push(friendId);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function removeFriend(friendId) {
            const friends = getFriends();
            const index = friends.indexOf(friendId);
            if (index > -1) {
                friends.splice(index, 1);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function isFriend(userId) {
            const friends = getFriends();
            return friends.includes(userId);
        }
        
        function openFriendsList() {
            const modal = document.getElementById('friendsModal');
            const friendsList = document.getElementById('friendsList');
            
            if (!modal || !friendsList) return;
            
            const friends = getFriends();
            
            if (friends.length === 0) {
                friendsList.innerHTML = '<div style="color: #8b949e; text-align: center; padding: 40px;">No friends yet. Use "friend [id]" to add someone!</div>';
            } else {
                friendsList.innerHTML = '';
                friends.forEach(friendId => {
                    const friendItem = document.createElement('div');
                    friendItem.className = 'friend-item';
                    
                    const avatar = getUserAvatar(friendId);
                    const bio = getUserBio(friendId) || 'No bio';
                    
                    friendItem.innerHTML = `
                        <div class="friend-avatar">${avatar}</div>
                        <div class="friend-info">
                            <div class="friend-name">${friendId}</div>
                            <div class="friend-bio">${bio.substring(0, 50)}${bio.length > 50 ? '...' : ''}</div>
                        </div>
                    `;
                    
                    friendItem.onclick = () => {
                        openPrivateChat(friendId);
                        closeFriendsList();
                    };
                    
                    friendsList.appendChild(friendItem);
                });
            }
            
            modal.classList.add('show');
        }
        
        function closeFriendsList() {
            const modal = document.getElementById('friendsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function openPrivateChat(friendId) {
            currentPrivateChatWith = friendId;
            const title = document.getElementById('privateChatTitle');
            const avatar = getUserAvatar(friendId);
            if (title) {
                title.textContent = ` Private Chat with ${avatar} ${friendId}`;
            }
            showPage('privateChatPage');
            loadPrivateChatMessages(friendId);
        }
        
        function loadPrivateChatMessages(friendId) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            
            if (database) {
                const messagesRef = database.ref(`privateChats/${chatId}/messages`).limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addPrivateMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messagesContainer.innerHTML = '';
                messages.forEach(msg => {
                    addPrivateMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addPrivateMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const avatar = getUserAvatar(message.userId);
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user">${avatar} ${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendPrivateMessage(text, friendId) {
            if (!text || !text.trim()) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            const message = {
                userId: currentUserId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                database.ref(`privateChats/${chatId}/messages`).push(message);
            } else {
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messages.push(message);
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem(`privateChat_${chatId}`, JSON.stringify(messages));
                addPrivateMessageToUI(message, true);
            }
        }
        
        // Visit Counter
        function updateVisitCounter() {
            const counter = document.getElementById('visitCounterNumber');
            if (!counter) return;
            
            if (database) {
                const visitsRef = database.ref('siteStats/visits');
                visitsRef.transaction((current) => {
                    return (current || 0) + 1;
                }, (error, committed, snapshot) => {
                    if (!error && committed && snapshot) {
                        counter.textContent = snapshot.val().toLocaleString();
                    }
                });
                
                // Listen for updates
                visitsRef.on('value', (snapshot) => {
                    const visits = snapshot.val() || 0;
                    counter.textContent = visits.toLocaleString();
                });
            } else {
                // Fallback to localStorage
                let visits = parseInt(localStorage.getItem('siteVisits') || '0');
                visits++;
                localStorage.setItem('siteVisits', visits.toString());
                counter.textContent = visits.toLocaleString();
            }
        }
        
        // Whoami profile
        function showWhoami(targetUserId = null) {
            const currentUserId = getUserId();
            const userId = targetUserId || currentUserId;
            
            // Try to get profile from Firebase first (for online users)
            if (database && userId !== currentUserId) {
                database.ref(`users/${userId}`).once('value', (snapshot) => {
                    const userData = snapshot.val();
                    if (userData) {
                        const bio = userData.bio || getUserBio(userId);
                        const isOnline = userData.online || (Date.now() - (userData.lastSeen || 0) < 60000);
                        const status = isOnline ? ' Online' : ' Offline';
                        const profile = `ID: ${userId} | ${status} | Bio: ${bio || '(No bio set)'}`;
                        showCommandFeedback('whoami', profile, true);
                    } else {
                        // Fallback to localStorage
                        const bio = getUserBio(userId);
                        if (bio) {
                            showCommandFeedback('whoami', `ID: ${userId} | Bio: ${bio}`, true);
                        } else {
                            showCommandFeedback('whoami', `ID: ${userId} | Bio: (User not found or has no bio)`, false);
                        }
                    }
                });
            } else {
                // Use localStorage
                let profile;
                if (userId === currentUserId) {
                    // Show own profile
                    const bio = getUserBio(userId);
                    if (bio) {
                        profile = `ID: ${userId} | Bio: ${bio}`;
                    } else {
                        profile = `ID: ${userId} | Bio: (No bio set. Use "iam [your bio]" to set one)`;
                    }
                } else {
                    // Show other user's profile
                    const bio = getUserBio(userId);
                    if (bio) {
                        profile = `ID: ${userId} | Bio: ${bio}`;
                    } else {
                        profile = `ID: ${userId} | Bio: (User not found or has no bio)`;
                    }
                }
                showCommandFeedback('whoami', profile, true);
            }
            
            const commandInput = document.getElementById('commandInput');
            if (commandInput) {
                commandInput.value = '';
                commandInput.placeholder = 'Profile displayed!';
                setTimeout(() => {
                    commandInput.placeholder = 'Type a color or "home"...';
                }, 2000);
            }
        }
        
        function setBio(bioText) {
            if (!bioText || bioText.trim() === '') {
                showCommandFeedback('iam', 'Please provide a bio. Usage: iam [your bio]', false);
                return;
            }
            
            const userId = getUserId();
            setUserBio(userId, bioText.trim());
            
            // Sync bio to Firebase if available
            if (database) {
                try {
                    database.ref(`users/${userId}`).update({
                        bio: bioText.trim(),
                        lastSeen: Date.now()
                    });
                } catch (e) {
                    console.warn('Could not sync bio to Firebase:', e);
                }
            }
            
            showCommandFeedback('iam', `Bio updated! Your ID is: ${userId}`, true);
            
            const commandInput = document.getElementById('commandInput');
            if (commandInput) {
                commandInput.value = '';
                commandInput.placeholder = `Bio set! Your ID: ${userId}`;
                setTimeout(() => {
                    commandInput.placeholder = 'Type a color or "home"...';
                }, 3000);
            }
        }
        
        // Chat System
        let chatListeners = [];
        let onlineUsersListeners = [];
        
        function initChat() {
            if (!database) {
                console.warn('Firebase not available - chat will use localStorage only');
                return;
            }
            
            const userId = getUserId();
            const userBio = getUserBio(userId);
            
            // Mark user as online
            const userRef = database.ref(`users/${userId}`);
            userRef.set({
                id: userId,
                bio: userBio || '',
                online: true,
                lastSeen: Date.now()
            });
            
            // Remove online status when page unloads
            window.addEventListener('beforeunload', () => {
                userRef.update({ online: false, lastSeen: Date.now() });
            });
        }
        
        function loadChatMessages() {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            if (database) {
                // Load from Firebase
                const messagesRef = database.ref('messages').limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const currentUserId = getUserId();
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
                messagesContainer.innerHTML = '';
                const currentUserId = getUserId();
                messages.forEach(msg => {
                    addMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user" onclick="showWhoami('${message.userId}')">${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendChatMessage(text) {
            if (!text || !text.trim()) return;
            
            const userId = getUserId();
            const message = {
                userId: userId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                // Send to Firebase
                database.ref('messages').push(message);
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
                messages.push(message);
                // Keep only last 100 messages
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem('chatMessages', JSON.stringify(messages));
                addMessageToUI(message, true);
            }
        }
        
        function loadOnlineUsers() {
            const usersList = document.getElementById('onlineUsersList');
            if (!usersList) return;
            
            if (database) {
                const usersRef = database.ref('users');
                usersRef.on('value', (snapshot) => {
                    const users = snapshot.val() || {};
                    const currentTime = Date.now();
                    const onlineThreshold = 60000; // 1 minute
                    
                    usersList.innerHTML = '';
                    
                    Object.entries(users).forEach(([id, user]) => {
                        const isOnline = user.online || (currentTime - (user.lastSeen || 0) < onlineThreshold);
                        if (isOnline) {
                            const userDiv = document.createElement('div');
                            userDiv.className = 'online-user-item';
                            userDiv.innerHTML = `<span class="user-id">${id}</span>${user.bio ? `: ${user.bio.substring(0, 30)}` : ''}`;
                            userDiv.onclick = () => showWhoami(id);
                            usersList.appendChild(userDiv);
                        }
                    });
                });
            } else {
                // Fallback: show local users
                usersList.innerHTML = '<div class="online-user-item"><span class="user-id">' + getUserId() + '</span> (Local only)</div>';
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize chat when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initChat();
            
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            
            if (chatInput && chatSendBtn) {
                chatSendBtn.onclick = () => {
                    const text = chatInput.value;
                    if (text.trim()) {
                        sendChatMessage(text);
                        chatInput.value = '';
                    }
                };
                
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        chatSendBtn.click();
                    }
                });
            }
        });
        
        // Load clock setting on page load
        loadClockSetting();
        
        // Command input handler
        const commandInput = document.getElementById('commandInput');
        
        // Semicolon key to focus command bar (works even when paper app is active)
        document.addEventListener('keydown', (e) => {
            // Only trigger if semicolon is pressed and not already typing in command input
            if (e.key === ';' && document.activeElement !== commandInput) {
                const activeEl = document.activeElement;
                
                // Block semicolon only if in a regular input/textarea (not contentEditable like paper app)
                const isRegularInput = activeEl && (
                    (activeEl.tagName === 'INPUT' && activeEl.id !== 'commandInput') || 
                    activeEl.tagName === 'TEXTAREA'
                );
                
                // Allow semicolon from anywhere except regular inputs/textareas
                // This includes paper app (contentEditable) and other places
                if (!isRegularInput) {
                    e.preventDefault();
                    commandInput.focus();
                    commandInput.select(); // Select any existing text
                }
            }
        });
        
        commandInput.addEventListener('keydown', (e) => {
            // Disable commands when on remote desktop
            const remoteDesktopPage = document.getElementById('remoteDesktopPage');
            if (remoteDesktopPage && !remoteDesktopPage.classList.contains('hidden')) {
                // Allow semicolon to work, but block other commands
                if (e.key !== ';' && e.key !== 'Enter') {
                    return;
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    showCommandFeedback('command', 'Commands disabled on desktop. Use ; to exit.', false);
                    return;
                }
            }
            
            if (e.key === 'Enter') {
                const command = commandInput.value.toLowerCase().trim();
                const hasColorPalette = colorPalettes.hasOwnProperty(command);
                
                // Handle navigation commands
                if (command === 'reset') {
                    // Check if reset has already been used
                    if (sessionStorage.getItem('resetUsed') === 'true') {
                        commandInput.value = '';
                        commandInput.placeholder = 'Reset can only be used once per session!';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    } else if (resetConfirm) {
                        // Second time - actually reset
                        resetEverything();
                        commandInput.value = '';
                        resetConfirm = false;
                            } else {
                        // First time - ask for confirmation
                        resetConfirm = true;
                        commandInput.value = '';
                        commandInput.placeholder = ' Type "reset" again to confirm - THIS WILL DELETE ALL PROGRESS!';
                        setTimeout(() => {
                            resetConfirm = false;
                            if (commandInput.placeholder.includes('confirm')) {
                                commandInput.placeholder = 'Type a color or "home"...';
                            }
                        }, 5000);
                    }
                } else if (command === 'home') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('homePage');
                    showCommandFeedback('home', 'Navigated to home page', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'back') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('mainPage');
                    showCommandFeedback('back', 'Returned to main page', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type a color or "home"...';
                } else if (command === 'sweeper') {
                    resetConfirm = false;
                    showPage('minesweeperPage');
                    initMinesweeper();
                    showCommandFeedback('sweeper', 'Minesweeper game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'pong') {
                    resetConfirm = false;
                    showPage('pongPage');
                    showCommandFeedback('pong', 'Pong game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'sandboxles') {
                    resetConfirm = false;
                    showPage('sandboxelsPage');
                    showCommandFeedback('sandboxles', 'Sandboxels opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'paint') {
                    resetConfirm = false;
                    showPage('paintPage');
                    initPaint();
                    showCommandFeedback('paint', 'Paint game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'drawing board' || command === 'drawingboard' || command === 'collab') {
                    resetConfirm = false;
                    showPage('drawingBoardPage');
                    showCommandFeedback('drawing board', 'Collaborative drawing board opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'remote desktop' || command === 'remotedesktop' || command === 'desktop') {
                    resetConfirm = false;
                    showPage('remoteDesktopPage');
                    setTimeout(() => {
                        initRemoteDesktop();
                    }, 100);
                    showCommandFeedback('remote desktop', 'Remote desktop opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'snake') {
                    resetConfirm = false;
                    // Execute snake game JavaScript
                    (function() {
                        if(window.snakeGameActive) return;
                        window.snakeGameActive = true;

                        const snakeColor = '#00FF00';
                        const headColor = '#FFFF00';
                        const snakeSpeed = 80; // faster for smoother movement
                        const snakeSize = 20;
                        const maxLength = 50;

                        let snake = [{x: 100, y: 100}];
                        let direction = 'right';
                        let grow = 0;

                        const canvas = document.createElement('canvas');
                        canvas.style.position = 'fixed';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.zIndex = '9999';
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        document.body.appendChild(canvas);
                        const ctx = canvas.getContext('2d');

                        // Polyfill for roundRect if not available
                        if (!ctx.roundRect) {
                            ctx.roundRect = function(x, y, width, height, radius) {
                                this.beginPath();
                                this.moveTo(x + radius, y);
                                this.lineTo(x + width - radius, y);
                                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                                this.lineTo(x + width, y + height - radius);
                                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                this.lineTo(x + radius, y + height);
                                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                                this.lineTo(x, y + radius);
                                this.quadraticCurveTo(x, y, x + radius, y);
                                this.closePath();
                            };
                        }

                        window.addEventListener('keydown', e => {
                            if(e.key === 'ArrowUp' && direction !== 'down') direction = 'up';
                            if(e.key === 'ArrowDown' && direction !== 'up') direction = 'down';
                            if(e.key === 'ArrowLeft' && direction !== 'right') direction = 'left';
                            if(e.key === 'ArrowRight' && direction !== 'left') direction = 'right';
                            // Allow escape to close
                            if(e.key === 'Escape') {
                                canvas.remove();
                                window.snakeGameActive = false;
                            }
                        });

                        function wrapWords() {
                            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
                            const textNodes = [];
                            while(walker.nextNode()) textNodes.push(walker.currentNode);

                            textNodes.forEach(node => {
                                if(node.nodeValue.trim() === '') return;
                                const words = node.nodeValue.split(/(\s+)/);
                                const fragment = document.createDocumentFragment();
                                words.forEach(word => {
                                    if(word.trim() === '') {
                                        fragment.appendChild(document.createTextNode(word));
                                    } else {
                                        const span = document.createElement('span');
                                        span.textContent = word;
                                        span.style.display = 'inline-block';
                                        fragment.appendChild(span);
                                    }
                                });
                                node.parentNode.replaceChild(fragment, node);
                            });
                        }

                        wrapWords();

                        function moveSnake() {
                            const head = {...snake[0]};
                            const step = 10; // smaller step for better collision
                            if(direction === 'up') head.y -= step;
                            if(direction === 'down') head.y += step;
                            if(direction === 'left') head.x -= step;
                            if(direction === 'right') head.x += step;

                            snake.unshift(head);

                            if(grow > 0) grow--;
                            else snake.pop();

                            if(snake.length > maxLength) snake.pop();

                            // Eat one word at a time
                            const elements = Array.from(document.body.querySelectorAll('span')).filter(el => el !== canvas);
                            for(let el of elements) {
                                const rect = el.getBoundingClientRect();
                                const padding = 4; // smaller hitbox
                                if(head.x + padding < rect.right && head.x + snakeSize - padding > rect.left &&
                                   head.y + padding < rect.bottom && head.y + snakeSize - padding > rect.top) {
                                    el.style.visibility = 'hidden';
                                    grow += 1;
                                    break;
                                }
                            }
                        }

                        function drawSnake() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // Draw tail with gradient effect
                            for(let i = 0; i < snake.length; i++) {
                                const seg = snake[i];
                                const t = i / snake.length;
                                ctx.fillStyle = `rgba(${Math.floor(0 + t*255)}, ${Math.floor(255 - t*100)}, 0, 1)`;
                                ctx.beginPath();
                                ctx.roundRect(seg.x, seg.y, snakeSize, snakeSize, 6); // rounded corners
                                ctx.fill();
                            }

                            // Draw head
                            const head = snake[0];
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.roundRect(head.x, head.y, snakeSize, snakeSize, 8);
                            ctx.fill();
                        }

                        function gameLoop() {
                            moveSnake();
                            drawSnake();
                        }

                        setInterval(gameLoop, snakeSpeed);

                        console.log("Snake game started! Arrow keys move. Snake eats one word at a time, hitbox improved. Press ESC to exit.");
                    })();
                    commandsUsed.add('snake');
                    commandInput.value = '';
                    commandInput.placeholder = 'Snake game started! Press ESC to exit.';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 3000);
                } else if (command === 'finley') {
                    resetConfirm = false;
                    transformToFinHubMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Welcome back to FinHub!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'coinflip') {
                    resetConfirm = false;
                    showPage('coinflipPage');
                    resetCoinFlip();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'clicker') {
                    resetConfirm = false;
                    showPage('clickerPage');
                    updateAllMoneyDisplays();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'achievements' || command === 'ach') {
                    resetConfirm = false;
                    showPage('achievementsPage');
                    renderAchievements();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'changelog') {
                    resetConfirm = false;
                    showPage('changelogPage');
                    loadChangelog();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'background' || command === 'bg') {
                    resetConfirm = false;
                    showPage('backgroundPage');
                    initBackground();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'goose') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    transformToGooseMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Honk! GooseHub activated!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'honk') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    if (unlockedCommands.has('honk')) {
                        playHonkSound();
                        showCommandFeedback('honk', 'HONK! ', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'HONK! ';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                                    } else {
                        showCommandFeedback('honk', 'Command not unlocked yet! Use "goose" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'Honk command not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'gooserain') {
                    resetConfirm = false;
                    if (unlockedCommands.has('gooserain')) {
                        showPage('gooserainPage');
                        initGooseRain();
                        showCommandFeedback('gooserain', 'Goose rain activated!', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'Type "back" to return';
                    } else {
                        showCommandFeedback('gooserain', 'Command not unlocked yet! Use "goose" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'Goose rain not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'stones') {
                    resetConfirm = false;
                    showPage('stonesPage');
                    initStones();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'wooper') {
                    resetConfirm = false;
                    applyWooperColors();
                    unlockCommand('wooperbird');
                    commandInput.value = '';
                    commandInput.placeholder = 'Wooper colors applied! ';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'wooperbird') {
                    resetConfirm = false;
                    if (unlockedCommands.has('wooperbird')) {
                        spawnWooperbirdGoose();
                        showCommandFeedback('wooperbird', 'WooperBird dropped! ', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird dropped! ';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    } else {
                        showCommandFeedback('wooperbird', 'Command not unlocked yet! Use "wooper" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird not unlocked yet! Use "wooper" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'panicmenu' || command === 'panic') {
                    resetConfirm = false;
                    showPage('panicmenuPage');
                    initPanicMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'jumpscare') {
                    resetConfirm = false;
                    triggerJumpscare();
                    commandInput.value = '';
                    commandInput.placeholder = 'BOO! ';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === '67') {
                    resetConfirm = false;
                    // Get current count
                    let count67 = parseInt(localStorage.getItem('count67') || '0');
                    count67++;
                    localStorage.setItem('count67', count67.toString());
                    
                    commandInput.value = '';
                    commandInput.placeholder = 'DONT SAY THAT';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                    
                    // Block after 3 uses
                    if (count67 >= 3) {
                        localStorage.setItem('isBlocked', 'true');
                        showPage('limboPage');
                        const commandBar = document.querySelector('.command-bar');
                        if (commandBar) commandBar.style.display = 'none';
                    }
                } else if (command === 'cmds') {
                    resetConfirm = false;
                    toggleCommandsMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Commands menu toggled!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'clock') {
                    resetConfirm = false;
                    const wasEnabled = clockEnabled;
                    if (clockEnabled) {
                        hideClock();
                        showCommandFeedback('clock', `Clock: ${wasEnabled}  false`, true);
                    } else {
                        showClock();
                        showCommandFeedback('clock', `Clock: ${wasEnabled}  true`, true);
                    }
                    commandInput.value = '';
                    commandInput.placeholder = `Clock: ${clockEnabled}`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command.startsWith('whoami ')) {
                    resetConfirm = false;
                    const targetId = command.substring(7).trim();
                    showWhoami(targetId);
                } else if (command === 'edit') {
                    resetConfirm = false;
                    openEditMenu();
                } else if (command.startsWith('friend ')) {
                    resetConfirm = false;
                    const friendId = command.substring(7).trim();
                    if (!friendId) {
                        showCommandFeedback('friend', 'Please provide a user ID. Usage: friend [user id]', false);
                    } else if (friendId === getUserId()) {
                        showCommandFeedback('friend', 'You cannot add yourself as a friend!', false);
                    } else {
                        if (addFriend(friendId)) {
                            showCommandFeedback('friend', `Added ${friendId} as a friend!`, true);
                        } else {
                            showCommandFeedback('friend', `${friendId} is already your friend!`, false);
                        }
                    }
                } else if (command === 'friends') {
                    resetConfirm = false;
                    openFriendsList();
                } else if (command === 'chat') {
                    resetConfirm = false;
                    const chatPage = document.getElementById('chatPage');
                    if (chatPage && !chatPage.classList.contains('hidden')) {
                        // Chat is open, close it
                        showPage('mainPage');
                        showCommandFeedback('chat', 'Chat closed!', true);
                    } else {
                        // Chat is closed, open it
                        showPage('chatPage');
                        loadChatMessages();
                        loadOnlineUsers();
                        showCommandFeedback('chat', 'Chat opened!', true);
                    }
                } else if (command === 'whoami') {
                    resetConfirm = false;
                    showWhoami();
                } else if (command.startsWith('setid ') || command.startsWith('setuserid ')) {
                    resetConfirm = false;
                    const newId = command.startsWith('setid ') ? command.substring(6).trim() : command.substring(10).trim();
                    if (!newId) {
                        showCommandFeedback('setid', 'Please provide a user ID. Usage: setid [your new id]', false);
                    } else {
                        const result = setUserId(newId);
                        if (result === false) {
                            showCommandFeedback('setid', 'Invalid ID or ID already taken. Use 3-20 characters (letters, numbers, _, -)', false);
                        } else if (result === true) {
                            showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                        } else {
                            // Promise result
                            result.then((success) => {
                                if (success) {
                                    showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                                } else {
                                    showCommandFeedback('setid', 'ID already taken by another user. Choose a different ID.', false);
                                }
                            });
                        }
                    }
                } else if (command.startsWith('setid ') || command.startsWith('setuserid ')) {
                    resetConfirm = false;
                    const newId = command.startsWith('setid ') ? command.substring(6).trim() : command.substring(10).trim();
                    if (!newId) {
                        showCommandFeedback('setid', 'Please provide a user ID. Usage: setid [your new id]', false);
                    } else {
                        const result = setUserId(newId);
                        if (result === false) {
                            showCommandFeedback('setid', 'Invalid ID or ID already taken. Use 3-20 characters (letters, numbers, _, -)', false);
                        } else if (result === true) {
                            showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                        } else {
                            // Promise result
                            result.then((success) => {
                                if (success) {
                                    showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                                } else {
                                    showCommandFeedback('setid', 'ID already taken by another user. Choose a different ID.', false);
                                }
                            });
                        }
                    }
                } else if (command.startsWith('iam ')) {
                    resetConfirm = false;
                    const bioText = command.substring(4).trim();
                    setBio(bioText);
                } else if (command === 'stars') {
                    resetConfirm = false;
                    spawnMoreStars(50);
                    commandInput.value = '';
                    commandInput.placeholder = 'More stars spawned!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'flashcard' || command === 'fc') {
                    resetConfirm = false;
                    createFlashcard();
                    commandInput.value = '';
                    commandInput.placeholder = 'Flashcard created!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command.startsWith('theme ')) {
                    resetConfirm = false;
                    const themeName = command.substring(6).trim().toLowerCase();
                    applyTheme(themeName);
                    commandInput.value = '';
                    commandInput.placeholder = `Theme changed to ${themeName}!`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'rainbow') {
                    resetConfirm = false;
                    applyRainbowColors();
                    showCommandFeedback('rainbow', 'Rainbow colors applied!', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Rainbow colors applied!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (hasColorPalette) {
                    resetConfirm = false;
                    changeAllColors(command);
                    showCommandFeedback(command, `Changed to ${command}!`, true);
                    commandInput.value = '';
                    commandInput.placeholder = `Changed to ${command}!`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else {
                    resetConfirm = false; // Clear reset confirmation if invalid command
                    showCommandFeedback(command, 'Command not found. Try: cmds, home, back, or a color name...', false);
                    commandInput.value = '';
                    commandInput.placeholder = 'Command not found. Try: cmds, home, back, or a color name...';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                }
            }
        });
        
        // Minesweeper game code
        const GRID_SIZE = 10;
        const NUM_MINES = 10;
        const gridEl = document.getElementById('minesweeper-grid');
        const messageEl = document.getElementById('message');
        const restartBtn = document.getElementById('restart-btn');

        let board = [];
        let isGameOver = false;
        let flagsRemaining = NUM_MINES;
        let revealedCount = 0;

        function createBoard() {
            board = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill({ 
                    isMine: false, 
                    isRevealed: false, 
                    isFlagged: false, 
                    mineCount: 0,
                    el: null
                })
            );
            let minesPlaced = 0;
            while (minesPlaced < NUM_MINES) {
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);
                if (!board[r][c].isMine) {
                    board[r][c] = { ...board[r][c], isMine: true }; 
                    minesPlaced++;
                }
            }
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (!board[r][c].isMine) {
                        board[r][c] = { ...board[r][c], mineCount: countMines(r, c) };
                    }
                }
            }
        }

        function countMines(r, c) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                        if (board[nr][nc].isMine) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        function revealCell(r, c) {
            if (isGameOver || r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || board[r][c].isRevealed || board[r][c].isFlagged) {
                return;
            }
            const cell = board[r][c];
            cell.isRevealed = true;
            revealedCount++;
            cell.el.classList.add('revealed');
            cell.el.innerHTML = '';
            cell.el.style.borderColor = 'transparent';

            if (cell.isMine) {
                cell.el.classList.add('mine');
                cell.el.innerHTML = '';
                gameOver(false);
                return;
            } 
            
            if (cell.mineCount > 0) {
                cell.el.innerHTML = cell.mineCount;
                cell.el.classList.add(`number-${cell.mineCount}`);
                    } else {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            checkWin();
        }

        function toggleFlag(r, c) {
            if (isGameOver || board[r][c].isRevealed) return;
            const cell = board[r][c];
            if (cell.isFlagged) {
                cell.isFlagged = false;
                flagsRemaining++;
                cell.el.innerHTML = '';
                cell.el.classList.remove('flag');
            } else if (flagsRemaining > 0) {
                cell.isFlagged = true;
                flagsRemaining--;
                cell.el.innerHTML = '';
                cell.el.classList.add('flag');
            }
            updateMessage();
        }

        function drawGrid() {
            if (!gridEl) return;
            gridEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = board[r][c];
                    const cellEl = document.createElement('div');
                    cellEl.classList.add('cell');
                    cellEl.dataset.r = r;
                    cellEl.dataset.c = c;
                    cell.el = cellEl;
                    cellEl.addEventListener('click', () => revealCell(r, c));
                    cellEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(r, c);
                    });
                    gridEl.appendChild(cellEl);
                }
            }
            updateMessage();
        }

        function updateMessage() {
            if (!messageEl) return;
            if (!isGameOver) {
                messageEl.innerHTML = `Flags Remaining: ${flagsRemaining}`;
            }
        }

        function checkWin() {
            if (revealedCount === (GRID_SIZE * GRID_SIZE) - NUM_MINES) {
                gameOver(true);
            }
        }

        function gameOver(win) {
            isGameOver = true;
            if (!messageEl) return;
            if (win) {
                messageEl.innerHTML = ' YOU WIN! ';
                messageEl.style.color = 'green';
                    } else {
                messageEl.innerHTML = ' GAME OVER! ';
                messageEl.style.color = 'red';
                board.flat().forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.el.classList.add('mine');
                        cell.el.innerHTML = '';
                    }
                });
            }
        }

        function initGame() {
            isGameOver = false;
            flagsRemaining = NUM_MINES;
            revealedCount = 0;
            if (messageEl) {
                messageEl.style.color = 'black';
            }
            createBoard();
            drawGrid();
        }

        function initMinesweeper() {
            if (restartBtn) {
                restartBtn.addEventListener('click', initGame);
            }
            initGame();
        }
        
        // Pong game code - placeholder for JavaScript
        function initPong() {
            // Pong game initialization will go here
            // Waiting for JavaScript code...
        }
        
        // Pong settings modal functions
        window.toggleSettingsModal = function() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.toggle('hidden');
            }
        };
        
        window.saveSettingsAndRestart = function() {
            // Settings save and restart will go here
            // Waiting for JavaScript code...
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };
        
        // Sandboxels close function
        function closeSandboxels() {
            showPage('mainPage');
        }
        
        // Pong close function
        function closePong() {
            showPage('mainPage');
        }
        
        // Jumpscare function
        function triggerJumpscare() {
            // Remove any existing jumpscare overlay
            const existing = document.getElementById('jumpscareOverlay');
            if (existing) {
                existing.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'jumpscareOverlay';
            overlay.className = 'jumpscare-overlay';
            
            // Create image element
            const img = document.createElement('img');
            img.className = 'jumpscare-image';
            // Note: You'll need to add your image file to the project and set the src
            // For now, using a placeholder - replace with your image path/URL
            img.src = 'jumpscare.jpg'; // Change this to your image file path or URL
            img.alt = 'Jumpscare';
            
            overlay.appendChild(img);
            document.body.appendChild(overlay);
            
            // Trigger animation by adding active class
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
            
            // Remove overlay after animation completes
            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, 1300); // 300ms pop + 800ms delay + 500ms fade
        }
        
        // Background selection system
        let bgMode = 'solid'; // 'solid' or 'gradient'
        let selectedGradientColor1 = null;
        let selectedGradientColor2 = null;
        let selectedSolidColor = null;
        
        // Map color names to hex values (use first color from each palette)
        const bgColorMap = {
            'black': '#000000',
            'red': '#ff0000',
            'blue': '#0000ff',
            'green': '#00ff00',
            'yellow': '#ffff00',
            'purple': '#800080',
            'orange': '#ffa500',
            'white': '#ffffff',
            'pink': '#ff69b4',
            'cyan': '#00ffff',
            'lime': '#00ff00',
            'magenta': '#ff00ff',
            'brown': '#a52a2a',
            'gray': '#808080',
            'grey': '#808080',
            'gold': '#ffd700',
            'silver': '#c0c0c0'
        };
        
        // Load background preferences
        function loadBackgroundPreferences() {
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
                // Only apply if on dark or light theme
                if (currentTheme === 'dark' || currentTheme === 'light') {
                    if (prefs.mode === 'solid' && prefs.color) {
                        applyBackgroundColor(prefs.color);
                        selectedSolidColor = prefs.color;
                    } else if (prefs.mode === 'gradient' && prefs.color1 && prefs.color2) {
                        const gradient = `linear-gradient(to bottom, ${prefs.color1}, ${prefs.color2})`;
                        applyBackgroundColor(gradient);
                        selectedGradientColor1 = prefs.color1;
                        selectedGradientColor2 = prefs.color2;
                    }
                }
            }
        }
        
        // Save background preferences
        function saveBackgroundPreferences() {
            const prefs = {
                mode: bgMode,
                color: bgMode === 'solid' ? selectedSolidColor : null,
                color1: bgMode === 'gradient' ? selectedGradientColor1 : null,
                color2: bgMode === 'gradient' ? selectedGradientColor2 : null
            };
            localStorage.setItem('backgroundPrefs', JSON.stringify(prefs));
        }
        
        // Initialize background page
        function initBackground() {
            // Show/hide warning based on current theme
            const warningEl = document.getElementById('bg-theme-warning');
            if (warningEl) {
                if (currentTheme === 'dark' || currentTheme === 'light') {
                    warningEl.style.display = 'none';
                } else {
                    warningEl.style.display = 'block';
                }
            }
            
            // Load saved preferences
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
            }
            
            setBgMode(bgMode);
            renderColorButtons();
        }
        
        // Set background mode (solid or gradient)
        function setBgMode(mode) {
            bgMode = mode;
            
            const solidSection = document.getElementById('bg-solid-section');
            const gradientSection = document.getElementById('bg-gradient-section');
            const solidBtn = document.getElementById('bg-solid-btn');
            const gradientBtn = document.getElementById('bg-gradient-btn');
            
            if (mode === 'solid') {
                if (solidSection) solidSection.style.display = 'block';
                if (gradientSection) gradientSection.style.display = 'none';
                if (solidBtn) solidBtn.style.background = '#238636';
                if (gradientBtn) gradientBtn.style.background = '#30363d';
                } else {
                if (solidSection) solidSection.style.display = 'none';
                if (gradientSection) gradientSection.style.display = 'block';
                if (solidBtn) solidBtn.style.background = '#30363d';
                if (gradientBtn) gradientBtn.style.background = '#238636';
                selectedGradientColor1 = null;
                selectedGradientColor2 = null;
                updateGradientSelection();
            }
        }
        
        // Render color buttons
        function renderColorButtons() {
            const solidColors = document.getElementById('bg-solid-colors');
            const gradientColors = document.getElementById('bg-gradient-colors');
            
            if (solidColors) {
                solidColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => applySolidBackground(colorName);
                    btn.title = colorName;
                    solidColors.appendChild(btn);
                });
            }
            
            if (gradientColors) {
                gradientColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => selectGradientColor(colorName);
                    btn.title = colorName;
                    gradientColors.appendChild(btn);
                });
            }
        }
        
        // Apply solid background
        function applySolidBackground(colorName) {
            // Only allow colors on dark and light themes
            if (currentTheme !== 'dark' && currentTheme !== 'light') {
                showCommandFeedback('background', 'Background colors only work on dark or light theme', false);
                return;
            }
            
            const color = bgColorMap[colorName];
            if (color) {
                // Apply with !important using a style element
                applyBackgroundColor(color);
                selectedSolidColor = color;
                saveBackgroundPreferences();
                showCommandFeedback('background', `Background changed to ${colorName}`, true);
            }
        }
        
        // Select gradient color
        function selectGradientColor(colorName) {
            const color = bgColorMap[colorName];
            if (!color) return;
            
            if (!selectedGradientColor1) {
                selectedGradientColor1 = color;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
            } else if (!selectedGradientColor2) {
                selectedGradientColor2 = color;
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color2NameEl) color2NameEl.textContent = colorName;
                
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = false;
                    applyBtn.style.cursor = 'pointer';
                    applyBtn.style.background = '#238636';
                }
                        } else {
                // Reset and select first color again
                selectedGradientColor1 = color;
                selectedGradientColor2 = null;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
                if (color2NameEl) color2NameEl.textContent = 'Not selected';
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = true;
                    applyBtn.style.cursor = 'not-allowed';
                    applyBtn.style.background = '#30363d';
                }
            }
        }
        
        // Update gradient selection display
        function updateGradientSelection() {
            const color1NameEl = document.getElementById('bg-gradient-color1-name');
            const color2NameEl = document.getElementById('bg-gradient-color2-name');
            const applyBtn = document.getElementById('bg-apply-gradient-btn');
            
            if (color1NameEl) color1NameEl.textContent = 'Not selected';
            if (color2NameEl) color2NameEl.textContent = 'Not selected';
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.style.cursor = 'not-allowed';
                applyBtn.style.background = '#30363d';
            }
        }
        
        // Apply gradient background
        function applyGradientBackground() {
            // Only allow colors on dark and light themes
            if (currentTheme !== 'dark' && currentTheme !== 'light') {
                showCommandFeedback('background', 'Background colors only work on dark or light theme', false);
                return;
            }
            
            if (selectedGradientColor1 && selectedGradientColor2) {
                const gradient = `linear-gradient(to bottom, ${selectedGradientColor1}, ${selectedGradientColor2})`;
                applyBackgroundColor(gradient);
                saveBackgroundPreferences();
                showCommandFeedback('background', 'Gradient background applied', true);
            }
        }
        
        // Helper function to apply background color with !important
        let customBgStyleEl = null;
        function applyBackgroundColor(colorOrGradient) {
            // Remove existing custom background style
            if (customBgStyleEl) {
                customBgStyleEl.remove();
            }
            
            // Create new style element with !important
            customBgStyleEl = document.createElement('style');
            customBgStyleEl.id = 'custom-background-style';
            customBgStyleEl.textContent = `body.theme-dark, body.theme-light { background: ${colorOrGradient} !important; } body.theme-dark .page, body.theme-light .page { background: ${colorOrGradient} !important; }`;
            document.head.appendChild(customBgStyleEl);
        }
        
        // Remove custom background when switching themes
        function removeCustomBackground() {
            if (customBgStyleEl) {
                customBgStyleEl.remove();
                customBgStyleEl = null;
            }
        }
        
        // Theme System
        const availableThemes = ['1995', 'cyberpunk', 'terminal', 'coffee', 'dark', 'light', 'matrix', 'paper', 'space', 'ocean', 'clouds', 'flashcard'];
        let currentTheme = 'dark'; // Default theme
        
        // Load saved theme
        function loadTheme() {
            const saved = localStorage.getItem('selectedTheme');
            if (saved && availableThemes.includes(saved)) {
                currentTheme = saved;
                applyTheme(saved, false); // false = don't save (already loaded)
            } else {
                applyTheme('dark', false); // Apply default without saving
            }
        }
        
        // Save theme preference
        function saveTheme(themeName) {
            localStorage.setItem('selectedTheme', themeName);
        }
        
        // Apply theme
        function applyTheme(themeName, save = true) {
            // Remove all theme classes
            document.body.classList.remove(...availableThemes.map(t => `theme-${t}`));
            
            // Validate theme name
            if (!availableThemes.includes(themeName)) {
                showCommandFeedback(`theme ${themeName}`, `Invalid theme. Available: ${availableThemes.join(', ')}`, false);
                const commandInput = document.getElementById('commandInput');
                if (commandInput) {
                    commandInput.placeholder = `Invalid theme: ${themeName}. Available: ${availableThemes.join(', ')}`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 3000);
                }
                return;
            }
            
            // Handle custom backgrounds
            const wasDarkOrLight = (currentTheme === 'dark' || currentTheme === 'light');
            const willBeDarkOrLight = (themeName === 'dark' || themeName === 'light');
            
            // Remove custom background if switching away from dark/light
            if (wasDarkOrLight && !willBeDarkOrLight) {
                removeCustomBackground();
            }
            
            // Add new theme class
            document.body.classList.add(`theme-${themeName}`);
            currentTheme = themeName;
            
            // Reapply custom background if switching to dark/light and one exists
            if (willBeDarkOrLight) {
                const saved = localStorage.getItem('backgroundPrefs');
                if (saved) {
                    const prefs = JSON.parse(saved);
                    if (prefs.mode === 'solid' && prefs.color) {
                        applyBackgroundColor(prefs.color);
                    } else if (prefs.mode === 'gradient' && prefs.color1 && prefs.color2) {
                        const gradient = `linear-gradient(to bottom, ${prefs.color1}, ${prefs.color2})`;
                        applyBackgroundColor(gradient);
                    }
                }
            }
            
            if (save) {
                saveTheme(themeName);
            }
            
            showCommandFeedback(`theme ${themeName}`, `Theme changed to ${themeName}!`, true);
        }
        
        // Note: applyTheme will be wrapped below, so we'll set window.applyTheme after wrapping
        
        // Matrix theme keypress handler
        let matrixColumns = [];
        const matrixSpecialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';
        
        function createMatrixColumn(key, x) {
            if (!document.body.classList.contains('theme-matrix')) return;
            
            // Don't create columns for command input
            const commandInput = document.getElementById('commandInput');
            if (commandInput && document.activeElement === commandInput) return;
            
            const column = document.createElement('div');
            column.className = 'matrix-column';
            column.style.left = x + 'px';
            column.style.display = 'flex';
            column.style.flexDirection = 'column';
            
            // Start with the pressed key
            const startChar = document.createElement('span');
            startChar.className = 'char';
            startChar.textContent = key;
            column.appendChild(startChar);
            
            // Add random special characters
            for (let i = 0; i < 30; i++) {
                const char = document.createElement('span');
                char.className = 'char';
                char.textContent = matrixSpecialChars[Math.floor(Math.random() * matrixSpecialChars.length)];
                if (i > 20) {
                    char.classList.add('fade');
                }
                column.appendChild(char);
            }
            
            document.body.appendChild(column);
            matrixColumns.push(column);
            
            // Animate falling
            let position = -50;
            const speed = 0.5 + Math.random() * 1; // Random speed between 0.5-1.5 (slower)
            const animate = () => {
                position += speed;
                column.style.top = position + 'px';
                
                // Remove when off screen
                if (position > window.innerHeight + 100) {
                    column.remove();
                    const index = matrixColumns.indexOf(column);
                    if (index > -1) {
                        matrixColumns.splice(index, 1);
                    }
                } else {
                    requestAnimationFrame(animate);
                }
            };
            
            animate();
        }
        
        // Matrix theme keypress listener
        let matrixKeyHandler = null;
        
        function setupMatrixKeyHandler() {
            // Remove existing handler if any
            if (matrixKeyHandler) {
                document.removeEventListener('keydown', matrixKeyHandler);
                matrixKeyHandler = null;
            }
            
            // Only add handler if matrix theme is active
            if (document.body.classList.contains('theme-matrix')) {
                matrixKeyHandler = (e) => {
                    // Don't trigger on command input
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && document.activeElement === commandInput) return;
                    
                    // Don't trigger on special keys (Ctrl, Alt, etc.)
                    if (e.ctrlKey || e.altKey || e.metaKey) return;
                    
                    // Get the key character
                    let key = e.key;
                    
                    // Handle special keys
                    if (key.length > 1) {
                        // Map special keys to symbols
                        const specialKeyMap = {
                            'Enter': '',
                            ' ': ' ',
                            'Space': ' ',
                            'Tab': '',
                            'Escape': '',
                            'Backspace': '',
                            'Delete': '',
                            'ArrowUp': '',
                            'ArrowDown': '',
                            'ArrowLeft': '',
                            'ArrowRight': ''
                        };
                        
                        if (specialKeyMap[key]) {
                            key = specialKeyMap[key];
                        } else {
                            // Skip other special keys
                            return;
                        }
                    }
                    
                    // Create column at random x position
                    const x = Math.random() * (window.innerWidth - 50);
                    createMatrixColumn(key, x);
                };
                
                document.addEventListener('keydown', matrixKeyHandler);
            }
        }
        
        // Clean up matrix columns when switching themes
        function cleanupMatrixColumns() {
            matrixColumns.forEach(column => column.remove());
            matrixColumns = [];
        }
        
        // Update applyTheme to setup/remove matrix handler and cleanup
        const originalApplyTheme = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup if switching away from matrix
            if (document.body.classList.contains('theme-matrix') && themeName !== 'matrix') {
                cleanupMatrixColumns();
            }
            
            originalApplyTheme(themeName, save);
            
            // Setup matrix handler if switching to matrix
            setupMatrixKeyHandler();
        };
        
        // Make wrapped applyTheme globally accessible
        window.applyTheme = applyTheme;
        
        // Load theme on page load
        loadTheme();
        
        // Load background preferences after theme is loaded
        setTimeout(() => {
            loadBackgroundPreferences();
        }, 50);
        
        // Setup matrix handler on page load if matrix theme is active
        setTimeout(() => {
            setupMatrixKeyHandler();
        }, 100);
        
        // Space theme - stars that react to cursor
        let spaceStars = [];
        let spaceMouseHandler = null;
        
        function createSpaceStars() {
            // Remove existing stars
            cleanupSpaceStars();
            
            if (!document.body.classList.contains('theme-space')) return;
            
            // Create stars
            const starCount = 100;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'space-star';
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                star.style.width = (Math.random() * 2 + 1) + 'px';
                star.style.height = star.style.width;
                star.dataset.x = x;
                star.dataset.y = y;
                document.body.appendChild(star);
                spaceStars.push(star);
            }
        }
        
        function cleanupSpaceStars() {
            spaceStars.forEach(star => star.remove());
            spaceStars = [];
        }
        
        function setupSpaceTheme() {
            // Remove existing handler
            if (spaceMouseHandler) {
                document.removeEventListener('mousemove', spaceMouseHandler);
                spaceMouseHandler = null;
            }
            
            if (document.body.classList.contains('theme-space')) {
                createSpaceStars();
                
                spaceMouseHandler = (e) => {
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    const pushRadius = 100; // Distance stars get pushed
                    
                    spaceStars.forEach(star => {
                        const starX = parseFloat(star.dataset.x) || 0;
                        const starY = parseFloat(star.dataset.y) || 0;
                        
                        const dx = starX - mouseX;
                        const dy = starY - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < pushRadius && distance > 0) {
                            // Push star away from cursor
                            const angle = Math.atan2(dy, dx);
                            const pushDistance = (pushRadius - distance) / pushRadius;
                            const newX = starX + Math.cos(angle) * pushDistance * 30;
                            const newY = starY + Math.sin(angle) * pushDistance * 30;
                            
                            // Keep stars within bounds
                            const clampedX = Math.max(0, Math.min(window.innerWidth, newX));
                            const clampedY = Math.max(0, Math.min(window.innerHeight, newY));
                            
                            star.style.left = clampedX + 'px';
                            star.style.top = clampedY + 'px';
                            star.dataset.x = clampedX;
                            star.dataset.y = clampedY;
                        }
                    });
                };
                
                document.addEventListener('mousemove', spaceMouseHandler);
            } else {
                cleanupSpaceStars();
            }
        }
        
        // Update applyTheme to handle space theme
        const originalApplyTheme3 = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup space theme if switching away
            if (document.body.classList.contains('theme-space') && themeName !== 'space') {
                cleanupSpaceStars();
            }
            
            originalApplyTheme3(themeName, save);
            
            // Setup space theme if switching to it
            setupSpaceTheme();
        };
        
        // Setup space theme on page load if active
        setTimeout(() => {
            setupSpaceTheme();
        }, 100);
        
        // Handle window resize for space stars
        window.addEventListener('resize', () => {
            if (document.body.classList.contains('theme-space')) {
                // Update star positions based on new window size
                spaceStars.forEach(star => {
                    const x = parseFloat(star.style.left) || 0;
                    const y = parseFloat(star.style.top) || 0;
                    star.dataset.x = x;
                    star.dataset.y = y;
                });
            }
        });
        
        // Function to spawn more stars (for "stars" command)
        function spawnMoreStars(count = 50) {
            if (!document.body.classList.contains('theme-space')) {
                showCommandFeedback('stars', 'Stars command only works in space theme', false);
                return;
            }
            
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'space-star';
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                star.style.width = (Math.random() * 2 + 1) + 'px';
                star.style.height = star.style.width;
                star.dataset.x = x;
                star.dataset.y = y;
                document.body.appendChild(star);
                spaceStars.push(star);
            }
            
            showCommandFeedback('stars', `Spawned ${count} more stars!`, true);
        }
        
        // Ocean theme - animated fish
        let oceanFish = [];
        
        function createOceanFish() {
            // Remove existing fish
            cleanupOceanFish();
            
            if (!document.body.classList.contains('theme-ocean')) return;
            
            // Create fish
            const fishEmojis = ['', '', '', ''];
            const fishCount = 5;
            
            for (let i = 0; i < fishCount; i++) {
                const fish = document.createElement('div');
                fish.className = 'ocean-fish';
                const size = ['small', 'medium', 'large'][Math.floor(Math.random() * 3)];
                fish.classList.add(size);
                fish.textContent = fishEmojis[Math.floor(Math.random() * fishEmojis.length)];
                fish.style.top = (Math.random() * 80 + 10) + '%'; // Random vertical position
                fish.style.animationDelay = (Math.random() * 5) + 's'; // Stagger animations
                document.body.appendChild(fish);
                oceanFish.push(fish);
            }
        }
        
        function cleanupOceanFish() {
            oceanFish.forEach(fish => fish.remove());
            oceanFish = [];
        }
        
        function setupOceanTheme() {
            if (document.body.classList.contains('theme-ocean')) {
                createOceanFish();
            } else {
                cleanupOceanFish();
            }
        }
        
        // Paper theme - drawing functionality
        let paperCanvas = null;
        let paperCtx = null;
        let isPaperDrawing = false;
        let lastPaperX = 0;
        let lastPaperY = 0;
        let paperColor = '#000000';
        let paperBrushSize = 3;
        
        function initPaperDrawing() {
            // Check if canvas already exists
            if (document.getElementById('paper-drawing-canvas')) {
                paperCanvas = document.getElementById('paper-drawing-canvas');
                paperCtx = paperCanvas.getContext('2d');
                return;
            }
            
            if (!document.body.classList.contains('theme-paper')) return;
            
            // Create canvas for drawing
            paperCanvas = document.createElement('canvas');
            paperCanvas.id = 'paper-drawing-canvas';
            paperCanvas.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: 5; background: transparent;';
            paperCanvas.width = window.innerWidth;
            paperCanvas.height = window.innerHeight;
            paperCtx = paperCanvas.getContext('2d');
            paperCtx.strokeStyle = paperColor;
            paperCtx.lineWidth = paperBrushSize;
            paperCtx.lineCap = 'round';
            paperCtx.lineJoin = 'round';
            document.body.appendChild(paperCanvas);
            
            // Drawing events
            paperCanvas.addEventListener('mousedown', handlePaperMouseDown);
            paperCanvas.addEventListener('mousemove', handlePaperMouseMove);
            paperCanvas.addEventListener('mouseup', handlePaperMouseUp);
            paperCanvas.addEventListener('mouseleave', handlePaperMouseUp);
            paperCanvas.addEventListener('touchstart', handlePaperTouchStart, { passive: false });
            paperCanvas.addEventListener('touchmove', handlePaperTouchMove, { passive: false });
            paperCanvas.addEventListener('touchend', handlePaperTouchEnd);
        }
        
        function handlePaperMouseDown(e) {
            isPaperDrawing = true;
            const rect = paperCanvas.getBoundingClientRect();
            lastPaperX = e.clientX - rect.left;
            lastPaperY = e.clientY - rect.top;
            drawPaperPoint(lastPaperX, lastPaperY);
        }
        
        function handlePaperMouseMove(e) {
            if (!isPaperDrawing) return;
            const rect = paperCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawPaperLine(lastPaperX, lastPaperY, x, y);
            lastPaperX = x;
            lastPaperY = y;
        }
        
        function handlePaperMouseUp() {
            isPaperDrawing = false;
        }
        
        function handlePaperTouchStart(e) {
            e.preventDefault();
            isPaperDrawing = true;
            const touch = e.touches[0];
            const rect = paperCanvas.getBoundingClientRect();
            lastPaperX = touch.clientX - rect.left;
            lastPaperY = touch.clientY - rect.top;
            drawPaperPoint(lastPaperX, lastPaperY);
        }
        
        function handlePaperTouchMove(e) {
            e.preventDefault();
            if (!isPaperDrawing) return;
            const touch = e.touches[0];
            const rect = paperCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawPaperLine(lastPaperX, lastPaperY, x, y);
            lastPaperX = x;
            lastPaperY = y;
        }
        
        function handlePaperTouchEnd(e) {
            e.preventDefault();
            isPaperDrawing = false;
        }
        
        function drawPaperPoint(x, y) {
            if (!paperCtx) return;
            paperCtx.fillStyle = paperColor;
            paperCtx.beginPath();
            paperCtx.arc(x, y, paperBrushSize / 2, 0, Math.PI * 2);
            paperCtx.fill();
        }
        
        function drawPaperLine(x1, y1, x2, y2) {
            if (!paperCtx) return;
            paperCtx.strokeStyle = paperColor;
            paperCtx.lineWidth = paperBrushSize;
            paperCtx.beginPath();
            paperCtx.moveTo(x1, y1);
            paperCtx.lineTo(x2, y2);
            paperCtx.stroke();
        }
        
        function cleanupPaperDrawing() {
            if (paperCanvas) {
                paperCanvas.remove();
                paperCanvas = null;
                paperCtx = null;
            }
        }
        
        function setupPaperTheme() {
            if (document.body.classList.contains('theme-paper')) {
                setTimeout(() => {
                    initPaperDrawing();
                }, 100);
            } else {
                cleanupPaperDrawing();
            }
        }
        
        // Clouds theme - animated clouds
        let cloudElements = [];
        let cloudInterval = null;
        
        function createCloud() {
            if (!document.body.classList.contains('theme-clouds')) return;
            
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            const size = 60 + Math.random() * 80; // Random size between 60-140px
            cloud.style.width = size + 'px';
            cloud.style.height = size * 0.6 + 'px';
            cloud.style.top = (Math.random() * 60 + 10) + '%'; // Random vertical position
            cloud.style.left = '-200px';
            cloud.style.animationDuration = (15 + Math.random() * 10) + 's'; // Random speed
            cloud.style.animationDelay = (Math.random() * 5) + 's';
            document.body.appendChild(cloud);
            cloudElements.push(cloud);
            
            // Remove cloud after animation
            setTimeout(() => {
                if (cloud.parentNode) {
                    cloud.remove();
                    cloudElements = cloudElements.filter(c => c !== cloud);
                }
            }, 30000);
        }
        
        function cleanupClouds() {
            cloudElements.forEach(cloud => cloud.remove());
            cloudElements = [];
            if (cloudInterval) {
                clearInterval(cloudInterval);
                cloudInterval = null;
            }
        }
        
        function setupCloudsTheme() {
            if (document.body.classList.contains('theme-clouds')) {
                // Create initial clouds
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => createCloud(), i * 2000);
                }
                // Create new clouds periodically
                cloudInterval = setInterval(() => {
                    if (cloudElements.length < 8) {
                        createCloud();
                    }
                }, 5000);
            } else {
                cleanupClouds();
            }
        }
        
        // Flashcard theme - interactive flashcards
        let flashcards = [];
        let flashcardCounter = 0;
        
        function saveFlashcards() {
            const flashcardData = flashcards.map(flashcard => {
                const header = flashcard.querySelector('.flashcard-header');
                const content = flashcard.querySelector('.flashcard-content');
                return {
                    id: flashcard.id,
                    x: parseInt(flashcard.style.left) || 0,
                    y: parseInt(flashcard.style.top) || 0,
                    headerText: header ? header.textContent : '',
                    contentText: content ? (content.textContent === 'Click to write...' ? '' : content.textContent) : ''
                };
            });
            localStorage.setItem('flashcards', JSON.stringify(flashcardData));
            localStorage.setItem('flashcardCounter', flashcardCounter.toString());
        }
        
        function loadFlashcards() {
            const savedFlashcards = localStorage.getItem('flashcards');
            const savedCounter = localStorage.getItem('flashcardCounter');
            
            if (savedCounter) {
                flashcardCounter = parseInt(savedCounter) || 0;
            }
            
            if (savedFlashcards) {
                try {
                    const flashcardData = JSON.parse(savedFlashcards);
                    flashcardData.forEach(data => {
                        createFlashcard(data.x, data.y, data.id, data.headerText, data.contentText);
                    });
                } catch (e) {
                    console.error('Error loading flashcards:', e);
                }
            }
        }
        
        function createFlashcard(x = null, y = null, id = null, headerText = null, contentText = null) {
            if (!document.body.classList.contains('theme-flashcard')) {
                showCommandFeedback('flashcard', 'Flashcards only work in flashcard theme', false);
                return;
            }
            
            const flashcard = document.createElement('div');
            flashcard.className = 'flashcard';
            
            if (id) {
                flashcard.id = id;
                const idNum = parseInt(id.replace('flashcard-', ''));
                if (idNum > flashcardCounter) {
                    flashcardCounter = idNum;
                }
            } else {
                flashcardCounter++;
                flashcard.id = `flashcard-${flashcardCounter}`;
            }
            
            // Position
            if (x === null || y === null) {
                x = window.innerWidth / 2 - 150;
                y = window.innerHeight / 2 - 100;
            }
            flashcard.style.left = x + 'px';
            flashcard.style.top = y + 'px';
            
            // Header
            const header = document.createElement('div');
            header.className = 'flashcard-header';
            header.textContent = headerText || `Flashcard ${flashcardCounter}`;
            header.contentEditable = true;
            
            // Save on header edit
            header.addEventListener('input', () => {
                saveFlashcards();
            });
            header.addEventListener('blur', () => {
                saveFlashcards();
            });
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'flashcard-close';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                flashcard.remove();
                flashcards = flashcards.filter(f => f !== flashcard);
                saveFlashcards();
            };
            
            // Content area
            const content = document.createElement('div');
            content.className = 'flashcard-content';
            content.contentEditable = true;
            if (contentText !== null && contentText !== '') {
                content.textContent = contentText;
            } else {
                content.textContent = 'Click to write...';
            }
            content.onfocus = function() {
                if (this.textContent === 'Click to write...') {
                    this.textContent = '';
                }
            };
            content.onblur = function() {
                if (this.textContent.trim() === '') {
                    this.textContent = 'Click to write...';
                }
                saveFlashcards();
            };
            
            // Save on content edit
            content.addEventListener('input', () => {
                saveFlashcards();
            });
            
            flashcard.appendChild(closeBtn);
            flashcard.appendChild(header);
            flashcard.appendChild(content);
            document.body.appendChild(flashcard);
            flashcards.push(flashcard);
            
            // Make draggable
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            
            header.addEventListener('mousedown', (e) => {
                if (e.target === header || e.target === closeBtn) {
                    isDragging = true;
                    flashcard.classList.add('dragging');
                    initialX = e.clientX - flashcard.offsetLeft;
                    initialY = e.clientY - flashcard.offsetTop;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    // Keep within bounds
                    currentX = Math.max(0, Math.min(window.innerWidth - flashcard.offsetWidth, currentX));
                    currentY = Math.max(0, Math.min(window.innerHeight - flashcard.offsetHeight, currentY));
                    
                    flashcard.style.left = currentX + 'px';
                    flashcard.style.top = currentY + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    flashcard.classList.remove('dragging');
                    saveFlashcards(); // Save position after dragging
                }
            });
            
            if (!id) {
                saveFlashcards();
                showCommandFeedback('flashcard', `Created flashcard ${flashcardCounter}`, true);
            }
        }
        
        function cleanupFlashcards() {
            flashcards.forEach(flashcard => flashcard.remove());
            flashcards = [];
            // Don't reset counter, keep it for continuity
        }
        
        function setupFlashcardTheme() {
            if (document.body.classList.contains('theme-flashcard')) {
                // Load saved flashcards
                setTimeout(() => {
                    loadFlashcards();
                    // If no saved flashcards, create a default one
                    if (flashcards.length === 0) {
                        createFlashcard();
                    }
                }, 100);
            } else {
                cleanupFlashcards();
            }
        }
        
        // Make createFlashcard globally accessible
        window.createFlashcard = createFlashcard;
        
        // Remote Desktop System
        let desktopIcons = [];
        let desktopWindows = [];
        let selectedIcon = null;
        let iconCounter = 0;
        let windowZIndex = 100;
        
        function saveDesktopState() {
            const state = {
                icons: desktopIcons.map(icon => ({
                    type: icon.type,
                    name: icon.name,
                    x: icon.x,
                    y: icon.y,
                    id: icon.id
                })),
                iconCounter: iconCounter
            };
            localStorage.setItem('desktopState', JSON.stringify(state));
        }
        
        function loadDesktopState() {
            const saved = localStorage.getItem('desktopState');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    if (state.icons && state.icons.length > 0) {
                        // Restore icon counter
                        iconCounter = state.iconCounter || 0;
                        
                        // Restore icons
                        state.icons.forEach(iconData => {
                            addDesktopIcon(iconData.type, iconData.name, iconData.x, iconData.y, iconData.id);
                        });
                        return true; // State loaded
                    }
                } catch (e) {
                    console.error('Error loading desktop state:', e);
                }
            }
            return false; // No state to load
        }
        
        function initRemoteDesktop() {
            const desktop = document.getElementById('remoteDesktop');
            const iconsContainer = document.getElementById('desktopIcons');
            
            if (!desktop || !iconsContainer) return;
            
            // Hide command bar when on desktop
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) {
                commandBar.style.display = 'none';
            }
            
            // Load saved desktop state, or add default icons
            const stateLoaded = loadDesktopState();
            if (!stateLoaded) {
                // Add default icons only if no saved state
                addDesktopIcon('paper', 'Paper', 10, 10);
                addDesktopIcon('paint', 'Paint', 10, 100);
                addDesktopIcon('computer', 'Computer', 10, 190);
                addDesktopIcon('appstore', 'App Store', 10, 280);
                saveDesktopState();
            }
            
            // Desktop right-click
            desktop.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.desktop-icon') || e.target.closest('.win95-window')) {
                    return; // Don't show menu on icons or windows
                }
                e.preventDefault();
                showDesktopContextMenu(e.clientX, e.clientY);
            });
            
            // Click to close context menus
            desktop.addEventListener('click', () => {
                hideContextMenus();
            });
            
            // Trash can drag and drop
            const trashCan = document.getElementById('trashCan');
            if (trashCan) {
                trashCan.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    trashCan.classList.add('trash-can-drag-over');
                });
                
                trashCan.addEventListener('dragleave', () => {
                    trashCan.classList.remove('trash-can-drag-over');
                });
                
                trashCan.addEventListener('drop', (e) => {
                    e.preventDefault();
                    trashCan.classList.remove('trash-can-drag-over');
                    const iconId = e.dataTransfer.getData('text/plain');
                    deleteDesktopIconById(iconId);
                });
            }
        }
        
        function addDesktopIcon(type, name, x, y) {
            iconCounter++;
            const iconId = `icon-${iconCounter}`;
            const iconsContainer = document.getElementById('desktopIcons');
            if (!iconsContainer) return;
            
            const icon = document.createElement('div');
            icon.className = 'desktop-icon';
            icon.id = iconId;
            icon.style.position = 'absolute';
            icon.style.left = x + 'px';
            icon.style.top = y + 'px';
            icon.draggable = true;
            
            // Icon image
            const iconImg = document.createElement('div');
            iconImg.className = 'desktop-icon-icon';
            if (type === 'paper') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'paint') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'computer') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'appstore') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'minesweeper') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'pong') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'sandboxles') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'snake') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'blockbreaker') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            } else if (type === 'chatbot') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'></text></svg>") no-repeat center';
            }
            iconImg.style.backgroundSize = 'contain';
            
            // Icon label
            const label = document.createElement('div');
            label.className = 'desktop-icon-label';
            label.textContent = name;
            label.contentEditable = false;
            
            icon.appendChild(iconImg);
            icon.appendChild(label);
            
            // Right-click menu
            icon.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectedIcon = iconId;
                if (type === 'computer') {
                    showComputerContextMenu(e.clientX, e.clientY);
                } else {
                    showIconContextMenu(e.clientX, e.clientY);
                }
            });
            
            // Click to select
            let clickTimer = null;
            icon.addEventListener('click', (e) => {
                if (e.detail === 1) { // Single click
                    clickTimer = setTimeout(() => {
                        selectIcon(iconId);
                    }, 200); // Delay to detect double-click
                }
            });
            
            // Double-click to open (clear single click timer)
            icon.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                }
                // Actually open the app
                if (type === 'appstore') {
                    openAppStore();
                } else if (type === 'pong') {
                    openPongApp(iconId, name);
                } else if (type === 'sandboxles') {
                    openSandboxlesApp(iconId, name);
                } else if (type === 'snake') {
                    openSnakeApp(iconId, name);
                } else if (type === 'blockbreaker') {
                    openBlockBreakerApp(iconId, name);
                } else if (type === 'chatbot') {
                    openChatbotApp(iconId, name);
                } else if (type !== 'computer') {
                    openDesktopApp(type, iconId, name);
                }
            });
            
            // Drag and drop - allow dragging to reposition or to trash
            let isDraggingIcon = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragStartTime = 0;
            
            icon.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragStartTime = Date.now();
                    isDraggingIcon = false; // Will be set to true if mouse moves
                }
            });
            
            icon.addEventListener('mousemove', (e) => {
                if (dragStartTime > 0) {
                    const moveDistance = Math.abs(e.clientX - dragStartX) + Math.abs(e.clientY - dragStartY);
                    if (moveDistance > 5) { // Start dragging after 5px movement
                        isDraggingIcon = true;
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                    }
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDraggingIcon && icon.parentNode) {
                    const iconsContainer = document.getElementById('desktopIcons');
                    if (iconsContainer) {
                        const containerRect = iconsContainer.getBoundingClientRect();
                        const iconRect = icon.getBoundingClientRect();
                        const newX = e.clientX - containerRect.left - (iconRect.width / 2);
                        const newY = e.clientY - containerRect.top - (iconRect.height / 2);
                        
                        // Keep within bounds
                        const maxX = iconsContainer.offsetWidth - icon.offsetWidth;
                        const maxY = iconsContainer.offsetHeight - icon.offsetHeight;
                        
                        icon.style.left = Math.max(0, Math.min(maxX, newX)) + 'px';
                        icon.style.top = Math.max(0, Math.min(maxY, newY)) + 'px';
                        
                        // Update stored position
                        const iconData = desktopIcons.find(i => i.id === iconId);
                        if (iconData) {
                            iconData.x = parseFloat(icon.style.left);
                            iconData.y = parseFloat(icon.style.top);
                            saveDesktopState(); // Save after moving
                        }
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDraggingIcon = false;
                dragStartTime = 0;
            });
            
            // Also support HTML5 drag for trash can
            icon.draggable = true;
            icon.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', iconId);
                icon.style.opacity = '0.5';
            });
            
            icon.addEventListener('dragend', () => {
                icon.style.opacity = '1';
            });
            
            iconsContainer.appendChild(icon);
            
            desktopIcons.push({
                id: iconId,
                type: type,
                name: name,
                element: icon,
                x: x,
                y: y
            });
            
            // Save desktop state after adding icon
            saveDesktopState();
            
            // Save desktop state after adding icon
            saveDesktopState();
        }
        
        function selectIcon(iconId) {
            // Deselect all
            desktopIcons.forEach(icon => {
                icon.element.classList.remove('selected');
            });
            
            // Select this one
            const icon = desktopIcons.find(i => i.id === iconId);
            if (icon) {
                icon.element.classList.add('selected');
                selectedIcon = iconId;
            }
        }
        
        function showDesktopContextMenu(x, y) {
            const menu = document.getElementById('desktopContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function showIconContextMenu(x, y) {
            const menu = document.getElementById('iconContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function hideContextMenus() {
            const desktopMenu = document.getElementById('desktopContextMenu');
            const iconMenu = document.getElementById('iconContextMenu');
            const computerMenu = document.getElementById('computerContextMenu');
            if (desktopMenu) desktopMenu.classList.add('hidden');
            if (iconMenu) iconMenu.classList.add('hidden');
            if (computerMenu) computerMenu.classList.add('hidden');
        }
        
        function showComputerContextMenu(x, y) {
            const menu = document.getElementById('computerContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function powerOffDesktop() {
            hideContextMenus();
            showPage('mainPage');
        }
        
        function openSelectedIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            const icon = desktopIcons.find(i => i.id === selectedIcon);
            if (icon && icon.type !== 'computer') {
                openDesktopApp(icon.type, icon.id, icon.name);
            }
        }
        
        // App Store
        function openAppStore() {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '500px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = 'App Store';
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                window.remove();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '20px';
            content.style.overflow = 'auto';
            
            // App Store content
            const storeContent = document.createElement('div');
            storeContent.innerHTML = `
                <h2 style="font-size: 16px; margin-bottom: 15px; font-weight: bold;">Available Apps</h2>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Minesweeper</div>
                            <div style="font-size: 11px; color: #666;">Classic minesweeper game</div>
                        </div>
                        <button id="install-minesweeper" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Pong</div>
                            <div style="font-size: 11px; color: #666;">Classic Pong game</div>
                        </div>
                        <button id="install-pong" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Sandboxles</div>
                            <div style="font-size: 11px; color: #666;">Interactive sandbox playground</div>
                        </div>
                        <button id="install-sandboxles" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Snake</div>
                            <div style="font-size: 11px; color: #666;">Classic snake game - 16x16 grid with 3 red apples</div>
                        </div>
                        <button id="install-snake" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Block Breaker</div>
                            <div style="font-size: 11px; color: #666;">Classic brick breaker game - break all the blocks!</div>
                        </div>
                        <button id="install-blockbreaker" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Chatbot</div>
                            <div style="font-size: 11px; color: #666;">AI chatbot assistant</div>
                        </div>
                        <button id="install-chatbot" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
            `;
            
            content.appendChild(storeContent);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            // Install buttons
            setTimeout(() => {
                const installMinesweeperBtn = document.getElementById('install-minesweeper');
                if (installMinesweeperBtn) {
                    installMinesweeperBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'minesweeper');
                        if (alreadyInstalled) {
                            alert('Minesweeper is already installed!');
                            return;
                        }
                        
                        // Add Minesweeper icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('minesweeper', 'Minesweeper', x, y);
                        alert('Minesweeper installed successfully!');
                    };
                }
                
                const installPongBtn = document.getElementById('install-pong');
                if (installPongBtn) {
                    installPongBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'pong');
                        if (alreadyInstalled) {
                            alert('Pong is already installed!');
                            return;
                        }
                        
                        // Add Pong icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('pong', 'Pong', x, y);
                        alert('Pong installed successfully!');
                    };
                }
                
                const installSandboxlesBtn = document.getElementById('install-sandboxles');
                if (installSandboxlesBtn) {
                    installSandboxlesBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'sandboxles');
                        if (alreadyInstalled) {
                            alert('Sandboxles is already installed!');
                            return;
                        }
                        
                        // Add Sandboxles icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('sandboxles', 'Sandboxles', x, y);
                        alert('Sandboxles installed successfully!');
                    };
                }
                
                const installSnakeBtn = document.getElementById('install-snake');
                if (installSnakeBtn) {
                    installSnakeBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'snake');
                        if (alreadyInstalled) {
                            alert('Snake is already installed!');
                            return;
                        }
                        
                        // Add Snake icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('snake', 'Snake', x, y);
                        alert('Snake installed successfully!');
                    };
                }
                
                const installBlockBreakerBtn = document.getElementById('install-blockbreaker');
                if (installBlockBreakerBtn) {
                    installBlockBreakerBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'blockbreaker');
                        if (alreadyInstalled) {
                            alert('Block Breaker is already installed!');
                            return;
                        }
                        
                        // Add Block Breaker icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('blockbreaker', 'Block Breaker', x, y);
                        alert('Block Breaker installed successfully!');
                    };
                }
                
                const installChatbotBtn = document.getElementById('install-chatbot');
                if (installChatbotBtn) {
                    installChatbotBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'chatbot');
                        if (alreadyInstalled) {
                            alert('Chatbot is already installed!');
                            return;
                        }
                        
                        // Add Chatbot icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('chatbot', 'Chatbot', x, y);
                        alert('Chatbot installed successfully!');
                    };
                }
            }, 100);
        }
        
        // Minesweeper app
        function openMinesweeperApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '450px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            
            // Create simple minesweeper game
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="minesweeper-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 10px;">Mines: <span id="mines-count">10</span></div>
                </div>
                <div id="minesweeper-grid" style="display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; max-width: 360px; margin: 0 auto;"></div>
            `;
            content.innerHTML = gameHTML;
            
            // Initialize minesweeper
            const gridEl = content.querySelector('#minesweeper-grid');
            const restartBtn = content.querySelector('#minesweeper-restart');
            const minesCountEl = content.querySelector('#mines-count');
            
            let minesweeperBoard = [];
            let revealed = [];
            let flagged = [];
            let gameOver = false;
            const GRID_SIZE = 10;
            const NUM_MINES = 10;
            
            function createMinesweeperBoard() {
                minesweeperBoard = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                revealed = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
                flagged = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
                gameOver = false;
                
                // Place mines
                let minesPlaced = 0;
                while (minesPlaced < NUM_MINES) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    if (minesweeperBoard[row][col] !== -1) {
                        minesweeperBoard[row][col] = -1;
                        minesPlaced++;
                    }
                }
                
                // Calculate numbers
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (minesweeperBoard[row][col] !== -1) {
                            let count = 0;
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    const nr = row + dr;
                                    const nc = col + dc;
                                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                                        if (minesweeperBoard[nr][nc] === -1) count++;
                                    }
                                }
                            }
                            minesweeperBoard[row][col] = count;
                        }
                    }
                }
                
                renderMinesweeper();
            }
            
            function renderMinesweeper() {
                gridEl.innerHTML = '';
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = document.createElement('button');
                        cell.style.cssText = 'width: 30px; height: 30px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 12px; cursor: pointer; font-weight: bold;';
                        
                        if (revealed[row][col]) {
                            cell.style.background = '#d4d0c8';
                            cell.style.border = '1px inset #c0c0c0';
                            if (minesweeperBoard[row][col] === -1) {
                                cell.textContent = '';
                                cell.style.background = '#ff0000';
                            } else if (minesweeperBoard[row][col] > 0) {
                                cell.textContent = minesweeperBoard[row][col];
                                const colors = ['', '#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000000', '#808080'];
                                cell.style.color = colors[minesweeperBoard[row][col]] || '#000000';
                            }
                        } else if (flagged[row][col]) {
                            cell.textContent = '';
                        }
                        
                        cell.onclick = () => {
                            if (gameOver || flagged[row][col]) return;
                            revealCell(row, col);
                        };
                        
                        cell.oncontextmenu = (e) => {
                            e.preventDefault();
                            if (gameOver || revealed[row][col]) return;
                            flagged[row][col] = !flagged[row][col];
                            renderMinesweeper();
                            updateMinesCount();
                        };
                        
                        gridEl.appendChild(cell);
                    }
                }
            }
            
            function revealCell(row, col) {
                if (revealed[row][col] || flagged[row][col] || gameOver) return;
                
                revealed[row][col] = true;
                
                if (minesweeperBoard[row][col] === -1) {
                    gameOver = true;
                    alert('Game Over!');
                    renderMinesweeper();
                    return;
                }
                
                if (minesweeperBoard[row][col] === 0) {
                    // Reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr;
                            const nc = col + dc;
                            if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && !revealed[nr][nc]) {
                                revealCell(nr, nc);
                            }
                        }
                    }
                }
                
                renderMinesweeper();
                checkWin();
            }
            
            function checkWin() {
                let revealedCount = 0;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (revealed[row][col]) revealedCount++;
                    }
                }
                if (revealedCount === GRID_SIZE * GRID_SIZE - NUM_MINES) {
                    gameOver = true;
                    alert('You Win!');
                }
            }
            
            function updateMinesCount() {
                let flagCount = 0;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (flagged[row][col]) flagCount++;
                    }
                }
                minesCountEl.textContent = NUM_MINES - flagCount;
            }
            
            restartBtn.onclick = createMinesweeperBoard;
            createMinesweeperBoard();
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'minesweeper',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Make functions globally accessible
        window.powerOffDesktop = powerOffDesktop;
        window.openSelectedIcon = openSelectedIcon;
        window.openAppStore = openAppStore;
        
        function addDesktopApp(type) {
            hideContextMenus();
            const x = Math.random() * 200 + 50;
            const y = Math.random() * 200 + 50;
            const name = type === 'paper' ? `Paper ${iconCounter + 1}` : `Paint ${iconCounter + 1}`;
            addDesktopIcon(type, name, x, y);
        }
        
        function renameDesktopIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            
            const icon = desktopIcons.find(i => i.id === selectedIcon);
            if (!icon) return;
            
            const label = icon.element.querySelector('.desktop-icon-label');
            if (label) {
                const oldName = label.textContent;
                label.contentEditable = true;
                label.focus();
                
                const range = document.createRange();
                range.selectNodeContents(label);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                
                label.addEventListener('blur', function onBlur() {
                    label.contentEditable = false;
                    const newName = label.textContent.trim() || oldName;
                    label.textContent = newName;
                    icon.name = newName;
                    label.removeEventListener('blur', onBlur);
                    saveDesktopState(); // Save after renaming
                });
                
                label.addEventListener('keydown', function onKeyDown(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        label.blur();
                    }
                    if (e.key === 'Escape') {
                        label.textContent = oldName;
                        label.blur();
                    }
                });
            }
        }
        
        function deleteDesktopIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            deleteDesktopIconById(selectedIcon);
        }
        
        function deleteDesktopIconById(iconId) {
            const icon = desktopIcons.find(i => i.id === iconId);
            if (icon) {
                icon.element.remove();
                desktopIcons = desktopIcons.filter(i => i.id !== iconId);
                selectedIcon = null;
            }
        }
        
        function openDesktopApp(type, iconId, name) {
            if (type === 'minesweeper') {
                openMinesweeperApp(iconId, name);
                return;
            }
            if (type === 'snake') {
                openSnakeApp(iconId, name);
                return;
            }
            if (type === 'blockbreaker') {
                openBlockBreakerApp(iconId, name);
                return;
            }
            if (type === 'chatbot') {
                openChatbotApp(iconId, name);
                return;
            }
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const minimizeBtn = document.createElement('button');
            minimizeBtn.className = 'win95-window-button';
            minimizeBtn.textContent = '_';
            minimizeBtn.onclick = () => {
                window.classList.toggle('minimized');
                updateTaskbar();
            };
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            
            // Set up close button to save before closing
            closeBtn.onclick = () => {
                // Save paint/paper before closing
                if (type === 'paint') {
                    const canvas = content.querySelector('canvas');
                    if (canvas) {
                        try {
                            const dataURL = canvas.toDataURL('image/png');
                            localStorage.setItem(`paint-${iconId}`, dataURL);
                        } catch (e) {
                            console.error('Error saving paint on close:', e);
                        }
                    }
                } else if (type === 'paper') {
                    const paperContent = content.querySelector('.paper-app-content');
                    if (paperContent && paperContent.textContent !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, paperContent.textContent);
                        const savedColor = paperContent.style.color || '#000000';
                        const savedFont = paperContent.style.fontFamily || 'Courier New, monospace';
                        localStorage.setItem(`paper-color-${iconId}`, savedColor);
                        localStorage.setItem(`paper-font-${iconId}`, savedFont);
                    }
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(minimizeBtn);
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            if (type === 'paper') {
                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.className = 'paint-app-toolbar';
                toolbar.style.marginBottom = '0';
                
                // Color picker
                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Color: ';
                colorLabel.style.fontSize = '11px';
                colorLabel.style.marginRight = '5px';
                
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'paint-app-color-picker';
                colorPicker.value = '#000000';
                colorPicker.style.marginRight = '10px';
                
                // Font selector
                const fontLabel = document.createElement('label');
                fontLabel.textContent = 'Font: ';
                fontLabel.style.fontSize = '11px';
                fontLabel.style.marginRight = '5px';
                
                const fontSelector = document.createElement('select');
                fontSelector.style.cssText = 'background: #c0c0c0; border: 1px inset #c0c0c0; padding: 2px 4px; font-size: 11px; margin-right: 10px;';
                fontSelector.innerHTML = `
                    <option value="Arial">Arial</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Impact">Impact</option>
                    <option value="Trebuchet MS">Trebuchet MS</option>
                `;
                
                toolbar.appendChild(colorLabel);
                toolbar.appendChild(colorPicker);
                toolbar.appendChild(fontLabel);
                toolbar.appendChild(fontSelector);
                
                const paperContent = document.createElement('div');
                paperContent.className = 'paper-app-content';
                paperContent.setAttribute('contenteditable', 'true');
                paperContent.style.outline = 'none';
                paperContent.style.minHeight = 'calc(100% - 30px)';
                paperContent.style.color = '#000000'; // Default black text
                paperContent.style.fontFamily = 'Courier New, monospace';
                paperContent.textContent = 'Start typing...';
                
                // Load saved content and preferences
                const savedContent = localStorage.getItem(`paper-${iconId}`);
                const savedColor = localStorage.getItem(`paper-color-${iconId}`) || '#000000';
                const savedFont = localStorage.getItem(`paper-font-${iconId}`) || 'Courier New';
                
                if (savedContent) {
                    paperContent.textContent = savedContent;
                }
                paperContent.style.color = savedColor;
                paperContent.style.fontFamily = savedFont;
                colorPicker.value = savedColor;
                fontSelector.value = savedFont;
                
                // Update color
                colorPicker.addEventListener('input', (e) => {
                    paperContent.style.color = e.target.value;
                    localStorage.setItem(`paper-color-${iconId}`, e.target.value);
                });
                
                // Update font
                fontSelector.addEventListener('change', (e) => {
                    paperContent.style.fontFamily = e.target.value;
                    localStorage.setItem(`paper-font-${iconId}`, e.target.value);
                });
                
                paperContent.onfocus = function() {
                    if (this.textContent === 'Start typing...') {
                        this.textContent = '';
                    }
                };
                
                paperContent.onblur = function() {
                    // Save content
                    if (this.textContent.trim() !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, this.textContent);
                    }
                    if (this.textContent.trim() === '') {
                        this.textContent = 'Start typing...';
                    }
                };
                
                // Auto-save on input
                paperContent.addEventListener('input', function() {
                    if (this.textContent !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, this.textContent);
                    }
                });
                
                content.appendChild(toolbar);
                content.appendChild(paperContent);
            } else if (type === 'paint') {
                const paintId = `paint-${iconId}`;
                const toolbar = document.createElement('div');
                toolbar.className = 'paint-app-toolbar';
                
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'paint-app-color-picker';
                colorPicker.value = '#000000';
                
                const brushSize = document.createElement('input');
                brushSize.type = 'range';
                brushSize.className = 'paint-app-brush-size';
                brushSize.min = '1';
                brushSize.max = '50';
                brushSize.value = '5';
                
                toolbar.appendChild(colorPicker);
                toolbar.appendChild(brushSize);
                
                const canvas = document.createElement('canvas');
                canvas.className = 'paint-app-canvas';
                canvas.id = paintId;
                canvas.width = 580;
                canvas.height = 340;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Load saved drawing if exists - use setTimeout to ensure canvas is ready
                setTimeout(() => {
                    const savedDrawing = localStorage.getItem(`paint-${iconId}`);
                    if (savedDrawing && savedDrawing.startsWith('data:image')) {
                        const img = new Image();
                        img.onload = () => {
                            // Clear and redraw white background first
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            // Then draw the saved image
                            ctx.drawImage(img, 0, 0);
                        };
                        img.onerror = () => {
                            // If image fails to load, keep white background
                            console.log('Failed to load saved paint drawing for', iconId);
                        };
                        img.src = savedDrawing;
                    } else {
                        // No saved drawing, ensure white background
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }, 100);
                
                let isDrawing = false;
                let lastX = 0;
                let lastY = 0;
                
                function savePaint() {
                    try {
                        const dataURL = canvas.toDataURL('image/png');
                        localStorage.setItem(`paint-${iconId}`, dataURL);
                    } catch (e) {
                        console.error('Error saving paint:', e);
                    }
                }
                
                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    lastX = e.clientX - rect.left;
                    lastY = e.clientY - rect.top;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    ctx.strokeStyle = colorPicker.value;
                    ctx.lineWidth = brushSize.value;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    lastX = x;
                    lastY = y;
                    
                    // Auto-save while drawing (debounced to avoid too frequent saves)
                    if (!savePaint.timeout) {
                        savePaint.timeout = setTimeout(() => {
                            savePaint();
                            savePaint.timeout = null;
                        }, 200); // Save every 200ms while drawing
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDrawing = false;
                    // Clear any pending save and save immediately
                    if (savePaint.timeout) {
                        clearTimeout(savePaint.timeout);
                        savePaint.timeout = null;
                    }
                    savePaint();
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDrawing = false;
                    // Clear any pending save and save immediately
                    if (savePaint.timeout) {
                        clearTimeout(savePaint.timeout);
                        savePaint.timeout = null;
                    }
                    savePaint();
                });
                
                // Make sure canvas is properly sized and visible
                canvas.style.display = 'block';
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                
                content.appendChild(toolbar);
                content.appendChild(canvas);
            }
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                initialX = e.clientX - window.offsetLeft;
                initialY = e.clientY - window.offsetTop;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    window.style.left = currentX + 'px';
                    window.style.top = currentY + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: type,
                element: window
            });
            
            updateTaskbar();
        }
        
        // Sandboxles app
        function openSandboxlesApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '700px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const minimizeBtn = document.createElement('button');
            minimizeBtn.className = 'win95-window-button';
            minimizeBtn.textContent = '_';
            minimizeBtn.onclick = () => {
                window.classList.toggle('minimized');
                updateTaskbar();
            };
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(minimizeBtn);
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content - sandbox playground
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            content.style.height = '100%';
            content.style.background = '#f0f0f0';
            
            // Create a simple interactive sandbox
            const sandboxDiv = document.createElement('div');
            sandboxDiv.style.cssText = 'width: 100%; height: 100%; min-height: 400px; background: #fff; border: 1px inset #c0c0c0; position: relative; overflow: hidden;';
            sandboxDiv.id = `sandbox-${iconId}`;
            
            // Add some interactive elements
            const info = document.createElement('div');
            info.style.cssText = 'padding: 10px; background: #e0e0e0; border-bottom: 1px inset #c0c0c0; font-size: 11px; margin-bottom: 5px;';
            info.innerHTML = '<strong>Sandbox Playground</strong><br>Click to create elements, drag to move them around! Double-click to remove.';
            
            // Make sandbox interactive - clicking creates colored boxes
            let elementCounter = 0;
            sandboxDiv.addEventListener('click', (e) => {
                if (e.target === sandboxDiv) {
                    const box = document.createElement('div');
                    box.style.cssText = `
                        position: absolute;
                        left: ${e.offsetX - 25}px;
                        top: ${e.offsetY - 25}px;
                        width: 50px;
                        height: 50px;
                        background: hsl(${Math.random() * 360}, 70%, 60%);
                        border: 2px outset #c0c0c0;
                        cursor: move;
                        user-select: none;
                    `;
                    box.textContent = ++elementCounter;
                    box.style.display = 'flex';
                    box.style.alignItems = 'center';
                    box.style.justifyContent = 'center';
                    box.style.fontSize = '20px';
                    box.style.fontWeight = 'bold';
                    box.style.color = '#000';
                    
                    // Make draggable
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    
                    box.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        const rect = box.getBoundingClientRect();
                        initialX = rect.left;
                        initialY = rect.top;
                        box.style.zIndex = '1000';
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        box.style.left = (initialX + dx) + 'px';
                        box.style.top = (initialY + dy) + 'px';
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            box.style.zIndex = '1';
                        }
                    });
                    
                    // Double-click to remove
                    box.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        box.remove();
                    });
                    
                    sandboxDiv.appendChild(box);
                }
            });
            
            content.appendChild(info);
            content.appendChild(sandboxDiv);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'sandboxles',
                element: window
            });
            
            updateTaskbar();
        }
        
        function updateTaskbar() {
            const taskbarApps = document.getElementById('taskbarApps');
            if (!taskbarApps) return;
            
            taskbarApps.innerHTML = '';
            desktopWindows.forEach((win, index) => {
                if (!win.element.classList.contains('minimized')) {
                    const btn = document.createElement('div');
                    btn.style.cssText = 'background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; margin: 2px; cursor: pointer; font-size: 11px; font-weight: bold; user-select: none;';
                    btn.textContent = win.name;
                    btn.onclick = () => {
                        win.element.style.zIndex = ++windowZIndex;
                        win.element.classList.remove('minimized');
                        updateTaskbar();
                    };
                    taskbarApps.appendChild(btn);
                }
            });
        }
        
        // Pong app
        function openPongApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content - embed pong iframe
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '0';
            content.style.overflow = 'hidden';
            content.style.height = '100%';
            
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.src = 'https://sethclydesdale.github.io/browser-pong/';
            
            content.appendChild(iframe);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'pong',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Snake app
        function openSnakeApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            
            // Game HTML
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="snake-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 10px;">Score: <span id="snake-score">0</span></div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 10px;">Use arrow keys to move</div>
                </div>
                <canvas id="snake-canvas" width="256" height="256" style="border: 2px inset #c0c0c0; background: #ffffff; display: block;"></canvas>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#snake-canvas');
            const ctx = canvas.getContext('2d');
            const restartBtn = content.querySelector('#snake-restart');
            const scoreEl = content.querySelector('#snake-score');
            
            // Game constants
            const GRID_SIZE = 16;
            const CELL_SIZE = 16;
            const NUM_APPLES = 3;
            
            // Game state
            let snake = [{x: 8, y: 8}];
            let direction = {x: 1, y: 0};
            let apples = [];
            let score = 0;
            let snakeGameInterval = null;
            let gameRunning = false;
            
            // Generate apples
            function generateApples() {
                apples = [];
                while (apples.length < NUM_APPLES) {
                    const x = Math.floor(Math.random() * GRID_SIZE);
                    const y = Math.floor(Math.random() * GRID_SIZE);
                    // Make sure apple doesn't spawn on snake
                    const onSnake = snake.some(segment => segment.x === x && segment.y === y);
                    const onExistingApple = apples.some(apple => apple.x === x && apple.y === y);
                    if (!onSnake && !onExistingApple) {
                        apples.push({x, y});
                    }
                }
            }
            
            // Draw game
            function draw() {
                // Clear canvas
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid lines
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE, 0);
                    ctx.lineTo(i * CELL_SIZE, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL_SIZE);
                    ctx.lineTo(canvas.width, i * CELL_SIZE);
                    ctx.stroke();
                }
                
                // Draw snake (black)
                ctx.fillStyle = '#000000';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * CELL_SIZE + 1, segment.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                });
                
                // Draw apples (red)
                ctx.fillStyle = '#ff0000';
                apples.forEach(apple => {
                    ctx.fillRect(apple.x * CELL_SIZE + 1, apple.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                });
            }
            
            // Game loop
            function gameLoop() {
                if (!gameRunning) return;
                
                // Move snake
                const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
                
                // Check wall collision
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    gameOver();
                    return;
                }
                
                // Check self collision
                if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameOver();
                    return;
                }
                
                snake.unshift(head);
                
                // Check apple collision
                let ateApple = false;
                for (let i = apples.length - 1; i >= 0; i--) {
                    if (head.x === apples[i].x && head.y === apples[i].y) {
                        apples.splice(i, 1);
                        score++;
                        scoreEl.textContent = score;
                        ateApple = true;
                    }
                }
                
                // If didn't eat apple, remove tail
                if (!ateApple) {
                    snake.pop();
                }
                
                // Regenerate apples if needed
                if (apples.length < NUM_APPLES) {
                    generateApples();
                }
                
                draw();
            }
            
            function startGame() {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                }
                
                // Reset game state
                snake = [{x: 8, y: 8}];
                direction = {x: 1, y: 0};
                score = 0;
                scoreEl.textContent = score;
                gameRunning = true;
                
                generateApples();
                draw();
                
                // Start game loop (update every 150ms)
                snakeGameInterval = setInterval(gameLoop, 150);
            }
            
            function gameOver() {
                gameRunning = false;
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                alert('Game Over! Score: ' + score);
                startGame();
            }
            
            // Keyboard controls
            const handleKeyPress = (e) => {
                if (!gameRunning) return;
                
                // Check if this window still exists and is visible
                if (!window.parentNode || !canvas.offsetParent) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (direction.y === 0) {
                            direction = {x: 0, y: -1};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowDown':
                        if (direction.y === 0) {
                            direction = {x: 0, y: 1};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowLeft':
                        if (direction.x === 0) {
                            direction = {x: -1, y: 0};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                        if (direction.x === 0) {
                            direction = {x: 1, y: 0};
                            e.preventDefault();
                        }
                        break;
                }
            };
            
            // Add keyboard listener
            document.addEventListener('keydown', handleKeyPress);
            closeBtn.onclick = () => {
                document.removeEventListener('keydown', handleKeyPress);
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            restartBtn.onclick = () => {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                }
                startGame();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'snake',
                element: window
            });
            
            updateTaskbar();
            
            // Start the game
            startGame();
        }
        
        // Block Breaker app
        function openBlockBreakerApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '450px';
            window.style.height = '550px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'hidden';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            
            // Game HTML
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="blockbreaker-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 5px;">Score: <span id="blockbreaker-score">0</span></div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 5px;">Lives: <span id="blockbreaker-lives">3</span></div>
                    <div style="font-size: 10px; color: #666;">Use mouse or arrow keys to move paddle</div>
                </div>
                <canvas id="blockbreaker-canvas" width="400" height="450" style="border: 2px inset #c0c0c0; background: #000; display: block;"></canvas>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#blockbreaker-canvas');
            const ctx = canvas.getContext('2d');
            const restartBtn = content.querySelector('#blockbreaker-restart');
            const scoreEl = content.querySelector('#blockbreaker-score');
            const livesEl = content.querySelector('#blockbreaker-lives');
            
            // Game constants
            const PADDLE_WIDTH = 80;
            const PADDLE_HEIGHT = 10;
            const BALL_RADIUS = 12;
            const BLOCK_ROWS = 5;
            const BLOCK_COLS = 8;
            const BLOCK_WIDTH = 45;
            const BLOCK_HEIGHT = 20;
            const BLOCK_PADDING = 5;
            const BLOCK_OFFSET_TOP = 30;
            const BLOCK_OFFSET_LEFT = 15;
            
            // Game state
            let paddleX = (canvas.width - PADDLE_WIDTH) / 2;
            let ballX = canvas.width / 2;
            let ballY = canvas.height - 50;
            let ballSpeedX = 2;
            let ballSpeedY = -2;
            let score = 0;
            let lives = 3;
            let blocks = [];
            let blockBreakerGameInterval = null;
            let gameRunning = false;
            
            // Create blocks
            function createBlocks() {
                blocks = [];
                const colors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff'];
                for (let row = 0; row < BLOCK_ROWS; row++) {
                    for (let col = 0; col < BLOCK_COLS; col++) {
                        blocks.push({
                            x: BLOCK_OFFSET_LEFT + col * (BLOCK_WIDTH + BLOCK_PADDING),
                            y: BLOCK_OFFSET_TOP + row * (BLOCK_HEIGHT + BLOCK_PADDING),
                            color: colors[row],
                            visible: true
                        });
                    }
                }
            }
            
            // Draw game
            function draw() {
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw blocks
                blocks.forEach(block => {
                    if (block.visible) {
                        ctx.fillStyle = block.color;
                        ctx.fillRect(block.x, block.y, BLOCK_WIDTH, BLOCK_HEIGHT);
                        ctx.strokeStyle = '#fff';
                        ctx.strokeRect(block.x, block.y, BLOCK_WIDTH, BLOCK_HEIGHT);
                    }
                });
                
                // Draw paddle
                ctx.fillStyle = '#fff';
                ctx.fillRect(paddleX, canvas.height - 30, PADDLE_WIDTH, PADDLE_HEIGHT);
                
                // Draw ball (bigger and brighter)
                ctx.beginPath();
                ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }
            
            // Update game
            function update() {
                if (!gameRunning) return;
                
                // Move ball
                ballX += ballSpeedX;
                ballY += ballSpeedY;
                
                // Ball collision with walls
                if (ballX + BALL_RADIUS > canvas.width || ballX - BALL_RADIUS < 0) {
                    ballSpeedX = -ballSpeedX;
                }
                if (ballY - BALL_RADIUS < 0) {
                    ballSpeedY = -ballSpeedY;
                }
                
                // Ball collision with paddle
                if (ballY + BALL_RADIUS > canvas.height - 30 && 
                    ballY + BALL_RADIUS < canvas.height - 20 &&
                    ballX > paddleX && 
                    ballX < paddleX + PADDLE_WIDTH) {
                    ballSpeedY = -Math.abs(ballSpeedY);
                    // Add spin based on where ball hits paddle
                    const hitPos = (ballX - paddleX) / PADDLE_WIDTH;
                    ballSpeedX = (hitPos - 0.5) * 4;
                }
                
                // Ball collision with blocks
                blocks.forEach(block => {
                    if (block.visible) {
                        if (ballX + BALL_RADIUS > block.x &&
                            ballX - BALL_RADIUS < block.x + BLOCK_WIDTH &&
                            ballY + BALL_RADIUS > block.y &&
                            ballY - BALL_RADIUS < block.y + BLOCK_HEIGHT) {
                            block.visible = false;
                            ballSpeedY = -ballSpeedY;
                            score += 10;
                            scoreEl.textContent = score;
                        }
                    }
                });
                
                // Check if ball fell off bottom
                if (ballY > canvas.height) {
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                        return;
                    }
                    resetBall();
                }
                
                // Check win condition
                const blocksLeft = blocks.filter(b => b.visible).length;
                if (blocksLeft === 0) {
                    gameRunning = false;
                    if (blockBreakerGameInterval) {
                        cancelAnimationFrame(blockBreakerGameInterval);
                    }
                    alert('You Win! Score: ' + score);
                    startGame();
                }
            }
            
            // Game loop
            function gameLoop() {
                update();
                draw();
                if (gameRunning) {
                    blockBreakerGameInterval = requestAnimationFrame(gameLoop);
                }
            }
            
            function resetBall() {
                ballX = canvas.width / 2;
                ballY = canvas.height - 50;
                ballSpeedX = 2 * (Math.random() > 0.5 ? 1 : -1);
                ballSpeedY = -2;
            }
            
            function startGame() {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                }
                
                gameRunning = true;
                score = 0;
                lives = 3;
                scoreEl.textContent = score;
                livesEl.textContent = lives;
                paddleX = (canvas.width - PADDLE_WIDTH) / 2;
                createBlocks();
                resetBall();
                draw();
                gameLoop();
            }
            
            function gameOver() {
                gameRunning = false;
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                alert('Game Over! Final Score: ' + score);
                startGame();
            }
            
            // Mouse controls
            const handleMouseMove = (e) => {
                if (!gameRunning || !window.parentNode) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, mouseX - PADDLE_WIDTH / 2));
            };
            
            // Keyboard controls
            const handleKeyPress = (e) => {
                if (!gameRunning || !window.parentNode) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        paddleX = Math.max(0, paddleX - 10);
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        paddleX = Math.min(canvas.width - PADDLE_WIDTH, paddleX + 10);
                        e.preventDefault();
                        break;
                }
            };
            
            // Add event listeners
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('keydown', handleKeyPress);
            
            closeBtn.onclick = () => {
                canvas.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('keydown', handleKeyPress);
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            restartBtn.onclick = () => {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                }
                startGame();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'blockbreaker',
                element: window
            });
            
            updateTaskbar();
            
            // Start the game
            startGame();
        }
        
        // Chatbot app
        function openChatbotApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '450px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = '';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.height = 'calc(100% - 20px)';
            content.style.overflow = 'hidden';
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.id = `chatbot-messages-${iconId}`;
            messagesArea.style.cssText = 'flex: 1; overflow-y: auto; border: 1px inset #c0c0c0; padding: 10px; margin-bottom: 10px; background: #fff; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';
            
            // Welcome message
            const welcomeMsg = document.createElement('div');
            welcomeMsg.style.cssText = 'margin-bottom: 10px; color: #666; font-style: italic;';
            welcomeMsg.textContent = 'Chatbot: Hello! How can I help you today?';
            messagesArea.appendChild(welcomeMsg);
            
            // Input area
            const inputContainer = document.createElement('div');
            inputContainer.style.cssText = 'display: flex; gap: 5px;';
            
            const inputField = document.createElement('input');
            inputField.type = 'text';
            inputField.id = `chatbot-input-${iconId}`;
            inputField.style.cssText = 'flex: 1; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';
            inputField.placeholder = 'Type your message...';
            
            const sendBtn = document.createElement('button');
            sendBtn.textContent = 'Send';
            sendBtn.style.cssText = 'padding: 5px 15px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 11px; font-weight: bold; cursor: pointer; font-family: "MS Sans Serif", Arial, sans-serif;';
            
            // Send function
            const sendMessage = () => {
                const message = inputField.value.trim();
                if (!message) return;
                
                // Add user message
                const userMsg = document.createElement('div');
                userMsg.style.cssText = 'margin-bottom: 10px; text-align: right; color: #000;';
                userMsg.textContent = `You: ${message}`;
                messagesArea.appendChild(userMsg);
                
                // Clear input
                inputField.value = '';
                
                // Scroll to bottom
                messagesArea.scrollTop = messagesArea.scrollHeight;
                
                // Add bot response after a short delay
                setTimeout(() => {
                    const botMsg = document.createElement('div');
                    botMsg.style.cssText = 'margin-bottom: 10px; color: #000;';
                    botMsg.textContent = 'Chatbot: sorry i dont understand mabey try again later';
                    messagesArea.appendChild(botMsg);
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }, 300);
            };
            
            sendBtn.onclick = sendMessage;
            inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            inputContainer.appendChild(inputField);
            inputContainer.appendChild(sendBtn);
            
            content.appendChild(messagesArea);
            content.appendChild(inputContainer);
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'chatbot',
                element: window
            });
            
            updateTaskbar();
            
            // Focus input field
            setTimeout(() => inputField.focus(), 100);
        }
        
        // Make functions globally accessible
        window.addDesktopApp = addDesktopApp;
        window.renameDesktopIcon = renameDesktopIcon;
        window.deleteDesktopIcon = deleteDesktopIcon;
        
        // Update applyTheme to handle ocean and paper themes (consolidating all wrappers)
        const originalApplyTheme4 = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup if switching away from matrix
            if (document.body.classList.contains('theme-matrix') && themeName !== 'matrix') {
                cleanupMatrixColumns();
            }
            
            // Cleanup if switching away from space
            if (document.body.classList.contains('theme-space') && themeName !== 'space') {
                cleanupSpaceStars();
            }
            
            // Cleanup if switching away from ocean
            if (document.body.classList.contains('theme-ocean') && themeName !== 'ocean') {
                cleanupOceanFish();
            }
            
            // Cleanup if switching away from paper
            if (document.body.classList.contains('theme-paper') && themeName !== 'paper') {
                cleanupPaperDrawing();
            }
            
            // Cleanup if switching away from clouds
            if (document.body.classList.contains('theme-clouds') && themeName !== 'clouds') {
                cleanupClouds();
            }
            
            // Cleanup if switching away from flashcard
            if (document.body.classList.contains('theme-flashcard') && themeName !== 'flashcard') {
                cleanupFlashcards();
            }
            
            originalApplyTheme4(themeName, save);
            
            // Setup matrix handler if switching to matrix
            setupMatrixKeyHandler();
            
            // Setup space theme if switching to it
            setupSpaceTheme();
            
            // Setup ocean theme if switching to it
            setupOceanTheme();
            
            // Setup paper theme if switching to it
            setupPaperTheme();
            
            // Setup clouds theme if switching to it
            setupCloudsTheme();
            
            // Setup flashcard theme if switching to it
            setupFlashcardTheme();
        };
        
        // Update window.applyTheme to use the consolidated version
        window.applyTheme = applyTheme;
        
        // Setup ocean and paper themes on page load if active
        setTimeout(() => {
            setupOceanTheme();
            setupPaperTheme();
            setupCloudsTheme();
            setupFlashcardTheme();
        }, 150);
        
        // Handle window resize for paper canvas
        window.addEventListener('resize', () => {
            if (paperCanvas && document.body.classList.contains('theme-paper')) {
                const imageData = paperCtx.getImageData(0, 0, paperCanvas.width, paperCanvas.height);
                paperCanvas.width = window.innerWidth;
                paperCanvas.height = window.innerHeight;
                paperCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Wooperbird goose on main page
        let wooperbirdCanvas, wooperbirdCtx;
        let wooperbirdGoose = null;
        let wooperbirdDragged = false;
        let wooperbirdMousePos = { x: 0, y: 0 };
        let wooperbirdLastMousePos = { x: 0, y: 0 };
        let wooperbirdAnimationId = null;
        
        function initWooperbirdCanvas() {
            wooperbirdCanvas = document.getElementById('wooperbirdCanvas');
            if (!wooperbirdCanvas) return;
            
            wooperbirdCanvas.width = window.innerWidth;
            wooperbirdCanvas.height = window.innerHeight;
            wooperbirdCtx = wooperbirdCanvas.getContext('2d');
            wooperbirdCanvas.style.pointerEvents = wooperbirdGoose ? 'auto' : 'none';
            
            // Mouse/touch events for dragging
            wooperbirdCanvas.addEventListener('mousedown', handleWooperbirdMouseDown);
            wooperbirdCanvas.addEventListener('mousemove', handleWooperbirdMouseMove);
            wooperbirdCanvas.addEventListener('mouseup', handleWooperbirdMouseUp);
            wooperbirdCanvas.addEventListener('touchstart', handleWooperbirdTouchStart, { passive: false });
            wooperbirdCanvas.addEventListener('touchmove', handleWooperbirdTouchMove, { passive: false });
            wooperbirdCanvas.addEventListener('touchend', handleWooperbirdTouchEnd);
            
            if (wooperbirdGoose) {
                animateWooperbird();
            }
        }
        
        function spawnWooperbirdGoose() {
            if (!wooperbirdCanvas) {
                initWooperbirdCanvas();
            }
            
            wooperbirdGoose = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2,
                size: 30,
                rotation: 0,
                rotationSpeed: 0.02
            };
            
            wooperbirdCanvas.style.pointerEvents = 'auto';
            
            if (!wooperbirdAnimationId) {
                animateWooperbird();
            }
        }
        
        function drawWooperbirdGoose(goose) {
            if (!wooperbirdCtx || !goose) return;
            
            wooperbirdCtx.save();
            wooperbirdCtx.translate(goose.x, goose.y);
            wooperbirdCtx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            wooperbirdCtx.fillStyle = '#FFFFFF';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#000000';
            wooperbirdCtx.lineWidth = 2;
            wooperbirdCtx.stroke();
            
            // Draw goose head
            wooperbirdCtx.fillStyle = '#FFFFFF';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.stroke();
            
            // Draw beak
            wooperbirdCtx.fillStyle = '#FFA500';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            wooperbirdCtx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            wooperbirdCtx.lineTo(goose.size * 0.7, -goose.size * 0.1);
            wooperbirdCtx.closePath();
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#000000';
            wooperbirdCtx.stroke();
            
            // Draw eye
            wooperbirdCtx.fillStyle = '#000000';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            
            wooperbirdCtx.restore();
        }
        
        function handleWooperbirdMouseDown(e) {
            if (!wooperbirdGoose) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdMouseMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdMouseUp() {
            wooperbirdDragged = false;
        }
        
        function handleWooperbirdTouchStart(e) {
            if (!wooperbirdGoose) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdTouchMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdTouchEnd() {
            wooperbirdDragged = false;
        }
        
        function animateWooperbird() {
            if (!wooperbirdCtx || !wooperbirdGoose) {
                wooperbirdAnimationId = null;
                return;
            }
            
            wooperbirdCtx.clearRect(0, 0, wooperbirdCanvas.width, wooperbirdCanvas.height);
            
            if (!wooperbirdDragged) {
                wooperbirdGoose.rotation += wooperbirdGoose.rotationSpeed;
            }
            
            drawWooperbirdGoose(wooperbirdGoose);
            
            wooperbirdAnimationId = requestAnimationFrame(animateWooperbird);
        }
        
        // Initialize wooperbird canvas on page load
        initWooperbirdCanvas();
        
        // Handle window resize for wooperbird canvas
        window.addEventListener('resize', () => {
            if (wooperbirdCanvas) {
                wooperbirdCanvas.width = window.innerWidth;
                wooperbirdCanvas.height = window.innerHeight;
            }
        });
        
        // Panic Menu system
        let panicHotkey = null;
        let panicUrl = '';
        
        function loadPanicSettings() {
            const saved = localStorage.getItem('panicSettings');
            if (saved) {
                const data = JSON.parse(saved);
                panicHotkey = data.hotkey || null;
                panicUrl = data.url || '';
            }
            setupPanicHotkey();
        }
        
        function savePanicSettings() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            if (!hotkeyInput || !urlInput) return;
            
            const url = urlInput.value.trim();
            
            if (!panicHotkey || !url) {
                if (statusEl) statusEl.textContent = 'Please set both hotkey and URL!';
                return;
            }
            
            localStorage.setItem('panicSettings', JSON.stringify({
                hotkey: panicHotkey,
                url: url
            }));
            panicUrl = url;
            setupPanicHotkey();
            
            if (statusEl) statusEl.textContent = 'Settings saved! Press your hotkey to swap tabs.';
            setTimeout(() => {
                if (statusEl) statusEl.textContent = '';
            }, 3000);
        }
        
        function setupPanicHotkey() {
            // Remove existing listener if any
            document.removeEventListener('keydown', handlePanicHotkey);
            
            if (panicHotkey && panicUrl) {
                document.addEventListener('keydown', handlePanicHotkey);
            }
        }
        
        function handlePanicHotkey(e) {
            // Check if the pressed key matches the panic hotkey
            if (e.key.toLowerCase() === panicHotkey.toLowerCase() || e.code.toLowerCase() === panicHotkey.toLowerCase()) {
                // Swap to the panic URL
                window.location.href = panicUrl;
            }
        }
        
        function initPanicMenu() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            loadPanicSettings();
            
            if (hotkeyInput) {
                hotkeyInput.value = panicHotkey || '';
                
                hotkeyInput.addEventListener('focus', () => {
                    hotkeyInput.value = '';
                    hotkeyInput.placeholder = 'Press a key...';
                });
                
                hotkeyInput.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    // Get the key code or key name
                    const key = e.key.length === 1 ? e.key.toLowerCase() : e.code;
                    panicHotkey = key;
                    hotkeyInput.value = e.key.length === 1 ? e.key.toUpperCase() : e.code;
                    hotkeyInput.placeholder = 'Hotkey';
                });
            }
            
            if (urlInput) {
                urlInput.value = panicUrl;
            }
            
            if (statusEl) {
                statusEl.textContent = '';
            }
        }
        
        // Make savePanicSettings globally accessible
        window.savePanicSettings = savePanicSettings;
        
        // Load panic settings on page load
        loadPanicSettings();
        
        // Goose Rain game with physics
        let geese = [];
        let animationId = null;
        let canvas, ctx;
        let draggedGoose = null;
        let mousePos = { x: 0, y: 0 };
        let lastGooseMousePos = { x: 0, y: 0 };
        let gooseDragStartPos = { x: 0, y: 0 };
        
        // Stones game with physics
        let stones = [];
        let stonesAnimationId = null;
        let stonesCanvas, stonesCtx;
        let draggedStone = null;
        let stonesMousePos = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };
        
        function initGooseRain() {
            canvas = document.getElementById('gooseCanvas');
            if (!canvas) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx = canvas.getContext('2d');
            
            geese = [];
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = 0;
            
            // Stop previous animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Mouse/touch events for dragging
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Spawn geese
            spawnGoose();
            const spawnInterval = setInterval(() => {
                if (document.getElementById('gooserainPage').classList.contains('hidden')) {
                    clearInterval(spawnInterval);
                    return;
                }
                spawnGoose();
            }, 500);
            
            // Start animation loop
            animate();
        }
        
        function spawnGoose() {
            geese.push({
                x: Math.random() * canvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: Math.random() * 30 + 20,
                rotation: (Math.random() - 0.5) * 0.2,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                dragged: false,
                targetX: 0,
                targetY: 0,
                mass: Math.random() * 30 + 20 // Weight based on size
            });
            
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = geese.length;
        }
        
        function drawGoose(goose) {
                    ctx.save();
            ctx.translate(goose.x, goose.y);
            ctx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
            ctx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw goose head
            ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
            ctx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
                        ctx.stroke();
            
            // Draw beak
            ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
            ctx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            ctx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            ctx.lineTo(goose.size * 0.7, -goose.size * 0.1);
                    ctx.closePath();
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.stroke();
            
            // Draw eye
            ctx.fillStyle = '#000000';
                    ctx.beginPath();
            ctx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
                    ctx.fill();
            
                    ctx.restore();
        }
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            // Check if clicking on a goose
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleMouseUp() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleTouchEnd() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw geese
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                
                if (goose.dragged) {
                    // Position is updated directly in mouse/touch handlers
                    // Keep rotation while dragging
                    goose.rotation += goose.rotationSpeed * 0.5;
                } else {
                    // Physics
                    goose.vy += 0.1; // Gravity
                    goose.vx *= 0.99; // Air resistance
                    goose.vy *= 0.99;
                    
                    goose.x += goose.vx;
                    goose.y += goose.vy;
                    goose.rotation += goose.rotationSpeed;
                    
                    // Collision with ground
                    if (goose.y > canvas.height - goose.size) {
                        goose.y = canvas.height - goose.size;
                        goose.vy *= -0.6; // Bounce
                        goose.vx *= 0.8; // Friction
                        if (Math.abs(goose.vy) < 0.5) {
                            goose.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (goose.x < goose.size || goose.x > canvas.width - goose.size) {
                        goose.vx *= -0.8;
                        goose.x = Math.max(goose.size, Math.min(canvas.width - goose.size, goose.x));
                    }
                }
                
                // Collision with other geese (works for both dragged and non-dragged)
                for (let j = 0; j < geese.length; j++) {
                    if (i !== j) {
                        const other = geese[j];
                        const dx = goose.x - other.x;
                        const dy = goose.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = goose.size + other.size;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass (heavier geese push more)
                            const totalMass = goose.mass + other.mass;
                            const goosePush = (other.mass / totalMass) * overlap;
                            const otherPush = (goose.mass / totalMass) * overlap;
                            
                            // Only move non-dragged geese, or both if both are dragged
                            if (!goose.dragged) {
                                goose.x += Math.cos(angle) * goosePush;
                                goose.y += Math.sin(angle) * goosePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                        } else {
                                // If other is dragged, push the dragged goose back a bit
                                goose.x += Math.cos(angle) * goosePush * 0.3;
                                goose.y += Math.sin(angle) * goosePush * 0.3;
                            }
                            
                            // Bounce for non-dragged geese
                            if (!goose.dragged && !other.dragged) {
                                const relativeVx = goose.vx - other.vx;
                                const relativeVy = goose.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                goose.vx -= Math.cos(angle) * dot * 0.5;
                                goose.vy -= Math.sin(angle) * dot * 0.5;
                                other.vx += Math.cos(angle) * dot * 0.5;
                                other.vy += Math.sin(angle) * dot * 0.5;
                            }
                        }
                    }
                }
                
                drawGoose(goose);
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Handle window resize for goose rain
        window.addEventListener('resize', () => {
            if (canvas && !document.getElementById('gooserainPage').classList.contains('hidden')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            if (stonesCanvas && !document.getElementById('stonesPage').classList.contains('hidden')) {
                stonesCanvas.width = window.innerWidth;
                stonesCanvas.height = window.innerHeight;
            }
        });
        
        // Paint game with canvas
        let paintCanvas, paintCtx;
        let isPainting = false;
        let paintBrushSize = 5;
        let paintColor = '#000000';
        let lastPaintX = 0;
        let lastPaintY = 0;
        
        function initPaint() {
            paintCanvas = document.getElementById('paintCanvas');
            if (!paintCanvas) return;
            
            paintCanvas.width = window.innerWidth;
            paintCanvas.height = window.innerHeight;
            paintCtx = paintCanvas.getContext('2d');
            paintCtx.fillStyle = '#ffffff';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            
            // Color picker event listener
            const colorPicker = document.getElementById('paint-color-picker');
            const colorDisplay = document.getElementById('paint-color-display');
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    paintColor = e.target.value;
                    if (colorDisplay) colorDisplay.textContent = paintColor;
                });
            }
            
            // Mouse/touch events for drawing
            paintCanvas.addEventListener('mousedown', handlePaintMouseDown);
            paintCanvas.addEventListener('mousemove', handlePaintMouseMove);
            paintCanvas.addEventListener('mouseup', handlePaintMouseUp);
            paintCanvas.addEventListener('mouseleave', handlePaintMouseUp);
            paintCanvas.addEventListener('touchstart', handlePaintTouchStart, { passive: false });
            paintCanvas.addEventListener('touchmove', handlePaintTouchMove, { passive: false });
            paintCanvas.addEventListener('touchend', handlePaintTouchEnd);
        }
        
        function handlePaintMouseDown(e) {
            isPainting = true;
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = e.clientX - rect.left;
            lastPaintY = e.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintMouseMove(e) {
            if (!isPainting) return;
            const rect = paintCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintMouseUp() {
            isPainting = false;
        }
        
        function handlePaintTouchStart(e) {
            e.preventDefault();
            isPainting = true;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = touch.clientX - rect.left;
            lastPaintY = touch.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintTouchMove(e) {
            e.preventDefault();
            if (!isPainting) return;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintTouchEnd(e) {
            e.preventDefault();
            isPainting = false;
        }
        
        function drawPaintPoint(x, y) {
            paintCtx.fillStyle = paintColor;
            paintCtx.beginPath();
            paintCtx.arc(x, y, paintBrushSize / 2, 0, Math.PI * 2);
            paintCtx.fill();
        }
        
        function drawPaintLine(x1, y1, x2, y2) {
            paintCtx.strokeStyle = paintColor;
            paintCtx.lineWidth = paintBrushSize;
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            paintCtx.beginPath();
            paintCtx.moveTo(x1, y1);
            paintCtx.lineTo(x2, y2);
            paintCtx.stroke();
        }
        
        // Handle window resize for paint canvas
        window.addEventListener('resize', () => {
            if (paintCanvas && !document.getElementById('paintPage').classList.contains('hidden')) {
                // Save current canvas content
                const imageData = paintCtx.getImageData(0, 0, paintCanvas.width, paintCanvas.height);
                paintCanvas.width = window.innerWidth;
                paintCanvas.height = window.innerHeight;
                paintCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Collaborative Drawing Board
        let drawingBoardCanvas = null;
        let drawingBoardCtx = null;
        let isDrawing = false;
        let lastDrawingX = 0;
        let lastDrawingY = 0;
        let drawingColor = '#000000';
        let drawingBrushSize = 5;
        let drawingUserId = 'user_' + Math.random().toString(36).substr(2, 9);
        let drawingSyncInterval = null;
        let drawingLastSync = 0;
        
        function initDrawingBoard() {
            drawingBoardCanvas = document.getElementById('drawingBoardCanvas');
            if (!drawingBoardCanvas) return;
            
            drawingBoardCanvas.width = window.innerWidth;
            drawingBoardCanvas.height = window.innerHeight;
            drawingBoardCtx = drawingBoardCanvas.getContext('2d');
            drawingBoardCtx.fillStyle = '#ffffff';
            drawingBoardCtx.fillRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
            
            // Load existing drawing from localStorage
            loadDrawingBoard();
            
            // Brush size slider
            const brushSizeSlider = document.getElementById('drawing-brush-size-slider');
            const brushSizeDisplay = document.getElementById('drawing-brush-size');
            if (brushSizeSlider) {
                brushSizeSlider.addEventListener('input', (e) => {
                    drawingBrushSize = parseInt(e.target.value);
                    if (brushSizeDisplay) brushSizeDisplay.textContent = drawingBrushSize;
                });
            }
            
            // Color picker
            const colorPicker = document.getElementById('drawing-color-picker');
            const colorDisplay = document.getElementById('drawing-color-display');
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    drawingColor = e.target.value;
                    if (colorDisplay) colorDisplay.textContent = drawingColor;
                });
            }
            
            // Drawing events
            drawingBoardCanvas.addEventListener('mousedown', handleDrawingMouseDown);
            drawingBoardCanvas.addEventListener('mousemove', handleDrawingMouseMove);
            drawingBoardCanvas.addEventListener('mouseup', handleDrawingMouseUp);
            drawingBoardCanvas.addEventListener('mouseleave', handleDrawingMouseUp);
            drawingBoardCanvas.addEventListener('touchstart', handleDrawingTouchStart, { passive: false });
            drawingBoardCanvas.addEventListener('touchmove', handleDrawingTouchMove, { passive: false });
            drawingBoardCanvas.addEventListener('touchend', handleDrawingTouchEnd);
            
            // Start syncing with other users (polling localStorage)
            startDrawingSync();
        }
        
        function handleDrawingMouseDown(e) {
            isDrawing = true;
            const rect = drawingBoardCanvas.getBoundingClientRect();
            lastDrawingX = e.clientX - rect.left;
            lastDrawingY = e.clientY - rect.top;
            drawDrawingPoint(lastDrawingX, lastDrawingY);
        }
        
        function handleDrawingMouseMove(e) {
            if (!isDrawing) return;
            const rect = drawingBoardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawDrawingLine(lastDrawingX, lastDrawingY, x, y);
            lastDrawingX = x;
            lastDrawingY = y;
        }
        
        function handleDrawingMouseUp() {
            isDrawing = false;
        }
        
        function handleDrawingTouchStart(e) {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const rect = drawingBoardCanvas.getBoundingClientRect();
            lastDrawingX = touch.clientX - rect.left;
            lastDrawingY = touch.clientY - rect.top;
            drawDrawingPoint(lastDrawingX, lastDrawingY);
        }
        
        function handleDrawingTouchMove(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const touch = e.touches[0];
            const rect = drawingBoardCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawDrawingLine(lastDrawingX, lastDrawingY, x, y);
            lastDrawingX = x;
            lastDrawingY = y;
        }
        
        function handleDrawingTouchEnd(e) {
            e.preventDefault();
            isDrawing = false;
        }
        
        function drawDrawingPoint(x, y) {
            if (!drawingBoardCtx) return;
            drawingBoardCtx.fillStyle = drawingColor;
            drawingBoardCtx.beginPath();
            drawingBoardCtx.arc(x, y, drawingBrushSize / 2, 0, Math.PI * 2);
            drawingBoardCtx.fill();
            saveDrawingBoard();
        }
        
        function drawDrawingLine(x1, y1, x2, y2) {
            if (!drawingBoardCtx) return;
            drawingBoardCtx.strokeStyle = drawingColor;
            drawingBoardCtx.lineWidth = drawingBrushSize;
            drawingBoardCtx.lineCap = 'round';
            drawingBoardCtx.lineJoin = 'round';
            drawingBoardCtx.beginPath();
            drawingBoardCtx.moveTo(x1, y1);
            drawingBoardCtx.lineTo(x2, y2);
            drawingBoardCtx.stroke();
            saveDrawingBoard();
        }
        
        function saveDrawingBoard() {
            if (!drawingBoardCanvas) return;
            const imageData = drawingBoardCanvas.toDataURL();
            localStorage.setItem('drawingBoard_data', imageData);
            localStorage.setItem('drawingBoard_timestamp', Date.now().toString());
            localStorage.setItem('drawingBoard_user', drawingUserId);
        }
        
        function loadDrawingBoard() {
            if (!drawingBoardCanvas || !drawingBoardCtx) return;
            const savedData = localStorage.getItem('drawingBoard_data');
            if (savedData) {
                const img = new Image();
                img.onload = () => {
                    drawingBoardCtx.clearRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                    drawingBoardCtx.drawImage(img, 0, 0);
                };
                img.src = savedData;
            }
        }
        
        function startDrawingSync() {
            // Poll for updates from other users (localStorage-based collaboration)
            drawingSyncInterval = setInterval(() => {
                if (!drawingBoardCanvas || document.getElementById('drawingBoardPage').classList.contains('hidden')) return;
                
                const lastTimestamp = localStorage.getItem('drawingBoard_timestamp');
                const lastUser = localStorage.getItem('drawingBoard_user');
                
                if (lastTimestamp && lastUser && lastUser !== drawingUserId) {
                    const timestamp = parseInt(lastTimestamp);
                    if (timestamp > drawingLastSync) {
                        loadDrawingBoard();
                        drawingLastSync = timestamp;
                    }
                }
                
                // Update user count (simplified - in real Firebase this would be accurate)
                const userCountEl = document.getElementById('drawing-user-count');
                if (userCountEl) {
                    // For now, just show 1+ if there's recent activity
                    const recentActivity = lastTimestamp && (Date.now() - parseInt(lastTimestamp) < 5000);
                    userCountEl.textContent = recentActivity ? '1+' : '1';
                }
            }, 500); // Check every 500ms
        }
        
        function stopDrawingSync() {
            if (drawingSyncInterval) {
                clearInterval(drawingSyncInterval);
                drawingSyncInterval = null;
            }
        }
        
        function clearDrawingBoard() {
            if (!drawingBoardCanvas || !drawingBoardCtx) return;
            if (confirm('Clear the entire canvas? This will affect all users.')) {
                drawingBoardCtx.fillStyle = '#ffffff';
                drawingBoardCtx.fillRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                saveDrawingBoard();
            }
        }
        
        // Initialize drawing board when page is shown
        const originalShowPage = showPage;
        showPage = function(pageId) {
            originalShowPage(pageId);
            if (pageId === 'drawingBoardPage') {
                setTimeout(() => {
                    if (!drawingBoardCanvas) {
                        initDrawingBoard();
                    } else {
                        // Resize if needed
                        const currentWidth = drawingBoardCanvas.width;
                        const currentHeight = drawingBoardCanvas.height;
                        if (currentWidth !== window.innerWidth || currentHeight !== window.innerHeight) {
                            const imageData = drawingBoardCtx.getImageData(0, 0, currentWidth, currentHeight);
                            drawingBoardCanvas.width = window.innerWidth;
                            drawingBoardCanvas.height = window.innerHeight;
                            drawingBoardCtx.putImageData(imageData, 0, 0);
                        }
                    }
                }, 100);
            } else {
                stopDrawingSync();
            }
        };
        
        // Handle window resize for drawing board canvas
        window.addEventListener('resize', () => {
            if (drawingBoardCanvas && !document.getElementById('drawingBoardPage').classList.contains('hidden')) {
                const imageData = drawingBoardCtx.getImageData(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                drawingBoardCanvas.width = window.innerWidth;
                drawingBoardCanvas.height = window.innerHeight;
                drawingBoardCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Stones game initialization
        function initStones() {
            stonesCanvas = document.getElementById('stonesCanvas');
            if (!stonesCanvas) return;
            
            stonesCanvas.width = window.innerWidth;
            stonesCanvas.height = window.innerHeight;
            stonesCtx = stonesCanvas.getContext('2d');
            
            stones = [];
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = 0;
            
            // Stop previous animation
            if (stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
            }
            
            // Mouse/touch events for dragging and throwing
            stonesCanvas.addEventListener('mousedown', handleStonesMouseDown);
            stonesCanvas.addEventListener('mousemove', handleStonesMouseMove);
            stonesCanvas.addEventListener('mouseup', handleStonesMouseUp);
            stonesCanvas.addEventListener('touchstart', handleStonesTouchStart, { passive: false });
            stonesCanvas.addEventListener('touchmove', handleStonesTouchMove, { passive: false });
            stonesCanvas.addEventListener('touchend', handleStonesTouchEnd);
            
            // Key event for spawning stones with 'e'
            stonesKeyHandler = handleStonesKeyDown;
            document.addEventListener('keydown', stonesKeyHandler);
            
            // Start animation loop
            animateStones();
        }
        
        // Handle 'e' key to spawn stones (only when on stones page)
        let stonesKeyHandler = null;
        
        function handleStonesKeyDown(e) {
            if (document.getElementById('stonesPage').classList.contains('hidden')) return;
            
            if (e.key === 'e' || e.key === 'E') {
                spawnStone();
            }
        }
        
        // Stone shape types
        const STONE_SHAPES = ['circle', 'square', 'triangle', 'irregular'];
        
        function spawnStone() {
            const size = Math.random() * 40 + 40; // Increased from 15-40 to 40-80 (bigger)
            const shape = STONE_SHAPES[Math.floor(Math.random() * STONE_SHAPES.length)];
            const stoneColor = `rgb(${Math.floor(Math.random() * 60 + 80)}, ${Math.floor(Math.random() * 40 + 60)}, ${Math.floor(Math.random() * 40 + 60)})`;
            
            // Add random scaling for stretched shapes
            const scaleX = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            const scaleY = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            
            stones.push({
                x: Math.random() * stonesCanvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: size,
                scaleX: scaleX,
                scaleY: scaleY,
                dragged: false,
                shape: shape,
                color: stoneColor,
                mass: size * scaleX * scaleY * 3, // Increased mass (3x heavier)
                lastX: 0,
                lastY: 0,
                collisionRadius: size * Math.max(scaleX, scaleY) // Collision radius based on max scaled dimension
            });
            
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = stones.length;
        }
        
        function drawStone(stone) {
            stonesCtx.save();
            stonesCtx.translate(stone.x, stone.y);
            stonesCtx.scale(stone.scaleX || 1, stone.scaleY || 1); // Apply scaling for stretched shapes (no rotation)
            
            stonesCtx.fillStyle = stone.color;
            stonesCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            stonesCtx.lineWidth = 2;
            
            stonesCtx.beginPath();
            
            if (stone.shape === 'circle') {
                stonesCtx.arc(0, 0, stone.size, 0, Math.PI * 2);
            } else if (stone.shape === 'square') {
                stonesCtx.rect(-stone.size, -stone.size, stone.size * 2, stone.size * 2);
            } else if (stone.shape === 'triangle') {
                stonesCtx.moveTo(0, -stone.size);
                stonesCtx.lineTo(-stone.size * 0.866, stone.size * 0.5);
                stonesCtx.lineTo(stone.size * 0.866, stone.size * 0.5);
                stonesCtx.closePath();
            } else if (stone.shape === 'irregular') {
                // Draw irregular polygon with random variations
                const sides = 5 + Math.floor(Math.random() * 6); // 5-10 sides
                const seed = stone.x * 1000 + stone.y; // Use position as seed for consistency
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const radiusVariation = 0.5 + ((seed + i * 137) % 50) / 100; // 0.5 to 1.0
                    const radius = stone.size * radiusVariation;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) {
                        stonesCtx.moveTo(x, y);
                } else {
                        stonesCtx.lineTo(x, y);
                    }
                }
                stonesCtx.closePath();
            }
            
            stonesCtx.fill();
            stonesCtx.stroke();
            stonesCtx.restore();
        }
        
        function handleStonesMouseDown(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            // Check if clicking on a stone
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesMouseMove(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            
            if (draggedStone) {
                // Update position directly while dragging
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesMouseUp() {
            if (draggedStone) {
                // Calculate velocity based on movement while dragging
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                const dt = 0.016; // Approximate frame time
                
                // Set velocity based on drag distance and direction (throwing) - reduced power
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function handleStonesTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            
            if (draggedStone) {
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesTouchEnd() {
            if (draggedStone) {
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function animateStones() {
            // Clear canvas with water/shore background
            const gradient = stonesCtx.createLinearGradient(0, 0, 0, stonesCanvas.height);
            gradient.addColorStop(0, '#4682B4'); // Sky blue (water)
            gradient.addColorStop(0.6, '#5F9EA0'); // Cadet blue (shallow water)
            gradient.addColorStop(0.6, '#D2B48C'); // Tan (shore)
            gradient.addColorStop(1, '#CD853F'); // Peru (sand)
            stonesCtx.fillStyle = gradient;
            stonesCtx.fillRect(0, 0, stonesCanvas.width, stonesCanvas.height);
            
            // Update and draw stones
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                
                if (!stone.dragged) {
                    // Physics
                    stone.vy += 0.2; // Gravity
                    stone.vx *= 0.98; // Air resistance
                    stone.vy *= 0.98;
                    
                    stone.x += stone.vx;
                    stone.y += stone.vy;
                    
                    // Collision with ground (shore)
                    const shoreLevel = stonesCanvas.height * 0.6;
                    const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                    if (stone.y > shoreLevel - collisionRadius) {
                        stone.y = shoreLevel - collisionRadius;
                        stone.vy *= -0.5; // Bounce
                        stone.vx *= 0.7; // Friction
                        if (Math.abs(stone.vy) < 0.5) {
                            stone.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (stone.x < collisionRadius || stone.x > stonesCanvas.width - collisionRadius) {
                        stone.vx *= -0.7;
                        stone.x = Math.max(collisionRadius, Math.min(stonesCanvas.width - collisionRadius, stone.x));
                    }
                }
                
                // Collision with other stones
                for (let j = 0; j < stones.length; j++) {
                    if (i !== j) {
                        const other = stones[j];
                        const dx = stone.x - other.x;
                        const dy = stone.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const stoneCollisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                        const otherCollisionRadius = other.collisionRadius || (other.size * Math.max(other.scaleX || 1, other.scaleY || 1));
                        const minDist = stoneCollisionRadius + otherCollisionRadius;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass
                            const totalMass = stone.mass + other.mass;
                            const stonePush = (other.mass / totalMass) * overlap;
                            const otherPush = (stone.mass / totalMass) * overlap;
                            
                            // Only move non-dragged stones
                            if (!stone.dragged) {
                                stone.x += Math.cos(angle) * stonePush;
                                stone.y += Math.sin(angle) * stonePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                    } else {
                                // If other is dragged, push the dragged stone back a bit
                                stone.x += Math.cos(angle) * stonePush * 0.3;
                                stone.y += Math.sin(angle) * stonePush * 0.3;
                            }
                            
                            // Bounce for non-dragged stones
                            if (!stone.dragged && !other.dragged) {
                                const relativeVx = stone.vx - other.vx;
                                const relativeVy = stone.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                stone.vx -= Math.cos(angle) * dot * 0.6;
                                stone.vy -= Math.sin(angle) * dot * 0.6;
                                other.vx += Math.cos(angle) * dot * 0.6;
                                other.vy += Math.sin(angle) * dot * 0.6;
                            }
                        }
                    }
                }
                
                drawStone(stone);
            }
            
            stonesAnimationId = requestAnimationFrame(animateStones);
        }
        
        // Clicker game
        function clickMoney() {
            addMoney(clickerPerClick);
            // Button animation
            const btn = document.getElementById('clicker-button');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                }, 100);
            }
        }
        
        // Coinflip game
        let coinflipStreak = 0;
        let isCoinFlipping = false;
        let winChanceUpgrades = 0; // Number of upgrades purchased
        const BASE_WIN_CHANCE = 50; // Base 50% chance
        
        // Load saved data
        function loadCoinflipData() {
            const saved = localStorage.getItem('coinflipData');
            if (saved) {
                const data = JSON.parse(saved);
                winChanceUpgrades = data.upgrades || 0;
                coinflipStreak = data.streak || 0;
            }
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
        }
        
        // Save data
        function saveCoinflipData() {
            localStorage.setItem('coinflipData', JSON.stringify({
                upgrades: winChanceUpgrades,
                streak: coinflipStreak
            }));
        }
        
        // Calculate win chance
        function getWinChance() {
            return Math.min(BASE_WIN_CHANCE + winChanceUpgrades, 99); // Cap at 99%
        }
        
        // Update win chance display
        function updateWinChanceDisplay() {
            const winChancePercent = document.getElementById('win-chance-percent');
            const chance = getWinChance();
            if (winChancePercent) winChancePercent.textContent = chance;
            if (shopWinChance) shopWinChance.textContent = chance;
        }
        
        function resetCoinFlip() {
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            
            loadCoinflipData(); // Reload data when page is shown
            
            if (coin) {
                coin.style.transform = 'rotateY(0deg)';
                coin.classList.remove('coin-flipping');
            }
            if (result) {
                result.textContent = '';
            }
            if (streakCount) {
                streakCount.textContent = coinflipStreak;
            }
            
            // Enable buttons
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            if (headsBtn) headsBtn.disabled = false;
            if (tailsBtn) tailsBtn.disabled = false;
        }
        
        function guessCoin(guess) {
            if (isCoinFlipping) return;
            
            isCoinFlipping = true;
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            
            // Disable buttons
            if (headsBtn) headsBtn.disabled = true;
            if (tailsBtn) tailsBtn.disabled = true;
            
            // Add flipping animation
            coin.classList.add('coin-flipping');
            
            // Calculate win chance
            const winChance = getWinChance() / 100;
            const isCorrect = Math.random() < winChance;
            
            // Determine result (if we win, the coin lands on our guess, otherwise opposite)
            const isHeads = isCorrect ? (guess === 'heads') : (guess === 'tails');
            const resultText = isHeads ? 'Heads' : 'Tails';
            
            // Set final rotation
            setTimeout(() => {
                coin.classList.remove('coin-flipping');
                coin.style.transform = isHeads ? 'rotateY(0deg)' : 'rotateY(180deg)';
                
                if (isCorrect) {
                    coinflipStreak++;
                    // Calculate reward: base 2x multiplier, +0.5x per streak
                    // Base reward is $10, multiplied by (2 + streak * 0.5)
                    const multiplier = 2 + (coinflipStreak * 0.5);
                    const baseReward = 10;
                    const reward = Math.floor(baseReward * multiplier);
                    
                    addMoney(reward);
                    
                    if (result) {
                        result.textContent = ` Correct! It's ${resultText}! +$${reward} (${multiplier.toFixed(1)}x)`;
                        result.style.color = '#3fb950';
                        }
                } else {
                    coinflipStreak = 0;
                    if (result) {
                        result.textContent = ` Wrong! It was ${resultText}`;
                        result.style.color = '#f85149';
                    }
                }
                
                if (streakCount) {
                    streakCount.textContent = coinflipStreak;
                }
                
                saveCoinflipData();
                
                // Re-enable buttons after a delay
                setTimeout(() => {
                    isCoinFlipping = false;
                    if (headsBtn) headsBtn.disabled = false;
                    if (tailsBtn) tailsBtn.disabled = false;
                }, 500);
            }, 1000);
        }
        
        // Shop functions
        function getUpgradeCost(upgradeLevel) {
            return 20 * Math.pow(2, upgradeLevel);
        }
        
        function showShop() {
            showPage('shopPage');
            loadCoinflipData();
            renderShop();
        }
        
        function closeShop() {
            showPage('mainPage');
        }
        
        function buyUpgrade() {
            const cost = getUpgradeCost(winChanceUpgrades);
            if (spendMoney(cost)) {
                winChanceUpgrades++;
                updateWinChanceDisplay();
                saveCoinflipData();
                renderShop();
            }
        }
        
        function buyColor(colorName) {
            const cost = colorCosts[colorName];
            if (cost && spendMoney(cost)) {
                unlockedColors.add(colorName);
                saveGlobalData();
                renderShop();
            }
        }
        
        function buyClickerUpgrade() {
            const cost = clickerPerClick * 10;
            if (spendMoney(cost)) {
                clickerPerClick++;
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
                saveGlobalData();
                renderShop();
            }
        }
        
        function renderShop() {
            const container = document.getElementById('upgrade-container');
            if (!container) return;
            
            let html = '';
            
            // Win Chance Upgrade
            const winChanceCost = getUpgradeCost(winChanceUpgrades);
            const canAffordWinChance = globalMoney >= winChanceCost;
            const nextChance = Math.min(getWinChance() + 1, 99);
            html += `
                <div class="upgrade-item">
                    <h3>Win Chance Upgrade</h3>
                    <p>Increase your win chance by +1%</p>
                    <p>Current: ${getWinChance()}%  Next: ${nextChance}%</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${winChanceCost}</p>
                    <button class="upgrade-btn" onclick="buyUpgrade()" ${!canAffordWinChance ? 'disabled' : ''}>
                        ${canAffordWinChance ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Clicker Upgrade
            const clickerCost = clickerPerClick * 10;
            const canAffordClicker = globalMoney >= clickerCost;
            html += `
                <div class="upgrade-item">
                    <h3>Clicker Upgrade</h3>
                    <p>Increase money per click by +$1</p>
                    <p>Current: $${clickerPerClick}  Next: $${clickerPerClick + 1}</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${clickerCost}</p>
                    <button class="upgrade-btn" onclick="buyClickerUpgrade()" ${!canAffordClicker ? 'disabled' : ''}>
                        ${canAffordClicker ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Colors section
            html += `<div class="upgrade-item" style="margin-top: 30px;"><h3>Colors</h3>`;
            Object.keys(colorPalettes).forEach(colorName => {
                const cost = colorCosts[colorName];
                const isUnlocked = unlockedColors.has(colorName);
                const canAfford = globalMoney >= cost;
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: ${isUnlocked ? '#3fb950' : '#8b949e'}; text-transform: capitalize;">${colorName}</strong>
                            ${isUnlocked ? '<span style="color: #3fb950; margin-left: 10px;"> Unlocked</span>' : ''}
                        </div>
                        ${!isUnlocked ? `
                            <button class="upgrade-btn" onclick="buyColor('${colorName}')" ${!canAfford ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                                ${canAfford ? `Buy ($${cost})` : `$${cost}`}
                            </button>
                        ` : ''}
                    </div>
                `;
            });
            // Rainbow color
            const rainbowCost = colorCosts['rainbow'];
            const rainbowUnlocked = unlockedColors.has('rainbow');
            const canAffordRainbow = globalMoney >= rainbowCost;
            html += `
                <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: ${rainbowUnlocked ? '#3fb950' : '#8b949e'};">Rainbow</strong>
                        ${rainbowUnlocked ? '<span style="color: #3fb950; margin-left: 10px;"> Unlocked</span>' : ''}
                    </div>
                    ${!rainbowUnlocked ? `
                        <button class="upgrade-btn" onclick="buyColor('rainbow')" ${!canAffordRainbow ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                            ${canAffordRainbow ? `Buy ($${rainbowCost})` : `$${rainbowCost}`}
                        </button>
                    ` : ''}
                </div>
            `;
            html += `</div>`;
            
            container.innerHTML = html;
        }
        
        // Blocking system
        function checkBlocked() {
            if (localStorage.getItem('isBlocked') === 'true') {
                showPage('limboPage');
                const commandBar = document.querySelector('.command-bar');
                if (commandBar) commandBar.style.display = 'none';
                return true;
            }
            return false;
        }
        
        function unblock() {
            localStorage.removeItem('isBlocked');
            localStorage.removeItem('count67');
            showPage('mainPage');
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) commandBar.style.display = 'flex';
        }
        
        // Password check function for limbo page
        function checkLimboPassword() {
            const passwordInput = document.getElementById('limboPasswordInput');
            const errorEl = document.getElementById('limboError');
            
            if (!passwordInput) return;
            
            const password = passwordInput.value.trim();
            
            if (password === 'OG') {
                // Correct password - unblock
                unblock();
                if (passwordInput) passwordInput.value = '';
                if (errorEl) errorEl.textContent = '';
                } else {
                // Wrong password
                if (errorEl) errorEl.textContent = 'Incorrect password!';
                if (passwordInput) passwordInput.value = '';
                setTimeout(() => {
                    if (errorEl) errorEl.textContent = '';
                }, 2000);
            }
        }
        
        // Allow Enter key to submit password
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('limboPasswordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        checkLimboPassword();
                    }
                });
            }
        });
        
        // Initialize global data on page load
        loadGlobalData();
        loadCoinflipData();
        
        // Check if blocked on page load
        if (checkBlocked()) {
            // Already showing limbo page
        }
        
        // Update clicker display
        const clickerAmount = document.getElementById('clicker-amount');
        if (clickerAmount) clickerAmount.textContent = clickerPerClick;
        
        // Achievements system
        const TOTAL_ACHIEVEMENTS = 256;
        let foundAchievements = new Set();
        
        // Achievement data - only name, emoji, and description
        const achievementData = [
            { id: 0, name: "Welcome", emoji: "", desc: "Visit the site for the first time" },
            { id: 1, name: "Explorer", emoji: "", desc: "Visit the home page" },
            { id: 2, name: "Color Master", emoji: "", desc: "Change colors 10 times" },
            { id: 3, name: "Rainbow", emoji: "", desc: "Apply rainbow colors" },
            { id: 4, name: "Sweeper Pro", emoji: "", desc: "Win a game of Minesweeper" },
            { id: 5, name: "Pong Champion", emoji: "", desc: "Play Pong" },
            { id: 6, name: "Coinflip Streak", emoji: "", desc: "Get a 5 streak in coinflip" },
            { id: 7, name: "Rich", emoji: "", desc: "Earn $100 in coinflip" },
            { id: 8, name: "Lucky", emoji: "", desc: "Win 10 coinflips in a row" },
            { id: 9, name: "Upgrade Master", emoji: "", desc: "Buy 5 upgrades in the shop" },
            { id: 10, name: "Sandbox", emoji: "", desc: "Open Sandboxels" },
            { id: 11, name: "Commander", emoji: "", desc: "Use 10 different commands" },
            // Add more achievements with placeholders...
        ];
        
        // Generate placeholder achievements for the remaining slots
        for (let i = achievementData.length; i < TOTAL_ACHIEVEMENTS; i++) {
            const emojis = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
            achievementData.push({
                id: i,
                name: `Achievement ${i + 1}`,
                emoji: emojis[i % emojis.length],
                desc: `Mystery achievement #${i + 1} - discover to find out more!`
            });
        }
        
        // Load found achievements from localStorage
        function loadAchievements() {
            const saved = localStorage.getItem('achievements');
            if (saved) {
                foundAchievements = new Set(JSON.parse(saved));
                    } else {
                // First visit - unlock welcome achievement
                unlockAchievement(0);
            }
            updateAchievementStats();
        }
        
        // Save achievements to localStorage
        function saveAchievements() {
            localStorage.setItem('achievements', JSON.stringify(Array.from(foundAchievements)));
            updateAchievementStats();
        }
        
        // Unlock an achievement
        function unlockAchievement(id) {
            if (!foundAchievements.has(id)) {
                foundAchievements.add(id);
                saveAchievements();
                renderAchievements();
            }
        }
        
        // Update achievement statistics
        function updateAchievementStats() {
            const foundCount = document.getElementById('found-count');
            const totalCount = document.getElementById('total-count');
            if (foundCount) foundCount.textContent = foundAchievements.size;
            if (totalCount) totalCount.textContent = TOTAL_ACHIEVEMENTS;
        }
        
        // Generate 16x16 pixel art patterns for achievements
        function generatePixelPattern(achievementId) {
            const patterns = {
                0: (() => {
                    // Welcome - smiley face
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 3 && x <= 12 && y >= 3 && y <= 10) p[i] = '#FFA500'; // Face
                            if ((x === 5 || x === 10) && (y === 5 || y === 6)) p[i] = '#000000'; // Eyes
                            if (x >= 6 && x <= 9 && y === 9) p[i] = '#000000'; // Mouth
                        }
                    }
                    return p;
                })(),
                1: (() => {
                    // Explorer - compass
                    const p = Array(256).fill('#000000');
                    const center = 8;
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - center;
                            const dy = y - center;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= 6) p[i] = '#C0C0C0';
                            if (dist <= 5) p[i] = '#808080';
                            if ((x === center || y === center) && dist <= 7) p[i] = '#FFD700';
                        }
                    }
                    return p;
                })(),
                2: (() => {
                    // Color Master - palette
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 2 && x <= 13 && y >= 2 && y <= 13) {
                                const section = Math.floor((x - 2) / 3);
                                const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                                p[i] = colors[section % 4];
                            }
                        }
                    }
                    return p;
                })(),
                4: (() => {
                    // Sweeper Pro - bomb
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 36) p[i] = '#333333';
                            if (dx*dx + dy*dy <= 25) p[i] = '#000000';
                            if (x >= 7 && x <= 9 && y >= 2 && y <= 5) p[i] = '#FF0000';
                        }
                    }
                    return p;
                })(),
                5: (() => {
                    // Pong Champion - paddle
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 13) p[i] = '#FFFFFF';
                            if (x === 7 || x === 8) {
                                if (y >= 4 && y <= 6) p[i] = '#000000';
                                if (y >= 9 && y <= 11) p[i] = '#000000';
                            }
                        }
                    }
                    return p;
                })(),
                6: (() => {
                    // Coinflip Streak - coin
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 49) p[i] = '#FFD700';
                            if (dx*dx + dy*dy <= 42) p[i] = '#FFA500';
                            if (x === 8 && y >= 3 && y <= 12) p[i] = '#000000';
                        }
                    }
                    return p;
                })(),
                7: (() => {
                    // Rich - money bag
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 4 && x <= 11 && y >= 4 && y <= 12) p[i] = '#00AA00';
                            if (x >= 5 && x <= 10 && y >= 5 && y <= 11) p[i] = '#008800';
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 4) p[i] = '#888888';
                            if (x === 7 || x === 8) {
                                if (y === 6 || y === 8 || y === 10) p[i] = '#FFD700';
                            }
                        }
                    }
                    return p;
                })(),
            };
            
            // Use specific pattern or generate unique one
            if (patterns[achievementId]) {
                return patterns[achievementId];
            }
            
            // Generate unique pattern for each achievement
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#FF69B4', '#00FF7F'];
            const seed = achievementId * 137; // Unique seed per achievement
            return Array(256).fill(0).map((_, i) => {
                const x = i % 16;
                const y = Math.floor(i / 16);
                const hash = ((x * seed + y) * 17) % 100;
                if (hash < 30) return colors[achievementId % colors.length];
                if (hash < 50) return colors[(achievementId * 3) % colors.length];
                if (hash < 60) return colors[(achievementId * 7) % colors.length];
                return '#202020';
            });
        }
        
        // Render achievements grid
        function renderAchievements() {
            const grid = document.getElementById('achievements-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let i = 0; i < TOTAL_ACHIEVEMENTS; i++) {
                const achievement = achievementData[i];
                const isFound = foundAchievements.has(i);
                
                const sprite = document.createElement('div');
                sprite.className = `achievement-sprite ${isFound ? 'found' : ''}`;
                sprite.dataset.id = i;
                
                // Create pixel sprite
                const pixelPattern = generatePixelPattern(i);
                for (let j = 0; j < 256; j++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.backgroundColor = pixelPattern[j];
                    sprite.appendChild(pixel);
                }
                
                // Tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'tooltip-name';
                nameSpan.textContent = achievement.name;
                tooltip.appendChild(nameSpan);
                
                if (isFound) {
                    const descSpan = document.createElement('span');
                    descSpan.className = 'tooltip-desc';
                    descSpan.textContent = achievement.desc;
                    tooltip.appendChild(descSpan);
                }
                
                sprite.appendChild(tooltip);
                grid.appendChild(sprite);
            }
            
            updateAchievementStats();
        }
        
        // Initialize achievements on page load
        loadAchievements();
        
        // Achievement triggers
        let colorChangeCount = 0;
        let commandsUsed = new Set();
        
        // Override changeAllColors to track achievements
        const originalChangeAllColors = changeAllColors;
        changeAllColors = function(colorName) {
            originalChangeAllColors(colorName);
            colorChangeCount++;
            if (colorChangeCount >= 10) unlockAchievement(2);
            
            if (colorName === 'rainbow') {
                unlockAchievement(3);
            }
        };
        
        // Track navigation for achievements - override showPage
        const originalShowPageForAchievements = showPage;
        showPage = function(pageId) {
            originalShowPageForAchievements(pageId);
            
            // Stop goose rain animation if leaving
            if (pageId !== 'gooserainPage' && animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Stop stones animation if leaving
            if (pageId !== 'stonesPage' && stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
                stonesAnimationId = null;
                // Remove key handler when leaving
                if (stonesKeyHandler) {
                    document.removeEventListener('keydown', stonesKeyHandler);
                    stonesKeyHandler = null;
                }
            }
            
            // Update money displays on page change
            updateAllMoneyDisplays();
            
            if (pageId === 'homePage') {
                unlockAchievement(1);
            } else if (pageId === 'minesweeperPage') {
                commandsUsed.add('sweeper');
            } else if (pageId === 'pongPage') {
                unlockAchievement(5);
                commandsUsed.add('pong');
            } else if (pageId === 'sandboxelsPage') {
                unlockAchievement(10);
                commandsUsed.add('sandboxles');
            } else if (pageId === 'coinflipPage') {
                commandsUsed.add('coinflip');
            } else if (pageId === 'clickerPage') {
                commandsUsed.add('clicker');
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            } else if (pageId === 'stonesPage') {
                commandsUsed.add('stones');
            }
            
            if (commandsUsed.size >= 10) {
                unlockAchievement(11);
            }
        };
        
        // Track Minesweeper win
        const originalGameOver = gameOver;
        gameOver = function(win) {
            originalGameOver(win);
            if (win) {
                unlockAchievement(4);
            }
        };
        
        // Track coinflip achievements - hook into guessCoin function
        let coinflipWins = 0;
        const originalGuessCoinFunc = guessCoin;
        guessCoin = function(guess) {
            const oldStreak = coinflipStreak;
            originalGuessCoinFunc(guess);
            
            // Check achievements after the coin flip completes
            setTimeout(() => {
                if (coinflipStreak > oldStreak) {
                    coinflipWins++;
                    if (coinflipStreak >= 5) unlockAchievement(6);
                    if (coinflipWins >= 10 && coinflipStreak >= 10) unlockAchievement(8);
                }
                
                if (globalMoney >= 100) unlockAchievement(7);
            }, 1500);
        };
        
        // Track shop upgrades - hook into buyUpgrade function
        const originalBuyUpgradeFunc = buyUpgrade;
        buyUpgrade = function() {
            originalBuyUpgradeFunc();
            setTimeout(() => {
                if (winChanceUpgrades >= 5) {
                    unlockAchievement(9);
                }
            }, 100);
        };
        
        // Changelog system
        function loadChangelog() {
            const changelogContent = document.getElementById('changelog-content');
            if (!changelogContent) return;
            
            const changelog = getChangelogEntries();
            let html = '';
            
            // Sort by date (newest first)
            const sortedChangelog = changelog.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            sortedChangelog.forEach(entry => {
                html += `
                    <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #30363d;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 style="color: #58a6ff; font-size: 18px; margin: 0;">${entry.title}</h3>
                            <span style="color: #8b949e; font-size: 12px;">${entry.date}</span>
                        </div>
                        <p style="color: #c9d1d9; font-size: 14px; margin: 5px 0;">${entry.description}</p>
                        ${entry.userRequest ? `<p style="color: #8b949e; font-size: 12px; font-style: italic; margin-top: 5px;">User Request: "${entry.userRequest}"</p>` : ''}
                    </div>
                `;
            });
            
            changelogContent.innerHTML = html || '<p style="color: #8b949e;">No changelog entries yet.</p>';
        }
        
        function getChangelogEntries() {
            const saved = localStorage.getItem('changelog');
            if (saved) {
                const entries = JSON.parse(saved);
                // Check if Block Breaker entry already exists
                const hasBlockBreaker = entries.some(e => e.title && e.title.includes('Block Breaker'));
                if (!hasBlockBreaker) {
                    // Add Block Breaker entry
                    entries.push({
                        date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                        title: ' Added Block Breaker Game to Desktop',
                        description: 'Added a classic Block Breaker (Breakout) game to the Remote Desktop App Store. Break all the blocks using the paddle to bounce the ball. Features 5 rows of colored blocks, 3 lives, and score tracking. Install it from the App Store in Remote Desktop, then double-click the Block Breaker icon to play. Use mouse or arrow keys to control the paddle.',
                        userRequest: 'add block breaker as a app'
                    });
                    localStorage.setItem('changelog', JSON.stringify(entries));
                }
                // Check if Chatbot entry already exists
                const hasChatbot = entries.some(e => e.title && e.title.includes('Chatbot'));
                const hasBlockBreakerUpdate = entries.some(e => e.title && e.title.includes('Block Breaker improvements'));
                if (!hasChatbot || !hasBlockBreakerUpdate) {
                    // Add Block Breaker improvements
                    if (!hasBlockBreakerUpdate) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: ' Block Breaker Game Improvements',
                            description: 'Made the ball slower (speed reduced from 4 to 2) and more visible (increased size from 8 to 12 pixels, changed color to bright yellow with white border). The ball is now easier to track and control.',
                            userRequest: 'make the ball slower and I cant see the ball mover'
                        });
                    }
                    // Add Chatbot entry
                    if (!hasChatbot) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: ' Added Chatbot App to Desktop',
                            description: 'Added a Chatbot app to the Remote Desktop App Store. The chatbot responds to every message with "sorry i dont understand mabey try again later". Install it from the App Store in Remote Desktop, then double-click the Chatbot icon to chat.',
                            userRequest: 'make another one thats called chatbot and every time it responds by saying sorry i dont understand mabey try again later'
                        });
                    }
                    localStorage.setItem('changelog', JSON.stringify(entries));
                }
                return entries;
            }
            // Initialize with Snake game entry
            const initialEntries = [{
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                title: ' Added Snake Game to Desktop',
                description: 'Added a classic Snake game to the Remote Desktop App Store. The game features a 16x16 grid with a black snake and 3 red apples. Install it from the App Store in Remote Desktop, then double-click the Snake icon to play. Use arrow keys to control the snake.',
                userRequest: 'Add a classic snake game for the desktop section where it\'s a 16x16 and there is 3 red boxes (apples) and you black'
            }];
            localStorage.setItem('changelog', JSON.stringify(initialEntries));
            return initialEntries;
        }
        
        function addChangelogEntry(title, description, userRequest = '') {
            const entries = getChangelogEntries();
            entries.push({
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                title: title,
                description: description,
                userRequest: userRequest
            });
            localStorage.setItem('changelog', JSON.stringify(entries));
            
            // Reload changelog if the page is currently open
            const changelogPage = document.getElementById('changelogPage');
            if (changelogPage && !changelogPage.classList.contains('hidden')) {
                loadChangelog();
            }
        }
        
        // Initialize changelog on page load if it doesn't exist
        getChangelogEntries();
    </script>
</body>
</html>
