<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clever | Portal</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%234169E1'/%3E%3Ctext x='50' y='75' font-size='70' font-weight='bold' font-family='Arial, sans-serif' text-anchor='middle' fill='white' filter='url(%23glow)'%3EC%3C/text%3E%3Cdefs%3E%3Cfilter id='glow'%3E%3CfeGaussianBlur stdDeviation='3' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3C/svg%3E">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #0d1117;
            min-height: 100vh;
            padding: 20px;
        }
        
        .page {
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .page.hidden {
            display: none;
        }
        
        .home-page {
            text-align: center;
        }
        
        .home-page h1 {
            color: #c9d1d9;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .home-page p {
            color: #8b949e;
            font-size: 18px;
        }
        
        .home-page a {
            color: #58a6ff;
            text-decoration: none;
            font-size: 20px;
            margin-top: 20px;
            display: inline-block;
            padding: 12px 24px;
            border: 1px solid #58a6ff;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .home-page a:hover {
            background: rgba(88, 166, 255, 0.1);
            color: #79c0ff;
            transform: translateY(-2px);
        }
        
        /* Minesweeper game styles */
        .minesweeper-page {
            background-color: #eee;
            font-family: Arial, sans-serif;
        }
        
        #minesweeper-game-container {
            display: inline-block;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
        }
        
        .minesweeper-grid {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
        }
        
        .cell {
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            background-color: #d1d1d1;
            border: 1px solid transparent;
            border-color: #fff #808080 #808080 #fff;
        }
        
        .cell.revealed {
            background-color: #c0c0c0;
            border: 1px solid #808080;
            border-color: #808080 #fff #fff #808080;
        }
        
        .cell.flag {
            color: red;
            font-size: 18px;
        }
        
        .cell.mine {
            background-color: red;
            color: black;
        }
        
        .cell.number-1 { color: blue; }
        .cell.number-2 { color: green; }
        .cell.number-3 { color: red; }
        .cell.number-4 { color: darkblue; }
        .cell.number-5 { color: darkred; }
        .cell.number-6 { color: teal; }
        .cell.number-7 { color: black; }
        .cell.number-8 { color: gray; }
        
        #message {
            margin-top: 5px;
            font-size: 20px;
            font-weight: bold;
            height: 25px;
            color: #333;
        }
        
        #restart-btn {
            padding: 8px 15px;
            margin-bottom: 15px;
            font-size: 16px;
            cursor: pointer;
            border: 4px solid #c0c0c0;
            border-top: 4px solid #fff;
            border-left: 4px solid #fff;
            background-color: #d1d1d1;
            font-weight: bold;
        }
        
        #restart-btn:active {
            border-top: 4px solid #808080;
            border-left: 4px solid #808080;
            border-bottom: 4px solid #fff;
            border-right: 4px solid #fff;
        }
        
        /* Pong game styles */
        .pong-page {
            background-color: #1a1a1a;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            color: white;
        }
        
        #pongCanvas {
            border: 4px solid #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            background-color: #000;
        }
        
        .pong-info {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .pong-button-style {
            transition: all 0.1s;
            box-shadow: 0 4px #2c2c2c;
            position: relative;
            top: 0;
        }
        
        .pong-button-style:active {
            box-shadow: 0 0 #2c2c2c;
            top: 4px;
        }
        
        .pong-settings-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .pong-settings-modal.hidden {
            display: none;
        }
        
        .pong-settings-content {
            background: #1f2937;
            padding: 24px;
            border-radius: 12px; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 320px;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content h3 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
            color: white;
            text-align: center;
        }
        
        .pong-settings-content label {
            display: block;
            color: #e5e7eb;
            margin-bottom: 4px;
        }
        
        .pong-settings-content select,
        .pong-settings-content input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: #111827;
            color: white;
            border: 1px solid #4b5563;
        }
        
        .pong-settings-content select:focus,
        .pong-settings-content input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 1px white;
        }
        
        .pong-settings-content button {
            width: 100%;
            margin-top: 16px;
        }
        
        /* Sandboxels page styles */
        .sandboxels-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            background-color: white;
            border: none;
            display: flex;
            flex-direction: column;
        }
        
        .sandboxels-iframe {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            padding: 0;
        }
        
        .sandboxels-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100000;
            padding: 10px 15px;
            background-color: #d9534f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .sandboxels-close-btn:hover {
            background-color: #c9302c;
        }
        
        /* Coinflip page styles */
        .coinflip-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        .coinflip-page button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .coinflip-page button:active {
            transform: scale(0.95);
        }
        
        @keyframes coinFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(900deg); }
            100% { transform: rotateY(1800deg); }
        }
        
        .coin-flipping {
            animation: coinFlip 1s ease-in-out;
        }
        
        /* Jumpscare overlay */
        .jumpscare-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
        }
        
        .jumpscare-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .jumpscare-overlay.active .jumpscare-image {
            animation: jumpscarePop 0.3s ease-out, jumpscareFade 0.5s ease-in 0.8s forwards;
        }
        
        .jumpscare-image {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            object-fit: contain;
            transform: scale(0.1);
            opacity: 0;
        }
        
        @keyframes jumpscarePop {
            0% {
                transform: scale(0.1);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes jumpscareFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.9);
            }
        }
        
        /* Shop page styles */
        .shop-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .upgrade-item {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 20px;
            margin: 15px auto;
            max-width: 400px;
            color: #c9d1d9;
        }
        
        .upgrade-item h3 {
            color: #58a6ff;
            margin: 0 0 10px 0;
            font-size: 20px;
        }
        
        .upgrade-item p {
            margin: 5px 0;
            font-size: 14px;
            color: #8b949e;
        }
        
        .upgrade-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            background: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .upgrade-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
        }
        
        .upgrade-btn:disabled {
            background: #30363d;
            color: #8b949e;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Limbo page styles */
        .limbo-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Panic menu page styles */
        .panicmenu-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        /* Achievements page styles */
        .achievements-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: #0d1117;
            padding: 40px 20px;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            grid-template-rows: repeat(16, 32px);
            gap: 4px;
            background: #161b22;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #30363d;
            margin: 20px auto;
            max-width: fit-content;
        }
        
        .achievement-sprite {
            width: 32px;
            height: 32px;
            border: 2px solid #30363d;
            border-radius: 4px;
            background: #21262d;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: grid;
            grid-template-columns: repeat(16, 2px);
            grid-template-rows: repeat(16, 2px);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            filter: grayscale(100%) brightness(0.3);
        }
        
        .achievement-sprite.found {
            filter: none;
            border-color: #58a6ff;
            background: #161b22;
        }
        
        .pixel {
            width: 2px;
            height: 2px;
        }
        
        /* Clicker page styles */
        .clicker-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #0d1117;
        }
        
        #clicker-button:active {
            transform: scale(0.95);
        }
        
        #clicker-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(35, 134, 54, 0.5);
        }
        
        .achievement-sprite:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.5);
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .achievement-sprite:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-tooltip .tooltip-name {
            font-weight: bold;
            color: #58a6ff;
            margin-bottom: 4px;
            display: block;
        }
        
        .achievement-tooltip .tooltip-desc {
            color: #8b949e;
            font-size: 11px;
            white-space: normal;
            max-width: 200px;
            text-align: left;
        }
        
        .finhub-title {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .big-letter {
            display: grid;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            color: #c9d1d9;
            gap: 0;
        }
        
        .big-letter .small-letter {
            display: inline-block;
            width: 8px;
            height: 8px;
            text-align: center;
        }
        
        /* Big F made of small letters - 3 thick, 2x tall */
        .letter-f {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big i made of small letters - 3 thick, 2x tall */
        .letter-i {
            grid-template-columns: repeat(9, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big n made of small letters - 3 thick, 2x tall */
        .letter-n {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big H made of small letters - 3 thick, 2x tall */
        .letter-h {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big u made of small letters - 3 thick, 2x tall */
        .letter-u {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Big b made of small letters - 3 thick, 2x tall */
        .letter-b {
            grid-template-columns: repeat(21, 8px);
            grid-template-rows: repeat(20, 8px);
        }
        
        /* Colors for small letters */
        .small-letter.f { color: #58a6ff; }
        .small-letter.i { color: #f0883e; }
        .small-letter.n { color: #bc8cff; }
        .small-letter.l { color: #3fb950; }
        .small-letter.e { color: #f85149; }
        .small-letter.y { color: #ffa657; }
        
        .subtitle {
            color: #8b949e;
            font-size: 18px;
            text-align: center;
            margin-top: 20px;
        }
        
        .letters-source {
            color: #6e7681;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        /* Profile display in top left */
        .profile-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 15px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
            min-width: 150px;
        }
        
        .profile-display:hover {
            background: rgba(22, 27, 34, 0.95);
            border-color: #58a6ff;
        }
        
        .profile-display .profile-username {
            font-weight: bold;
            color: #58a6ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .profile-display .profile-username::before {
            content: 'ðŸ‘¤';
            font-size: 16px;
        }
        
        .profile-display .profile-admin-badge {
            background: #f85149;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: bold;
        }
        
        .profile-menu {
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            background: rgba(13, 17, 23, 0.98);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 5px 0;
            min-width: 180px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 1001;
        }
        
        .profile-menu.show {
            display: block;
        }
        
        .profile-menu-item {
            padding: 10px 15px;
            color: #c9d1d9;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }
        
        .profile-menu-item:hover {
            background: rgba(48, 54, 61, 0.5);
        }
        
        .profile-menu-item.logout {
            color: #f85149;
        }
        
        .profile-menu-item.logout:hover {
            background: rgba(248, 81, 73, 0.1);
        }
        
        /* Clock display in top left */
        .clock-display {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 15px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .clock-display.hidden {
            display: none;
        }
        
        /* Command feedback display */
        .command-feedback {
            position: fixed;
            bottom: 70px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 400px;
            z-index: 998;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .command-feedback.hidden {
            display: none;
        }
        
        .command-feedback .command-text {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-feedback .feedback-text {
            color: #8b949e;
            margin-left: 8px;
        }
        
        .command-feedback.success {
            border-color: #3fb950;
        }
        
        .command-feedback.success .command-text {
            color: #3fb950;
        }
        
        .command-feedback.error {
            border-color: #f85149;
        }
        
        .command-feedback.error .command-text,
        .command-feedback.error .feedback-text {
            color: #f85149;
        }
        
        /* Terms and Agreements Modal */
        .terms-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .terms-modal.show {
            display: flex;
        }
        
        .terms-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .terms-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .terms-text {
            line-height: 1.8;
            margin-bottom: 25px;
        }
        
        .terms-text p {
            margin-bottom: 15px;
        }
        
        .terms-text ul {
            margin: 15px 0;
            padding-left: 25px;
        }
        
        .terms-text li {
            margin-bottom: 10px;
        }
        
        .terms-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .terms-agree-btn,
        .terms-disagree-btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .terms-agree-btn {
            background: #238636;
            color: white;
        }
        
        .terms-agree-btn:hover {
            background: #2ea043;
        }
        
        .terms-disagree-btn {
            background: #30363d;
            color: #c9d1d9;
        }
        
        .terms-disagree-btn:hover {
            background: #484f58;
        }
        
        /* Edit Profile Modal */
        .edit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .edit-modal.show {
            display: flex;
        }
        
        .edit-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .edit-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 25px;
            font-size: 24px;
        }
        
        .edit-field {
            margin-bottom: 20px;
        }
        
        .edit-field label {
            display: block;
            color: #c9d1d9;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .edit-field input,
        .edit-field textarea {
            width: 100%;
            padding: 10px 15px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        .edit-field input:focus,
        .edit-field textarea:focus {
            outline: none;
            border-color: #58a6ff;
        }
        
        .edit-field textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .edit-field small {
            display: block;
            color: #8b949e;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .emoji-picker {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .emoji-preview {
            width: 80px;
            height: 80px;
            background: #0d1117;
            border: 2px solid #30363d;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .emoji-preview:hover {
            border-color: #58a6ff;
            transform: scale(1.1);
        }
        
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
        }
        
        .emoji-option {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            background: transparent;
            border: 1px solid transparent;
        }
        
        .emoji-option:hover {
            background: #21262d;
            border-color: #58a6ff;
            transform: scale(1.2);
        }
        
        .emoji-option.selected {
            background: #1f6feb;
            border-color: #58a6ff;
        }
        
        .edit-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 25px;
        }
        
        .edit-save-btn,
        .edit-cancel-btn {
            padding: 10px 25px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-save-btn {
            background: #238636;
            color: white;
        }
        
        .edit-save-btn:hover {
            background: #2ea043;
        }
        
        .edit-cancel-btn {
            background: #30363d;
            color: #c9d1d9;
        }
        
        .edit-cancel-btn:hover {
            background: #484f58;
        }
        
        /* Command History Display */
        .command-history {
            position: fixed;
            bottom: 110px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 500px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 997;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: none;
        }
        
        .command-history.visible {
            display: block;
        }
        
        /* Chat Page Styles */
        .chat-container {
            width: 90%;
            max-width: 900px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .chat-header {
            padding: 15px 20px;
            background: #161b22;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-header h2 {
            color: #c9d1d9;
            font-size: 20px;
            margin: 0;
        }
        
        .online-users {
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .online-users-title {
            color: #58a6ff;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }
        
        .online-user-item {
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(48, 54, 61, 0.5);
            border-radius: 4px;
            cursor: pointer;
            color: #c9d1d9;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .online-user-item:hover {
            background: rgba(48, 54, 61, 0.8);
        }
        
        .online-user-item .user-id {
            font-weight: bold;
            color: #58a6ff;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #0d1117;
        }
        
        .chat-message {
            margin-bottom: 15px;
            padding: 10px 15px;
            background: rgba(22, 27, 34, 0.8);
            border-left: 3px solid #58a6ff;
            border-radius: 6px;
        }
        
        .chat-message.own-message {
            border-left-color: #3fb950;
            background: rgba(13, 17, 23, 0.9);
        }
        
        .chat-message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .chat-message-user {
            font-weight: bold;
            color: #58a6ff;
            font-size: 13px;
            cursor: pointer;
        }
        
        .chat-message.own-message .chat-message-user {
            color: #3fb950;
        }
        
        .chat-message-time {
            color: #8b949e;
            font-size: 11px;
        }
        
        .chat-message-text {
            color: #c9d1d9;
            font-size: 14px;
            word-wrap: break-word;
        }
        
        .chat-input-container {
            display: flex;
            padding: 15px 20px;
            background: #161b22;
            border-top: 1px solid #30363d;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px 15px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 14px;
            font-family: inherit;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #58a6ff;
        }
        
        .chat-send-btn {
            padding: 10px 20px;
            background: #238636;
            border: 1px solid #2ea043;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .chat-send-btn:hover {
            background: #2ea043;
        }
        
        .chat-send-btn:disabled {
            background: #30363d;
            border-color: #30363d;
            cursor: not-allowed;
        }
        
        .chat-back-btn {
            padding: 8px 15px;
            background: #30363d;
            border: 1px solid #484f58;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-back-btn:hover {
            background: #484f58;
        }
        
        /* Friends Modal */
        .friends-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .friends-modal.show {
            display: flex;
        }
        
        .friends-modal-content {
            background: #161b22;
            border: 2px solid #30363d;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #c9d1d9;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .friends-modal-content h2 {
            color: #58a6ff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .friends-list {
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .friend-item {
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid #30363d;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .friend-item:hover {
            background: rgba(22, 27, 34, 0.9);
            border-color: #58a6ff;
            transform: translateX(5px);
        }
        
        .friend-avatar {
            font-size: 32px;
        }
        
        .friend-info {
            flex: 1;
        }
        
        .friend-name {
            font-weight: bold;
            color: #58a6ff;
            font-size: 14px;
        }
        
        .friend-bio {
            color: #8b949e;
            font-size: 12px;
            margin-top: 2px;
        }
        
        .friends-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
        }
        
        .friends-close-btn {
            padding: 10px 25px;
            background: #30363d;
            border: none;
            border-radius: 6px;
            color: #c9d1d9;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .friends-close-btn:hover {
            background: #484f58;
        }
        
        /* Visit Counter */
        .visit-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 2px solid #58a6ff;
            border-radius: 12px;
            padding: 15px 20px;
            z-index: 998;
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.3);
            text-align: center;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 20px rgba(88, 166, 255, 0.3);
            }
            50% {
                box-shadow: 0 4px 30px rgba(88, 166, 255, 0.6), 0 0 40px rgba(88, 166, 255, 0.3);
            }
        }
        
        .visit-counter-number {
            font-size: 32px;
            font-weight: bold;
            color: #58a6ff;
            text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% {
                text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            }
            50% {
                text-shadow: 0 0 20px rgba(88, 166, 255, 0.8), 0 0 30px rgba(88, 166, 255, 0.4);
            }
        }
        
        .visit-counter-label {
            font-size: 11px;
            color: #8b949e;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .command-history-header {
            color: #58a6ff;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #30363d;
            font-size: 12px;
        }
        
        .command-history-entry {
            margin-bottom: 6px;
            padding: 4px 0;
            line-height: 1.4;
        }
        
        .command-history-entry .command-text {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-history-entry .feedback-text {
            color: #8b949e;
            margin-left: 8px;
        }
        
        .command-history-entry.success .command-text,
        .command-history-entry.success .feedback-text {
            color: #3fb950;
        }
        
        .command-history-entry.error .command-text,
        .command-history-entry.error .feedback-text {
            color: #f85149;
        }
        
        .command-history-toggle {
            position: fixed;
            bottom: 70px;
            left: 420px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 4px 8px;
            color: #8b949e;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            z-index: 996;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            user-select: none;
        }
        
        .command-history-toggle:hover {
            color: #c9d1d9;
            border-color: #58a6ff;
        }
        
        @media (max-width: 768px) {
            .command-history-toggle {
                left: 20px;
                bottom: 110px;
            }
        }
        
        /* Command bar in bottom left */
        .command-bar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        
        .command-bar::before {
            content: '>';
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-input {
            background: transparent;
            border: none;
            outline: none;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex: 1;
        }
        
        .command-input::placeholder {
            color: #6e7681;
        }
        
        /* Commands menu - draggable tab */
        .commands-menu {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            right: -300px;
            width: 300px;
            max-height: 500px;
            background: rgba(13, 17, 23, 0.98);
            border: 1px solid #30363d;
            border-right: none;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .commands-menu.open {
            right: 0;
        }
        
        .commands-menu.dragging {
            transform: none;
            transition: none;
        }
        
        .commands-menu-header {
            background: #161b22;
            padding: 12px 16px;
            border-bottom: 1px solid #30363d;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .commands-menu-header h3 {
            color: #c9d1d9;
            font-size: 16px;
            margin: 0;
        }
        
        .commands-menu-close {
            background: none;
            border: none;
            color: #8b949e;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .commands-menu-close:hover {
            color: #c9d1d9;
        }
        
        .commands-list {
            padding: 16px;
        }
        
        .command-category {
            margin-bottom: 20px;
        }
        
        .command-category h4 {
            color: #58a6ff;
            font-size: 14px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .command-item {
            color: #c9d1d9;
            font-size: 13px;
            padding: 6px 0;
            font-family: 'Courier New', monospace;
        }
        
        .command-item .command-name {
            color: #58a6ff;
            font-weight: bold;
        }
        
        .command-item .command-desc {
            color: #8b949e;
            margin-left: 8px;
        }
        
        @media (max-width: 768px) {
            .finhub-title {
                font-size: 48px;
            }
            .command-bar {
                min-width: 200px;
                bottom: 10px;
                left: 10px;
            }
            .commands-menu {
                width: 250px;
                right: -250px;
            }
        }

/* Theme System Styles */
body.theme-1995 {
    font-family: 'MS Sans Serif', 'MS Sans Serif', sans-serif;
    background: #c0c0c0 !important;
    color: #000000;
}

body.theme-1995 .command-bar,
body.theme-1995 .clock-display,
body.theme-1995 .command-feedback,
body.theme-1995 .commands-menu {
    background: #c0c0c0 !important;
    border: 2px outset #c0c0c0 !important;
    box-shadow: inset -1px -1px 0px 0px #808080, inset 1px 1px 0px 0px #ffffff !important;
}

body.theme-1995 .command-input {
    background: #ffffff !important;
    border: 1px inset #c0c0c0 !important;
    color: #000000 !important;
}

body.theme-1995 .page {
    background: #c0c0c0 !important;
}

body.theme-1995 .home-page h1,
body.theme-1995 .subtitle,
body.theme-1995 .letters-source {
    color: #000000 !important;
}

body.theme-1995 button {
    background: #c0c0c0 !important;
    border: 2px outset #c0c0c0 !important;
    color: #000000 !important;
    font-family: 'MS Sans Serif', sans-serif !important;
}

body.theme-1995 button:active {
    border: 2px inset #c0c0c0 !important;
}

body.theme-cyberpunk {
    font-family: 'Orbitron', 'Courier New', monospace;
    background: #0a0a0f !important;
    color: #ff00ff;
    position: relative;
}

body.theme-cyberpunk::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        linear-gradient(90deg, rgba(0, 255, 255, 0.03) 50%, transparent 50%),
        linear-gradient(rgba(255, 0, 255, 0.03) 50%, transparent 50%);
    background-size: 4px 4px;
    pointer-events: none;
    z-index: 1;
}

body.theme-cyberpunk * {
    text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
}

body.theme-cyberpunk .command-bar,
body.theme-cyberpunk .clock-display,
body.theme-cyberpunk .command-feedback,
body.theme-cyberpunk .commands-menu {
    background: rgba(10, 10, 15, 0.95) !important;
    border: 2px solid #00ffff !important;
    box-shadow: 0 0 20px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1) !important;
    color: #ff00ff !important;
}

body.theme-cyberpunk .command-input {
    background: rgba(10, 10, 15, 0.8) !important;
    border: 1px solid #ff00ff !important;
    color: #00ffff !important;
    text-shadow: 0 0 5px #00ffff !important;
}

body.theme-cyberpunk .command-bar::before {
    color: #ff00ff !important;
    text-shadow: 0 0 10px #ff00ff !important;
}

body.theme-cyberpunk .page {
    background: #0a0a0f !important;
}

body.theme-cyberpunk .home-page h1 {
    color: #ff00ff !important;
    text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff !important;
}

body.theme-cyberpunk .subtitle {
    color: #00ffff !important;
    text-shadow: 0 0 10px #00ffff !important;
}

body.theme-cyberpunk button {
    background: rgba(10, 10, 15, 0.9) !important;
    border: 2px solid #ff00ff !important;
    color: #00ffff !important;
    text-shadow: 0 0 10px #00ffff !important;
    box-shadow: 0 0 20px rgba(255, 0, 255, 0.5) !important;
}

body.theme-cyberpunk button:hover {
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.8) !important;
    border-color: #00ffff !important;
}

@keyframes glitch {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-2px, 2px); }
    40% { transform: translate(-2px, -2px); }
    60% { transform: translate(2px, 2px); }
    80% { transform: translate(2px, -2px); }
}

body.theme-cyberpunk .finhub-title {
    animation: glitch 0.3s infinite;
}

body.theme-terminal {
    font-family: 'Courier New', monospace;
    background: #000000 !important;
    color: #00ff00;
    position: relative;
}

body.theme-terminal::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
        0deg,
        rgba(0, 255, 0, 0.03),
        rgba(0, 255, 0, 0.03) 1px,
        transparent 1px,
        transparent 2px
    );
    pointer-events: none;
    z-index: 1;
    animation: scanline 8s linear infinite;
}

@keyframes scanline {
    0% { transform: translateY(0); }
    100% { transform: translateY(100vh); }
}

body.theme-terminal .command-bar,
body.theme-terminal .clock-display,
body.theme-terminal .command-feedback,
body.theme-terminal .commands-menu {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 1px solid #00ff00 !important;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5), inset 0 0 10px rgba(0, 255, 0, 0.1) !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .command-input {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid #00ff00 !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .command-bar::before {
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
}

body.theme-terminal .page {
    background: #000000 !important;
}

body.theme-terminal .home-page h1,
body.theme-terminal .subtitle,
body.theme-terminal .letters-source {
    color: #00ff00 !important;
    text-shadow: 0 0 10px #00ff00 !important;
}

body.theme-terminal button {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 1px solid #00ff00 !important;
    color: #00ff00 !important;
    text-shadow: 0 0 5px #00ff00 !important;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.3) !important;
}

body.theme-terminal button:hover {
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.6) !important;
}

body.theme-matrix {
    font-family: 'Courier New', monospace;
    background: #000000 !important;
    color: #00ff41;
    position: relative;
    overflow: hidden;
}

body.theme-matrix .command-bar,
body.theme-matrix .clock-display,
body.theme-matrix .command-feedback,
body.theme-matrix .commands-menu {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 1px solid #00ff41 !important;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.5), inset 0 0 10px rgba(0, 255, 65, 0.1) !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .command-input {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid #00ff41 !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .command-bar::before {
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
}

body.theme-matrix .page {
    background: #000000 !important;
}

body.theme-matrix .home-page h1,
body.theme-matrix .subtitle,
body.theme-matrix .letters-source {
    color: #00ff41 !important;
    text-shadow: 0 0 10px #00ff41 !important;
}

body.theme-matrix button {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 1px solid #00ff41 !important;
    color: #00ff41 !important;
    text-shadow: 0 0 5px #00ff41 !important;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3) !important;
}

body.theme-matrix button:hover {
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.6) !important;
}

/* Matrix falling characters */
.matrix-column {
    position: fixed;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    color: #00ff41;
    text-shadow: 0 0 5px #00ff41;
    pointer-events: none;
    z-index: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
}

.matrix-column .char {
    position: absolute;
    display: block;
    opacity: 0;
    height: 18px;
    width: 20px;
    text-align: center;
    left: 0;
    animation: matrix-char-fall linear forwards;
}

.matrix-column .char.fade {
    opacity: 0.2;
}

.matrix-column .char.bright {
    opacity: 1;
    color: #ffffff;
    text-shadow: 0 0 10px #ffffff, 0 0 20px #00ff41;
}

@keyframes matrix-char-fall {
    0% {
        top: -20px;
        opacity: 0;
    }
    2% {
        opacity: 1;
    }
    98% {
        opacity: 1;
    }
    100% {
        top: calc(100vh + 20px);
        opacity: 0;
    }
}

body.theme-coffee {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #3e2723 !important;
    color: #d7ccc8;
    filter: sepia(30%) saturate(80%);
}

body.theme-coffee .command-bar,
body.theme-coffee .clock-display,
body.theme-coffee .command-feedback,
body.theme-coffee .commands-menu {
    background: rgba(94, 53, 45, 0.95) !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee .command-input {
    background: rgba(94, 53, 45, 0.8) !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee .page {
    background: #3e2723 !important;
}

body.theme-coffee .home-page h1,
body.theme-coffee .subtitle,
body.theme-coffee .letters-source {
    color: #d7ccc8 !important;
}

body.theme-coffee button {
    background: #5d4037 !important;
    border: 1px solid #8d6e63 !important;
    color: #d7ccc8 !important;
}

body.theme-coffee button:hover {
    background: #6d4c41 !important;
}

body.theme-light {
    background: #ffffff !important;
    color: #000000;
}

body.theme-light .command-bar,
body.theme-light .clock-display,
body.theme-light .command-feedback,
body.theme-light .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light .command-bar::before {
    color: #0066cc !important;
}

body.theme-light .page {
    background: #ffffff !important;
}

body.theme-light .home-page h1,
body.theme-light .subtitle,
body.theme-light .letters-source {
    color: #000000 !important;
}

body.theme-light button {
    background: #f5f5f5 !important;
    border: 1px solid #e0e0e0 !important;
    color: #000000 !important;
}

body.theme-light button:hover {
    background: #e8e8e8 !important;
}

body.theme-dark {
    background: #0d1117 !important;
    color: #c9d1d9;
}

body.theme-dark .command-bar,
body.theme-dark .clock-display,
body.theme-dark .command-feedback,
body.theme-dark .commands-menu {
    background: rgba(13, 17, 23, 0.95) !important;
    border: 1px solid #30363d !important;
    color: #c9d1d9 !important;
}

body.theme-dark .command-input {
    background: transparent !important;
    border: none !important;
    color: #c9d1d9 !important;
}

body.theme-dark .command-bar::before {
    color: #58a6ff !important;
}

body.theme-dark .page {
    background: #0d1117 !important;
}

body.theme-dark .home-page h1,
body.theme-dark .subtitle,
body.theme-dark .letters-source {
    color: #c9d1d9 !important;
}

body.theme-dark button {
    background: #238636 !important;
    border: none !important;
    color: #ffffff !important;
}

body.theme-paper {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px),
        repeating-linear-gradient(90deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
    color: #2c2c2c;
}

body.theme-paper .command-bar,
body.theme-paper .clock-display,
body.theme-paper .command-feedback,
body.theme-paper .commands-menu {
    background: rgba(245, 245, 220, 0.95) !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

body.theme-paper .command-input {
    background: rgba(255, 255, 255, 0.8) !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
}

body.theme-paper .command-bar::before {
    color: #8b4513 !important;
}

body.theme-paper .page {
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px),
        repeating-linear-gradient(90deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
}

body.theme-paper .home-page h1,
body.theme-paper .subtitle,
body.theme-paper .letters-source {
    color: #2c2c2c !important;
}

body.theme-paper button {
    background: #faf0e6 !important;
    border: 1px solid #d4a574 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

body.theme-paper button:hover {
    background: #f5e6d3 !important;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15) !important;
}

body.theme-space {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #000428 !important;
    background-image: 
        radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-space::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(2px 2px at 20% 30%, #fff, transparent),
        radial-gradient(2px 2px at 60% 70%, #fff, transparent),
        radial-gradient(1px 1px at 50% 50%, #fff, transparent),
        radial-gradient(1px 1px at 80% 10%, #fff, transparent),
        radial-gradient(2px 2px at 90% 40%, #fff, transparent),
        radial-gradient(1px 1px at 33% 60%, #fff, transparent),
        radial-gradient(1px 1px at 70% 80%, #fff, transparent);
    background-size: 200% 200%;
    background-position: 0% 0%;
    pointer-events: none;
    z-index: 1;
    animation: starfield 20s linear infinite;
}

@keyframes starfield {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
}

body.theme-space .command-bar,
body.theme-space .clock-display,
body.theme-space .command-feedback,
body.theme-space .commands-menu {
    background: rgba(0, 4, 40, 0.95) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 15px rgba(74, 144, 226, 0.3) !important;
}

body.theme-space .command-input {
    background: rgba(0, 4, 40, 0.8) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
}

body.theme-space .command-bar::before {
    color: #4a90e2 !important;
}

body.theme-space .page {
    background: #000428 !important;
    background-image: 
        radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
}

body.theme-space .home-page h1,
body.theme-space .subtitle,
body.theme-space .letters-source {
    color: #ffffff !important;
    text-shadow: 0 0 10px rgba(74, 144, 226, 0.5) !important;
}

body.theme-space button {
    background: rgba(0, 4, 40, 0.9) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 10px rgba(74, 144, 226, 0.3) !important;
}

body.theme-space button:hover {
    box-shadow: 0 0 20px rgba(74, 144, 226, 0.6) !important;
}

/* Space theme stars that react to cursor */
.space-star {
    position: fixed;
    width: 2px;
    height: 2px;
    background: #ffffff;
    border-radius: 50%;
    pointer-events: none;
    z-index: 1;
    box-shadow: 0 0 2px #fff;
    transition: transform 0.1s ease-out;
}

body.theme-ocean {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #1e3a5f 100%) !important;
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-ocean::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(255, 255, 255, 0.03) 2px,
            rgba(255, 255, 255, 0.03) 4px
        );
    pointer-events: none;
    z-index: 1;
    animation: oceanWave 3s ease-in-out infinite;
}

@keyframes oceanWave {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

body.theme-ocean .command-bar,
body.theme-ocean .clock-display,
body.theme-ocean .command-feedback,
body.theme-ocean .commands-menu {
    background: rgba(30, 58, 95, 0.95) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 15px rgba(74, 144, 226, 0.3) !important;
}

body.theme-ocean .command-input {
    background: rgba(30, 58, 95, 0.8) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
}

body.theme-ocean .command-bar::before {
    color: #87ceeb !important;
}

body.theme-ocean .page {
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 50%, #1e3a5f 100%) !important;
}

body.theme-ocean .home-page h1,
body.theme-ocean .subtitle,
body.theme-ocean .letters-source {
    color: #ffffff !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
}

body.theme-ocean button {
    background: rgba(30, 58, 95, 0.9) !important;
    border: 1px solid #4a90e2 !important;
    color: #ffffff !important;
    box-shadow: 0 0 10px rgba(74, 144, 226, 0.3) !important;
}

body.theme-ocean button:hover {
    box-shadow: 0 0 20px rgba(74, 144, 226, 0.6) !important;
}

/* Ocean theme fish */
.ocean-fish {
    position: fixed;
    pointer-events: none;
    z-index: 2;
    font-size: 30px;
    animation: fishSwim 15s linear infinite;
}

@keyframes fishSwim {
    0% {
        transform: translateX(-100px) translateY(0) scaleX(1);
    }
    49% {
        transform: translateX(calc(100vw + 100px)) translateY(0) scaleX(1);
    }
    50% {
        transform: translateX(calc(100vw + 100px)) translateY(0) scaleX(-1);
    }
    99% {
        transform: translateX(-100px) translateY(0) scaleX(-1);
    }
    100% {
        transform: translateX(-100px) translateY(0) scaleX(1);
    }
}

.ocean-fish.small {
    font-size: 20px;
    animation-duration: 12s;
}

.ocean-fish.medium {
    font-size: 30px;
    animation-duration: 15s;
}

.ocean-fish.large {
    font-size: 40px;
    animation-duration: 18s;
}

body.theme-clouds {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 50%, #B0E0E6 100%) !important;
    color: #2c3e50;
    position: relative;
    overflow: hidden;
}

body.theme-clouds .command-bar,
body.theme-clouds .clock-display,
body.theme-clouds .command-feedback,
body.theme-clouds .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

body.theme-clouds .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
}

body.theme-clouds .command-bar::before {
    color: #4682B4 !important;
}

body.theme-clouds .page {
    background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 50%, #B0E0E6 100%) !important;
}

body.theme-clouds .home-page h1,
body.theme-clouds .subtitle,
body.theme-clouds .letters-source {
    color: #2c3e50 !important;
    text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5) !important;
}

body.theme-clouds button {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 1px solid #b0c4de !important;
    color: #2c3e50 !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

body.theme-clouds button:hover {
    background: rgba(255, 255, 255, 1) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* Clouds theme - animated clouds */
.cloud {
    position: fixed;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50px;
    pointer-events: none;
    z-index: 1;
    opacity: 0.7;
    animation: cloudFloat 20s linear infinite;
}

@keyframes cloudFloat {
    0% {
        transform: translateX(-200px) translateY(0);
    }
    100% {
        transform: translateX(calc(100vw + 200px)) translateY(0);
    }
}

.cloud::before,
.cloud::after {
    content: '';
    position: absolute;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50px;
}

.cloud::before {
    width: 50px;
    height: 50px;
    top: -25px;
    left: 10px;
}

.cloud::after {
    width: 60px;
    height: 60px;
    top: -35px;
    right: 10px;
}

body.theme-flashcard {
    font-family: 'Georgia', 'Times New Roman', serif;
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
    color: #2c2c2c;
    position: relative;
}

body.theme-flashcard .command-bar,
body.theme-flashcard .clock-display,
body.theme-flashcard .command-feedback,
body.theme-flashcard .commands-menu {
    background: rgba(255, 255, 255, 0.95) !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
}

/* Minecraft Theme */
body.theme-minecraft {
    font-family: 'Press Start 2P', 'Courier New', monospace;
    background: #87CEEB !important;
    background-image: 
        linear-gradient(to bottom, #87CEEB 0%, #6AB0D9 40%, #5B9FD0 100%),
        repeating-linear-gradient(0deg, transparent, transparent 32px, rgba(0,0,0,0.03) 32px, rgba(0,0,0,0.03) 33px);
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-minecraft::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 40%;
    background: linear-gradient(to bottom, transparent, rgba(107, 142, 35, 0.3));
    pointer-events: none;
    z-index: 0;
}

body.theme-minecraft .command-bar,
body.theme-minecraft .clock-display,
body.theme-minecraft .command-feedback,
body.theme-minecraft .commands-menu {
    background: rgba(139, 90, 43, 0.95) !important;
    border: 4px solid #8b5a2b !important;
    border-style: outset !important;
    color: #ffffff !important;
    box-shadow: 
        inset -2px -2px 0 rgba(0,0,0,0.3),
        inset 2px 2px 0 rgba(255,255,255,0.3),
        0 0 10px rgba(0,0,0,0.5) !important;
}

body.theme-minecraft .command-input {
    background: rgba(101, 67, 33, 0.9) !important;
    border: 3px solid #654321 !important;
    border-style: inset !important;
    color: #ffffff !important;
    font-family: 'Press Start 2P', 'Courier New', monospace !important;
    font-size: 10px !important;
}

body.theme-minecraft .command-bar::before {
    color: #8b5a2b !important;
}

body.theme-minecraft .page {
    background: #87CEEB !important;
}

body.theme-minecraft .home-page h1,
body.theme-minecraft .subtitle,
body.theme-minecraft .letters-source {
    color: #ffffff !important;
    text-shadow: 
        2px 2px 0 #000000,
        -1px -1px 0 #000000,
        1px -1px 0 #000000,
        -1px 1px 0 #000000 !important;
}

body.theme-minecraft button {
    background: #8b5a2b !important;
    border: 4px solid #654321 !important;
    border-style: outset !important;
    color: #ffffff !important;
    font-family: 'Press Start 2P', 'Courier New', monospace !important;
    font-size: 10px !important;
    box-shadow: 
        inset -2px -2px 0 rgba(0,0,0,0.3),
        inset 2px 2px 0 rgba(255,255,255,0.3) !important;
}

body.theme-minecraft button:hover {
    background: #9d6a3b !important;
    box-shadow: 
        inset -2px -2px 0 rgba(0,0,0,0.2),
        inset 2px 2px 0 rgba(255,255,255,0.4) !important;
}

body.theme-minecraft button:active {
    border-style: inset !important;
    box-shadow: 
        inset 2px 2px 0 rgba(0,0,0,0.3),
        inset -2px -2px 0 rgba(255,255,255,0.3) !important;
}

/* Minecraft Explosion Effect */
.minecraft-explosion {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
}

.minecraft-explosion-particle {
    position: absolute;
    width: 8px;
    height: 8px;
    background: #ff4400;
    border: 2px solid #ff8800;
    border-radius: 2px;
    animation: minecraft-explode 0.6s ease-out forwards;
}

@keyframes minecraft-explode {
    0% {
        transform: scale(1) translate(0, 0);
        opacity: 1;
    }
    100% {
        transform: scale(0.3) translate(var(--dx), var(--dy));
        opacity: 0;
    }
}

/* Pirate Theme */
body.theme-pirate {
    font-family: 'Bangers', 'Arial Black', sans-serif;
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 30%, #1e3a5f 60%, #0d1b2a 100%) !important;
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-pirate::before {
    content: 'ðŸ´â€â˜ ï¸';
    position: fixed;
    top: 20px;
    right: 20px;
    font-size: 60px;
    opacity: 0.2;
    pointer-events: none;
    z-index: 0;
    animation: pirate-flag 3s ease-in-out infinite;
}

@keyframes pirate-flag {
    0%, 100% { transform: rotate(-5deg); }
    50% { transform: rotate(5deg); }
}

body.theme-pirate .command-bar,
body.theme-pirate .clock-display,
body.theme-pirate .command-feedback,
body.theme-pirate .commands-menu {
    background: rgba(139, 90, 43, 0.95) !important;
    border: 3px solid #8b5a2b !important;
    color: #ffffff !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
    font-family: 'Bangers', 'Arial Black', sans-serif !important;
}

body.theme-pirate .command-input {
    background: rgba(101, 67, 33, 0.9) !important;
    border: 2px solid #8b5a2b !important;
    color: #ffffff !important;
    font-family: 'Bangers', 'Arial Black', sans-serif !important;
}

body.theme-pirate .command-bar::before {
    content: 'âš“ ' !important;
    color: #ffd700 !important;
}

body.theme-pirate .page {
    background: linear-gradient(to bottom, #87CEEB 0%, #4682B4 30%, #1e3a5f 60%, #0d1b2a 100%) !important;
}

body.theme-pirate .home-page h1,
body.theme-pirate .subtitle,
body.theme-pirate .letters-source {
    color: #ffffff !important;
    text-shadow: 
        3px 3px 0 #000000,
        -1px -1px 0 #000000,
        1px -1px 0 #000000,
        -1px 1px 0 #000000 !important;
}

body.theme-pirate button {
    background: linear-gradient(to bottom, #d4af37, #b8860b) !important;
    border: 3px solid #8b5a2b !important;
    color: #000000 !important;
    font-family: 'Bangers', 'Arial Black', sans-serif !important;
    font-weight: bold !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
}

body.theme-pirate button:hover {
    background: linear-gradient(to bottom, #ffd700, #daa520) !important;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4) !important;
}

/* Firework Theme */
body.theme-firework {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #000000 !important;
    color: #ffffff;
    position: relative;
    overflow: hidden;
}

body.theme-firework .command-bar,
body.theme-firework .clock-display,
body.theme-firework .command-feedback,
body.theme-firework .commands-menu {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 2px solid #ffffff !important;
    color: #ffffff !important;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3) !important;
}

body.theme-firework .command-input {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 2px solid #ffffff !important;
    color: #ffffff !important;
}

body.theme-firework .command-bar::before {
    color: #ffffff !important;
}

body.theme-firework .page {
    background: #000000 !important;
}

body.theme-firework .home-page h1,
body.theme-firework .subtitle,
body.theme-firework .letters-source {
    color: #ffffff !important;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5) !important;
}

body.theme-firework button {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 2px solid #ffffff !important;
    color: #ffffff !important;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.3) !important;
}

body.theme-firework button:hover {
    background: rgba(20, 20, 20, 0.95) !important;
    box-shadow: 0 0 25px rgba(255, 255, 255, 0.5) !important;
}

/* MLG Theme */
body.theme-mlg {
    font-family: 'Impact', 'Arial Black', sans-serif;
    background: linear-gradient(135deg, #1a0033 0%, #330066 25%, #000000 50%, #330066 75%, #1a0033 100%) !important;
    background-size: 400% 400%;
    animation: mlg-gradient 5s ease infinite, mlg-crazy-shake 0.05s ease-in-out infinite !important;
    color: #00ff00;
    position: relative;
    overflow: hidden;
}

@keyframes mlg-crazy-shake {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    10% { transform: translate(-10px, -8px) rotate(-1deg); }
    20% { transform: translate(8px, 10px) rotate(1deg); }
    30% { transform: translate(-8px, 8px) rotate(-1deg); }
    40% { transform: translate(10px, -10px) rotate(1deg); }
    50% { transform: translate(-6px, -8px) rotate(-0.5deg); }
    60% { transform: translate(8px, 6px) rotate(0.5deg); }
    70% { transform: translate(-10px, 8px) rotate(-1deg); }
    80% { transform: translate(6px, -10px) rotate(1deg); }
    90% { transform: translate(-8px, -6px) rotate(-0.5deg); }
}

@keyframes mlg-gradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

body.theme-mlg::before {
    content: 'MLG';
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(45deg);
    font-size: 200px;
    font-weight: bold;
    color: rgba(0, 255, 0, 0.1);
    pointer-events: none;
    z-index: 0;
    animation: mlg-spin 3s linear infinite;
}

@keyframes mlg-spin {
    0% { transform: translate(-50%, -50%) rotate(45deg); }
    100% { transform: translate(-50%, -50%) rotate(405deg); }
}

body.theme-mlg .command-bar,
body.theme-mlg .clock-display,
body.theme-mlg .command-feedback,
body.theme-mlg .commands-menu {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 3px solid #00ff00 !important;
    color: #00ff00 !important;
    box-shadow: 
        0 0 20px #00ff00,
        inset 0 0 20px rgba(0, 255, 0, 0.2) !important;
    text-shadow: 0 0 10px #00ff00 !important;
    animation: mlg-pulse 1s ease-in-out infinite, mlg-crazy-shake 0.05s ease-in-out infinite !important;
}

@keyframes mlg-pulse {
    0%, 100% { box-shadow: 0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2); }
    50% { box-shadow: 0 0 40px #00ff00, inset 0 0 30px rgba(0, 255, 0, 0.4); }
}

body.theme-mlg .command-input {
    background: rgba(0, 0, 0, 0.9) !important;
    border: 2px solid #00ff00 !important;
    color: #00ff00 !important;
    text-shadow: 0 0 10px #00ff00 !important;
    font-family: 'Impact', 'Arial Black', sans-serif !important;
}

body.theme-mlg .command-bar::before {
    content: '> MLG ' !important;
    color: #00ff00 !important;
    text-shadow: 0 0 10px #00ff00 !important;
}

body.theme-mlg .page {
    background: linear-gradient(135deg, #1a0033 0%, #330066 25%, #000000 50%, #330066 75%, #1a0033 100%) !important;
    background-size: 400% 400%;
    animation: mlg-gradient 5s ease infinite;
}

body.theme-mlg .home-page h1,
body.theme-mlg .subtitle,
body.theme-mlg .letters-source {
    color: #00ff00 !important;
    text-shadow: 
        0 0 10px #00ff00,
        0 0 20px #00ff00,
        0 0 30px #00ff00 !important;
    animation: mlg-crazy-shake 0.05s ease-in-out infinite !important;
}

body.theme-mlg *:not(.mlg-emoji-rain):not(.mlg-airhorn):not(.mlg-oh-text):not(.mlg-dorito):not(.mlg-mountain-dew) {
    animation: mlg-crazy-shake 0.05s ease-in-out infinite !important;
}

body.theme-mlg button {
    background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%) !important;
    border: 3px solid #00ff00 !important;
    color: #000000 !important;
    font-family: 'Impact', 'Arial Black', sans-serif !important;
    font-weight: bold !important;
    text-shadow: none !important;
    box-shadow: 
        0 0 20px #00ff00,
        inset 0 0 10px rgba(0, 255, 0, 0.5) !important;
    animation: mlg-button-pulse 0.5s ease-in-out infinite, mlg-crazy-shake 0.05s ease-in-out infinite !important;
}

@keyframes mlg-button-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

body.theme-mlg button:hover {
    background: linear-gradient(135deg, #00ff00 0%, #33ff33 100%) !important;
    box-shadow: 
        0 0 40px #00ff00,
        inset 0 0 20px rgba(0, 255, 0, 0.7) !important;
    transform: scale(1.1) rotate(2deg);
}

/* MLG Effects */
.mlg-airhorn {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    font-size: 60px;
    font-weight: bold;
    color: #00ff00;
    text-shadow: 
        0 0 20px #00ff00,
        0 0 40px #00ff00,
        0 0 60px #00ff00;
    animation: mlg-airhorn-pop 0.5s ease-out forwards;
}

@keyframes mlg-airhorn-pop {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 1;
    }
    50% {
        transform: scale(1.5) rotate(180deg);
        opacity: 1;
    }
    100% {
        transform: scale(1) rotate(360deg);
        opacity: 0;
    }
}

.mlg-oh-text {
    position: fixed;
    pointer-events: none;
    z-index: 10001;
    font-size: 80px;
    font-weight: bold;
    color: #00ff00;
    text-shadow: 
        0 0 20px #00ff00,
        0 0 40px #00ff00,
        0 0 60px #00ff00,
        0 0 80px #00ff00;
    animation: mlg-oh-bounce 1s ease-out forwards;
    font-family: 'Impact', 'Arial Black', sans-serif;
}

@keyframes mlg-oh-bounce {
    0% {
        transform: translateY(-100px) scale(0);
        opacity: 0;
    }
    50% {
        transform: translateY(0) scale(1.2);
        opacity: 1;
    }
    100% {
        transform: translateY(100px) scale(0.8);
        opacity: 0;
    }
}

.mlg-dorito {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    font-size: 40px;
    animation: mlg-dorito-fly 2s linear forwards;
}

@keyframes mlg-dorito-fly {
    0% {
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--dx), var(--dy)) rotate(720deg) scale(0);
        opacity: 0;
    }
}

.mlg-mountain-dew {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    font-size: 40px;
    animation: mlg-dew-fly 2s linear forwards;
}

@keyframes mlg-dew-fly {
    0% {
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--dx), var(--dy)) rotate(-720deg) scale(0);
        opacity: 0;
    }
}

.mlg-emoji-rain {
    position: fixed;
    pointer-events: none;
    z-index: 9998;
    font-size: 30px;
    animation: mlg-emoji-fly 3s linear forwards;
}

@keyframes mlg-emoji-fly {
    0% {
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--dx), var(--dy)) rotate(720deg) scale(0);
        opacity: 0;
    }
}

/* Firework Elements */
.firework-rocket {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    font-size: 20px;
    color: #ffaa00;
    text-shadow: 0 0 10px #ffaa00;
    animation: firework-launch 1s ease-out forwards;
}

.firework-explosion {
    position: fixed;
    pointer-events: none;
    z-index: 10001;
    font-size: 80px;
    font-weight: bold;
    text-shadow: 
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor;
    animation: firework-explode 1.5s ease-out forwards;
}

.firework-particle {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: firework-particle 1.5s ease-out forwards;
}

@keyframes firework-launch {
    0% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-80vh) scale(0.5);
        opacity: 0;
    }
}

@keyframes firework-explode {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 1;
    }
    50% {
        transform: scale(1.2) rotate(180deg);
        opacity: 1;
    }
    100% {
        transform: scale(0.8) rotate(360deg);
        opacity: 0;
    }
}

@keyframes firework-particle {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--dx), var(--dy)) scale(0);
        opacity: 0;
    }
}

/* Pirate Cannonball */
.pirate-cannonball {
    position: fixed;
    width: 20px;
    height: 20px;
    background: radial-gradient(circle at 30% 30%, #cccccc, #333333);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    box-shadow: 
        inset -3px -3px 0 rgba(0,0,0,0.5),
        0 0 5px rgba(0,0,0,0.8);
    /* Animation is set dynamically in JavaScript */
}

@keyframes cannonball-fly-left {
    0% {
        left: -30px;
        top: var(--start-y);
        transform: translateY(-50%) rotate(0deg);
    }
    100% {
        left: calc(100vw + 30px);
        top: var(--start-y);
        transform: translateY(-50%) rotate(720deg);
    }
}

@keyframes cannonball-fly-right {
    0% {
        left: calc(100vw + 30px);
        top: var(--start-y);
        transform: translateY(-50%) rotate(0deg);
    }
    100% {
        left: -30px;
        top: var(--start-y);
        transform: translateY(-50%) rotate(-720deg);
    }
}

@keyframes cannonball-fly-up {
    0% {
        left: var(--start-x);
        top: calc(100vh + 30px);
        transform: translateX(-50%) rotate(0deg);
    }
    100% {
        left: var(--start-x);
        top: -30px;
        transform: translateX(-50%) rotate(720deg);
    }
}

@keyframes cannonball-fly-down {
    0% {
        left: var(--start-x);
        top: -30px;
        transform: translateX(-50%) rotate(0deg);
    }
    100% {
        left: var(--start-x);
        top: calc(100vh + 30px);
        transform: translateX(-50%) rotate(-720deg);
    }
}

@keyframes cannonball-fly-diagonal-tl-br {
    0% {
        left: -30px;
        top: -30px;
        transform: translate(-50%, -50%) rotate(0deg);
    }
    100% {
        left: calc(100vw + 30px);
        top: calc(100vh + 30px);
        transform: translate(-50%, -50%) rotate(720deg);
    }
}

@keyframes cannonball-fly-diagonal-tr-bl {
    0% {
        left: calc(100vw + 30px);
        top: -30px;
        transform: translate(-50%, -50%) rotate(0deg);
    }
    100% {
        left: -30px;
        top: calc(100vh + 30px);
        transform: translate(-50%, -50%) rotate(-720deg);
    }
}

@keyframes cannonball-fly-diagonal-bl-tr {
    0% {
        left: -30px;
        top: calc(100vh + 30px);
        transform: translate(-50%, -50%) rotate(0deg);
    }
    100% {
        left: calc(100vw + 30px);
        top: -30px;
        transform: translate(-50%, -50%) rotate(720deg);
    }
}

@keyframes cannonball-fly-diagonal-br-tl {
    0% {
        left: calc(100vw + 30px);
        top: calc(100vh + 30px);
        transform: translate(-50%, -50%) rotate(0deg);
    }
    100% {
        left: -30px;
        top: -30px;
        transform: translate(-50%, -50%) rotate(-720deg);
    }
}

body.theme-flashcard .command-input {
    background: rgba(255, 255, 255, 0.9) !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
}

body.theme-flashcard .command-bar::before {
    color: #8b4513 !important;
}

body.theme-flashcard .page {
    background: #f5f5dc !important;
    background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(0,0,0,.05) 31px, rgba(0,0,0,.05) 32px);
}

body.theme-flashcard .home-page h1,
body.theme-flashcard .subtitle,
body.theme-flashcard .letters-source {
    color: #2c2c2c !important;
}

body.theme-flashcard button {
    background: #fffef7 !important;
    border: 2px solid #8b7355 !important;
    color: #2c2c2c !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
}

body.theme-flashcard button:hover {
    background: #f5f5dc !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
}

/* Flashcard theme - interactive flashcards */
.flashcard {
    position: fixed;
    width: 300px;
    height: 200px;
    background: #fffef7;
    border: 3px solid #8b7355;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    padding: 20px;
    cursor: pointer;
    z-index: 10;
    font-family: 'Georgia', serif;
    font-size: 18px;
    color: #2c2c2c;
    overflow: hidden;
    resize: both;
    min-width: 200px;
    min-height: 150px;
}

.flashcard.dragging {
    opacity: 0.8;
    z-index: 1000;
}

.flashcard-header {
    font-weight: bold;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 2px solid #8b7355;
    user-select: none;
    cursor: move;
}

.flashcard-content {
    min-height: 100px;
    outline: none;
    overflow-y: auto;
}

.flashcard-close {
    position: absolute;
    top: 5px;
    right: 10px;
    background: #f85149;
    color: white;
    border: none;
    border-radius: 4px;
    width: 24px;
    height: 24px;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    z-index: 11;
}

.flashcard-close:hover {
    background: #d73a49;
}

/* Remote Desktop - Windows 95 style */
.desktop-icon {
    width: 80px;
    text-align: center;
    cursor: pointer;
    user-select: none;
    padding: 4px;
    margin: 4px;
    position: relative;
}

.desktop-icon:hover {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 2px;
}

.desktop-icon.selected {
    background: rgba(0, 0, 128, 0.3);
    border: 1px dashed #000080;
    border-radius: 2px;
}

.desktop-icon-icon {
    width: 32px;
    height: 32px;
    margin: 0 auto 4px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.desktop-icon-label {
    font-size: 11px;
    color: #fff;
    text-shadow: 1px 1px 1px #000;
    word-break: break-word;
    line-height: 1.2;
}

.context-menu {
    font-family: 'MS Sans Serif', Arial, sans-serif;
}

.context-menu-item {
    padding: 4px 20px;
    cursor: pointer;
    font-size: 11px;
    background: transparent;
    border: none;
    text-align: left;
    width: 100%;
}

.context-menu-item:hover {
    background: #000080;
    color: #fff;
}

.context-menu.hidden {
    display: none;
}

/* Windows 95 style windows */
.win95-window {
    position: fixed;
    background: #c0c0c0;
    border: 2px outset #c0c0c0;
    box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    z-index: 100;
    min-width: 300px;
    min-height: 200px;
    display: flex;
    flex-direction: column;
}

.win95-window-header {
    background: #000080;
    color: #fff;
    padding: 4px 8px;
    font-size: 11px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    user-select: none;
}

.win95-window-title {
    flex: 1;
}

.win95-window-controls {
    display: flex;
    gap: 2px;
}

.win95-window-button {
    width: 16px;
    height: 14px;
    background: #c0c0c0;
    border: 1px outset #c0c0c0;
    cursor: pointer;
    font-size: 10px;
    line-height: 12px;
    text-align: center;
    padding: 0;
}

.win95-window-button:hover {
    background: #d4d0c8;
}

.win95-window-button:active {
    border: 1px inset #c0c0c0;
}

.win95-window-content {
    flex: 1;
    background: #c0c0c0;
    padding: 8px;
    overflow: auto;
    border: 2px inset #c0c0c0;
}

.win95-window.minimized {
    display: none;
}

/* Paper app window */
.paper-app-content {
    background: #fff;
    width: 100%;
    height: 100%;
    padding: 10px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    border: 1px inset #c0c0c0;
    outline: none;
    overflow: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Paint app window */
.paint-app-content {
    background: #fff;
    width: 100%;
    height: 100%;
    border: 1px inset #c0c0c0;
    position: relative;
}

.paint-app-canvas {
    width: 100%;
    height: 100%;
    cursor: crosshair;
    display: block;
}

.paint-app-toolbar {
    background: #c0c0c0;
    border-bottom: 1px solid #808080;
    padding: 4px;
    display: flex;
    gap: 4px;
    align-items: center;
}

.paint-app-color-picker {
    width: 30px;
    height: 20px;
    border: 1px inset #c0c0c0;
    cursor: pointer;
}

.paint-app-brush-size {
    width: 60px;
    height: 20px;
    border: 1px inset #c0c0c0;
    font-size: 11px;
    padding: 0 4px;
}

/* Trash can drag over effect */
.trash-can-drag-over {
    background: rgba(255, 0, 0, 0.3) !important;
    border: 2px dashed #ff0000 !important;
}
    </style>
</head>
<body>
    <!-- Main page with FinHub title -->
    <!-- Login page (must be first, blocks all access) -->
    <div class="page login-page" id="loginPage" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #0d1117; color: #c9d1d9;">
        <div style="background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 40px; max-width: 400px; width: 100%; box-shadow: 0 8px 24px rgba(0,0,0,0.3);">
            <h1 style="color: #c9d1d9; font-size: 32px; margin-bottom: 10px; text-align: center;">Login</h1>
            <p style="color: #8b949e; font-size: 14px; margin-bottom: 30px; text-align: center;">You must login to access this website</p>
            <div id="loginError" style="color: #f85149; font-size: 14px; margin-bottom: 15px; min-height: 20px; text-align: center;"></div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 14px; display: block; margin-bottom: 8px;">Username:</label>
                <input type="text" id="loginUsername" placeholder="Enter username" style="width: 100%; padding: 12px; font-size: 16px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 14px; display: block; margin-bottom: 8px;">Password:</label>
                <input type="password" id="loginPassword" placeholder="Enter password" style="width: 100%; padding: 12px; font-size: 16px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; box-sizing: border-box;">
            </div>
            <button id="loginSubmitBtn" onclick="attemptLogin()" style="width: 100%; padding: 12px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 15px; transition: background 0.2s;">Login</button>
            <button id="registerBtn" onclick="showRegisterForm()" style="width: 100%; padding: 12px; font-size: 14px; background: transparent; color: #58a6ff; border: 1px solid #30363d; border-radius: 6px; cursor: pointer; transition: all 0.2s;">Create Account</button>
        </div>
        <!-- Register form (hidden by default) -->
        <div id="registerForm" style="display: none; background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 40px; max-width: 400px; width: 100%; box-shadow: 0 8px 24px rgba(0,0,0,0.3); margin-top: 20px;">
            <h2 style="color: #c9d1d9; font-size: 28px; margin-bottom: 10px; text-align: center;">Create Account</h2>
            <p style="color: #8b949e; font-size: 14px; margin-bottom: 30px; text-align: center;">Choose a unique username and password</p>
            <div id="registerError" style="color: #f85149; font-size: 14px; margin-bottom: 15px; min-height: 20px; text-align: center;"></div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 14px; display: block; margin-bottom: 8px;">Username (3-20 characters):</label>
                <input type="text" id="registerUsername" placeholder="Enter username" style="width: 100%; padding: 12px; font-size: 16px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 14px; display: block; margin-bottom: 8px;">Password (min 4 characters):</label>
                <input type="password" id="registerPassword" placeholder="Enter password" style="width: 100%; padding: 12px; font-size: 16px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 14px; display: block; margin-bottom: 8px;">Confirm Password:</label>
                <input type="password" id="registerPasswordConfirm" placeholder="Confirm password" style="width: 100%; padding: 12px; font-size: 16px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; box-sizing: border-box;">
            </div>
            <button id="registerSubmitBtn" onclick="attemptRegister()" style="width: 100%; padding: 12px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 15px;">Register</button>
            <button onclick="showLoginForm()" style="width: 100%; padding: 12px; font-size: 14px; background: transparent; color: #58a6ff; border: 1px solid #30363d; border-radius: 6px; cursor: pointer;">Back to Login</button>
        </div>
    </div>
    
    <div class="page hidden" id="mainPage">
        <div class="finhub-title">
            <!-- Big F made of small letters -->
            <div class="big-letter letter-f" id="letter-f"></div>
            <!-- Big i made of small letters -->
            <div class="big-letter letter-i" id="letter-i"></div>
            <!-- Big n made of small letters -->
            <div class="big-letter letter-n" id="letter-n"></div>
            <!-- Big H made of small letters -->
            <div class="big-letter letter-h" id="letter-h"></div>
            <!-- Big u made of small letters -->
            <div class="big-letter letter-u" id="letter-u"></div>
            <!-- Big b made of small letters -->
            <div class="big-letter letter-b" id="letter-b"></div>
        </div>
        
        <p class="subtitle">Built with code, powered by Finley</p>
        <p class="letters-source">Spelled with letters from: F-I-N-L-E-Y</p>
        <!-- Canvas for wooperbird goose on main page -->
        <canvas id="wooperbirdCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></canvas>
                </div>
    
    <!-- Profile display in top left (visible on all pages) -->
    <div class="profile-display" id="profileDisplay" style="display: none;" onclick="toggleProfileMenu(event)">
        <div class="profile-username" id="profileUsername">
            <span id="profileUsernameText"></span>
            <span class="profile-admin-badge" id="profileAdminBadge" style="display: none;">ADMIN</span>
        </div>
        <div class="profile-menu" id="profileMenu">
            <div class="profile-menu-item" onclick="showWhoami(); document.getElementById('profileMenu').classList.remove('show');">View Profile</div>
            <div class="profile-menu-item logout" onclick="logout()">Logout</div>
        </div>
    </div>
    
    <!-- Home page -->
    <div class="page home-page hidden" id="homePage">
        <h1>Welcome to the home</h1>
        <p>Type "back" in the command bar to return</p>
        <a href="https://sso.browardschools.com/" target="_blank">Broward Schools Login</a>
            </div>
    
    <!-- Minesweeper page -->
    <div class="page minesweeper-page hidden" id="minesweeperPage" oncontextmenu="return false;">
        <button id="restart-btn">Restart Game</button>
        <button id="minesweeper-page-leaderboard-btn" style="margin-left: 10px;">Leaderboard</button>
        <div id="message">Flags Remaining: 10</div>
        <div id="minesweeper-timer-display" style="font-size: 16px; margin: 10px 0; font-weight: bold;">Time: <span id="minesweeper-timer-text">0</span>s</div>
        <div id="minesweeper-game-container">
            <div class="minesweeper-grid" id="minesweeper-grid"></div>
        </div>
    </div>

    <!-- Pong page -->
    <div class="page sandboxels-page hidden" id="pongPage">
        <iframe id="pong-iframe" class="sandboxels-iframe" src="https://web-pong.com/" name="pong_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closePong()">X CLOSE VIEW (Return to finleychang.com)</button>
                    </div>
    
    <!-- Sandboxels page -->
    <div class="page sandboxels-page hidden" id="sandboxelsPage">
        <iframe id="sandboxels-iframe" class="sandboxels-iframe" src="https://shalbito.vercel.app/" name="sandboxels_frame"></iframe>
        <button class="sandboxels-close-btn" onclick="closeSandboxels()">X CLOSE VIEW (Return to finleychang.com)</button>
        </div>
        
    <!-- Paint page -->
    <div class="page sandboxels-page hidden" id="paintPage">
        <canvas id="paintCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: black; font-size: 16px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); z-index: 1000; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px;">
            <div>Brush Size: <span id="paint-brush-size">5</span></div>
            <div style="margin-top: 10px;">
                <label for="paint-color-picker" style="display: block; margin-bottom: 5px;">Color:</label>
                <input type="color" id="paint-color-picker" value="#000000" style="width: 60px; height: 30px; cursor: pointer; border: 2px solid #333; border-radius: 4px;">
                <span id="paint-color-display" style="margin-left: 10px;">#000000</span>
            </div>
            </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
        
    <!-- Collaborative Drawing Board page -->
    <div class="page sandboxels-page hidden" id="drawingBoardPage">
        <canvas id="drawingBoardCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: black; font-size: 16px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); z-index: 1000; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; min-width: 250px;">
            <div style="margin-bottom: 10px;">
                <strong>Collaborative Drawing Board</strong>
            </div>
            <div style="margin-bottom: 10px;">
                <div>Brush Size: <span id="drawing-brush-size">5</span></div>
                <input type="range" id="drawing-brush-size-slider" min="1" max="50" value="5" style="width: 100%; margin-top: 5px;">
            </div>
            <div style="margin-top: 10px;">
                <label for="drawing-color-picker" style="display: block; margin-bottom: 5px;">Color:</label>
                <input type="color" id="drawing-color-picker" value="#000000" style="width: 60px; height: 30px; cursor: pointer; border: 2px solid #333; border-radius: 4px;">
                <span id="drawing-color-display" style="margin-left: 10px;">#000000</span>
            </div>
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ccc;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Active Users: <span id="drawing-user-count">1</span></div>
                <button onclick="clearDrawingBoard()" style="padding: 8px 15px; font-size: 14px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 5px;">Clear Canvas</button>
            </div>
        </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
    </div>
    
    <!-- Remote Desktop page -->
    <div class="page remote-desktop-page hidden" id="remoteDesktopPage">
        <div id="remoteDesktop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #008080; font-family: 'MS Sans Serif', Arial, sans-serif; overflow: hidden;">
            <!-- Desktop Icons Container -->
            <div id="desktopIcons" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 40px); padding: 10px;">
                <!-- Icons will be added here dynamically -->
            </div>
            
            <!-- Taskbar -->
            <div id="taskbar" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40px; background: #c0c0c0; border-top: 2px solid #ffffff; display: flex; align-items: center; padding: 0 4px; z-index: 1000;">
                <button id="startButton" style="height: 32px; padding: 0 12px; background: #c0c0c0; border: 2px outset #c0c0c0; font-family: 'MS Sans Serif', Arial, sans-serif; font-size: 11px; font-weight: bold; cursor: pointer; margin-right: 4px;">Start</button>
                <div id="taskbarApps" style="flex: 1; display: flex; align-items: center; gap: 2px;"></div>
            </div>
            
            <!-- Context Menu -->
            <div id="desktopContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" data-action="add-paper" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">New Paper</div>
                <div class="context-menu-item" data-action="add-paint" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">New Paint</div>
            </div>
            
            <!-- Icon Context Menu -->
            <div id="iconContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" onclick="openSelectedIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Open</div>
                <div class="context-menu-item" onclick="renameDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Rename</div>
                <div class="context-menu-item" onclick="deleteDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Delete</div>
            </div>
            
            <!-- Computer Context Menu -->
            <div id="computerContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                <div class="context-menu-item" onclick="powerOffDesktop()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Power Off</div>
            </div>
        </div>
    </div>
        
    <!-- Coinflip page -->
    <div class="page coinflip-page hidden" id="coinflipPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Coin Flip</h1>
        <div id="money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="money-count">0</span>
            </div>
        <div id="win-chance-display" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Win Chance: <span id="win-chance-percent">50</span>%
        </div>
        <div id="coin-container" style="width: 200px; height: 200px; margin: 20px auto; position: relative; perspective: 1000px;">
            <div id="coin" style="width: 200px; height: 200px; position: relative; transform-style: preserve-3d; transition: transform 0.6s;">
                <div id="coin-front" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(0deg);">H</div>
                <div id="coin-back" style="position: absolute; width: 100%; height: 100%; border-radius: 50%; background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); border: 8px solid #c9a520; display: flex; align-items: center; justify-content: center; font-size: 72px; font-weight: bold; color: #8b6914; backface-visibility: hidden; transform: rotateY(180deg);">T</div>
            </div>
        </div>
        <div id="coinflip-result" style="color: #c9d1d9; font-size: 24px; margin: 20px 0; min-height: 30px;"></div>
        <div style="margin: 30px 0;">
            <button id="heads-btn" onclick="guessCoin('heads')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Heads</button>
            <button id="tails-btn" onclick="guessCoin('tails')" style="padding: 15px 30px; margin: 10px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Tails</button>
        </div>
        <div id="streak-display" style="color: #58a6ff; font-size: 20px; margin-top: 20px;">
            Streak: <span id="streak-count">0</span>
        </div>
    </div>
    
    <!-- Clicker page -->
    <div class="page clicker-page hidden" id="clickerPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Clicker Game</h1>
        <div id="clicker-money-display" style="color: #ffd700; font-size: 24px; margin-bottom: 15px; font-weight: bold;">
            Money: $<span id="clicker-money-count">0</span>
        </div>
        <div id="clicker-per-click" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Money Per Click: $<span id="clicker-amount">1</span>
        </div>
        <div style="margin: 40px 0;">
            <button id="clicker-button" onclick="clickMoney()" style="padding: 30px 60px; font-size: 32px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.1s; user-select: none;">CLICK ME!</button>
        </div>
    </div>
    
    <!-- Achievements page -->
    <div class="page achievements-page hidden" id="achievementsPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 10px;">Achievements</h1>
        <div id="achievements-stats" style="color: #58a6ff; font-size: 18px; margin-bottom: 20px;">
            Found: <span id="found-count">0</span> / <span id="total-count">256</span>
                </div>
        <div id="achievements-grid" class="achievements-grid">
            <!-- Achievements will be generated here -->
            </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>

    <!-- Goose Rain page -->
    <div class="page gooserain-page hidden" id="gooserainPage">
        <canvas id="gooseCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Geese: <span id="goose-count">0</span>
                </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
            </div>
    
    <!-- Stones page -->
    <div class="page stones-page hidden" id="stonesPage">
        <canvas id="stonesCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #4682B4 0%, #5F9EA0 60%, #D2B48C 60%, #CD853F 100%); cursor: crosshair;"></canvas>
        <div style="position: fixed; top: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Stones: <span id="stones-count">0</span>
        </div>
        <div style="position: fixed; top: 50px; left: 20px; color: white; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1000;">
            Press E to spawn stones
        </div>
        <button onclick="showPage('mainPage')" style="position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; z-index: 1000;">Back</button>
    </div>
    
    <!-- Limbo page (blocked) -->
    <div class="page limbo-page hidden" id="limboPage">
        <h1 style="color: #f85149; font-size: 48px; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">âš ï¸ BLOCKED âš ï¸</h1>
        <p style="color: #c9d1d9; font-size: 24px; margin-bottom: 40px; text-align: center;">Your blocked from this website</p>
        <p style="color: #8b949e; font-size: 18px; margin-bottom: 30px;">Enter the password to be unblocked:</p>
        <input type="text" id="limboPasswordInput" placeholder="Password" style="padding: 15px 20px; font-size: 20px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; margin-bottom: 20px; text-align: center; min-width: 250px;">
        <button id="limboSubmitBtn" onclick="checkLimboPassword()" style="padding: 15px 40px; font-size: 20px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Submit</button>
        <p id="limboError" style="color: #f85149; font-size: 16px; margin-top: 20px; min-height: 24px;"></p>
    </div>
    
    <!-- Panic Menu page -->
    <div class="page panicmenu-page hidden" id="panicmenuPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Panic Menu</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">Set a hotkey and URL to quickly swap tabs</p>
        <div style="max-width: 500px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Hotkey:</label>
                <input type="text" id="panicHotkeyInput" placeholder="Press a key..." style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; text-align: center;" readonly>
                <p style="color: #8b949e; font-size: 14px; margin-top: 5px;">Click the input and press a key to set</p>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="color: #c9d1d9; font-size: 18px; display: block; margin-bottom: 10px;">Website URL:</label>
                <input type="text" id="panicUrlInput" placeholder="https://example.com" style="width: 100%; padding: 12px; font-size: 16px; background: #161b22; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9;">
            </div>
            <button onclick="savePanicSettings()" style="width: 100%; padding: 15px; font-size: 18px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 20px;">Save Settings</button>
            <div id="panicStatus" style="color: #58a6ff; font-size: 16px; text-align: center; min-height: 24px; margin-bottom: 20px;"></div>
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer;">Back</button>
        </div>
    </div>
    
    <!-- Suggestions page -->
    <div class="page suggestions-page hidden" id="suggestionsPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">ðŸ’¡ Suggestions</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">View and create suggestions for the website</p>
        <div style="max-width: 900px; margin: 0 auto;">
            <!-- Create suggestion form -->
            <div style="background: #161b22; border: 2px solid #30363d; border-radius: 8px; padding: 20px; margin-bottom: 30px;">
                <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Create New Suggestion</h2>
                <textarea id="suggestion-input" placeholder="Enter your suggestion here..." style="width: 100%; min-height: 100px; padding: 12px; font-size: 16px; background: #0d1117; border: 2px solid #30363d; border-radius: 8px; color: #c9d1d9; margin-bottom: 15px; font-family: inherit; resize: vertical;" maxlength="500"></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="suggestion-char-count" style="color: #8b949e; font-size: 14px;">0/500 characters</span>
                    <button onclick="submitSuggestion()" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Submit Suggestion</button>
                </div>
            </div>
            
            <!-- Suggestions list -->
            <div id="suggestions-list" style="background: #161b22; border: 2px solid #30363d; border-radius: 8px; padding: 20px;">
                <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 20px;">All Suggestions</h2>
                <div id="suggestions-content" style="color: #c9d1d9;">
                    <p style="color: #8b949e; text-align: center; padding: 20px;">Loading suggestions...</p>
                </div>
            </div>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Changelog page -->
    <div class="page changelog-page hidden" id="changelogPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">ðŸ“ Changelog</h1>
        <p style="color: #8b949e; font-size: 16px; margin-bottom: 30px;">Track of all additions and updates to the website</p>
        <div style="max-width: 800px; margin: 0 auto; text-align: left;">
            <div id="changelog-content" style="background: #161b22; border: 2px solid #30363d; border-radius: 8px; padding: 20px; color: #c9d1d9;">
                <!-- Changelog entries will be displayed here -->
            </div>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Background Selection page -->
    <div class="page background-page hidden" id="backgroundPage">
        <h1 style="color: #c9d1d9; font-size: 36px; margin-bottom: 20px;">Background Selection</h1>
        <div id="bg-theme-warning" style="display: none; padding: 15px; margin-bottom: 20px; background: #f85149; color: white; border-radius: 8px; font-size: 16px; max-width: 600px;">
            <strong>âš ï¸ Background colors only work on Dark or Light theme.</strong> Switch to one of those themes to use custom backgrounds.
        </div>
        <div style="margin-bottom: 30px;">
            <button id="bg-solid-btn" onclick="setBgMode('solid')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer;">Solid Color</button>
            <button id="bg-gradient-btn" onclick="setBgMode('gradient')" style="padding: 10px 20px; margin: 5px; font-size: 16px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 6px; cursor: pointer;">Gradient (2 Colors)</button>
        </div>
        <div id="bg-solid-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select Color</h2>
            <div id="bg-solid-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
        </div>
        <div id="bg-gradient-section" style="display: none;">
            <h2 style="color: #c9d1d9; font-size: 24px; margin-bottom: 15px;">Select 2 Colors</h2>
            <div style="margin-bottom: 15px;">
                <p style="color: #8b949e; font-size: 16px;">Color 1: <span id="bg-gradient-color1-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
                <p style="color: #8b949e; font-size: 16px;">Color 2: <span id="bg-gradient-color2-name" style="color: #c9d1d9; font-weight: bold;">Not selected</span></p>
            </div>
            <div id="bg-gradient-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 800px; margin-bottom: 20px;">
                <!-- Colors will be generated here -->
            </div>
            <button id="bg-apply-gradient-btn" onclick="applyGradientBackground()" disabled style="padding: 12px 24px; font-size: 18px; font-weight: bold; background: #30363d; color: white; border: none; border-radius: 8px; cursor: not-allowed; margin-top: 20px;">Apply Gradient</button>
        </div>
        <div style="margin-top: 30px;">
            <button onclick="showPage('mainPage')" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background: #f85149; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">Back</button>
        </div>
    </div>
    
    <!-- Remote Desktop page -->
    <div class="page remote-desktop-page hidden" id="remoteDesktopPage">
        <div id="remoteDesktop" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #008080; font-family: 'MS Sans Serif', Arial, sans-serif; overflow: hidden;">
            <!-- Desktop icons container -->
            <div id="desktopIcons" style="position: absolute; top: 0; left: 0; width: 100%; height: calc(100% - 40px); padding: 10px; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 20px;">
                <!-- Icons will be added here dynamically -->
            </div>
            
            <!-- Taskbar -->
            <div id="taskbar" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 40px; background: #c0c0c0; border-top: 2px solid #ffffff; display: flex; align-items: center; padding: 0 4px; z-index: 1000; box-shadow: 0 -2px 4px rgba(0,0,0,0.3);">
                <div style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; margin: 2px; cursor: pointer; font-size: 11px; font-weight: bold; user-select: none;" onclick="showPage('mainPage')">
                    Start
                </div>
                <div id="taskbarApps" style="flex: 1; display: flex; gap: 2px; padding: 0 4px;">
                    <!-- Taskbar buttons will be added here -->
                </div>
            </div>
        </div>
        
        <!-- Right-click context menu -->
        <div id="desktopContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
            <div class="context-menu-item" onclick="addDesktopApp('paper')" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">New Paper</div>
            <div class="context-menu-item" onclick="addDesktopApp('paint')" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">New Paint</div>
        </div>
        
        <!-- Icon right-click menu -->
        <div id="iconContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
            <div class="context-menu-item" onclick="renameDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">Rename</div>
            <div class="context-menu-item" onclick="deleteDesktopIcon()" style="padding: 4px 20px; cursor: pointer; font-size: 11px; background: transparent; border: none; text-align: left; width: 100%;">Delete</div>
        </div>
        
        <!-- Trash can -->
        <div id="trashCan" class="desktop-icon" style="position: absolute; bottom: 50px; right: 10px; width: 80px; text-align: center; cursor: pointer; user-select: none;" draggable="false">
            <div style="width: 32px; height: 32px; margin: 0 auto 4px; background: url('data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 32 32%22><rect x=%228%22 y=%228%22 width=%2216%22 height=%2216%22 fill=%22%23000%22/><rect x=%2210%22 y=%2210%22 width=%2212%22 height=%222%22 fill=%22%23000%22/><rect x=%2212%22 y=%2212%22 width=%228%22 height=%222%22 fill=%22%23fff%22/></svg>') no-repeat center; background-size: contain;"></div>
            <div style="font-size: 11px; color: #fff; text-shadow: 1px 1px 1px #000;">Trash</div>
        </div>
    </div>
    
    <!-- Clock display (top left) -->
    <div class="clock-display hidden" id="clockDisplay"></div>
    
    <!-- Edit Profile Modal -->
    <div class="edit-modal" id="editModal">
        <div class="edit-modal-content">
            <h2>âœï¸ Edit Profile</h2>
            <div class="edit-form">
                <div class="edit-field">
                    <label>User ID:</label>
                    <input type="text" id="editUserId" placeholder="Your user ID" maxlength="20">
                    <small>3-20 characters (letters, numbers, _, -)</small>
                </div>
                <div class="edit-field">
                    <label>Bio:</label>
                    <textarea id="editBio" placeholder="Tell us about yourself..." maxlength="200"></textarea>
                    <small><span id="bioCharCount">0</span>/200 characters</small>
                </div>
                <div class="edit-field">
                    <label>Avatar Emoji:</label>
                    <div class="emoji-picker">
                        <div class="emoji-preview" id="emojiPreview">ðŸ‘¤</div>
                        <div class="emoji-grid" id="emojiGrid">
                            <!-- Emojis will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="edit-buttons">
                    <button class="edit-save-btn" id="editSaveBtn">Save</button>
                    <button class="edit-cancel-btn" id="editCancelBtn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Terms and Agreements Modal -->
    <div class="terms-modal" id="termsModal">
        <div class="terms-modal-content">
            <h2>ðŸ“‹ Terms and Agreements</h2>
            <div class="terms-text">
                <p><strong>Welcome to FinHub!</strong></p>
                <p>By using this website, you agree to the following terms:</p>
                <ul>
                    <li><strong>Be Respectful:</strong> No inappropriate content, harassment, or offensive language</li>
                    <li><strong>No Inappropriate Drawings:</strong> Keep drawings appropriate and respectful</li>
                    <li><strong>No Bad Words:</strong> Keep chat clean and friendly</li>
                    <li><strong>Respect Others:</strong> Be kind to other users</li>
                    <li><strong>No Spam:</strong> Don't spam messages or flood the chat</li>
                    <li><strong>Privacy:</strong> Don't share personal information</li>
                </ul>
                <p><strong>Violations may result in being banned from the service.</strong></p>
                <p>By clicking "I Agree", you acknowledge that you have read and agree to these terms.</p>
            </div>
            <div class="terms-buttons">
                <button class="terms-agree-btn" id="termsAgreeBtn">I Agree</button>
                <button class="terms-disagree-btn" id="termsDisagreeBtn">I Disagree</button>
            </div>
        </div>
    </div>
    
    <!-- Command feedback display -->
    <div class="command-feedback hidden" id="commandFeedback">
        <span class="command-text"></span><span class="feedback-text"></span>
    </div>
    
    <!-- Chat Page -->
    <div class="page hidden" id="chatPage">
        <div class="chat-container">
            <div class="chat-header">
                <h2>ðŸ’¬ Online Chat</h2>
                <div class="online-users" id="onlineUsers">
                    <div class="online-users-title">ðŸ‘¥ Online Users</div>
                    <div id="onlineUsersList"></div>
                </div>
                <!-- Context Menu for Online Users -->
                <div id="onlineUserContextMenu" class="context-menu hidden" style="position: fixed; background: #c0c0c0; border: 2px outset #c0c0c0; padding: 2px; z-index: 2000; min-width: 150px; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                    <div class="context-menu-item" id="addFriendContextItem" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">Add Friend</div>
                    <div class="context-menu-item" id="viewBoardContextItem" style="padding: 4px 20px; cursor: pointer; font-size: 11px; font-family: 'MS Sans Serif', Arial, sans-serif;">View Board</div>
                </div>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." maxlength="500">
                <button class="chat-send-btn" id="chatSendBtn">Send</button>
            </div>
        </div>
    </div>
    
    <!-- Friends List Modal -->
    <div class="friends-modal" id="friendsModal">
        <div class="friends-modal-content">
            <h2>ðŸ‘¥ My Friends</h2>
            <div class="friends-list" id="friendsList">
                <!-- Friends will be populated here -->
            </div>
            <div class="friends-buttons">
                <button class="friends-close-btn" id="friendsCloseBtn">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Private Chat Page -->
    <div class="page hidden" id="privateChatPage">
        <div class="chat-container">
            <div class="chat-header">
                <h2 id="privateChatTitle">ðŸ’¬ Private Chat</h2>
                <button class="chat-back-btn" id="privateChatBackBtn">â† Back to Friends</button>
            </div>
            <div class="chat-messages" id="privateChatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="privateChatInput" placeholder="Type a message..." maxlength="500">
                <button class="chat-send-btn" id="privateChatSendBtn">Send</button>
            </div>
        </div>
    </div>
    
    <!-- Board View Page -->
    <div class="page hidden" id="boardViewPage">
        <div style="padding: 20px; max-width: 800px; margin: 0 auto; background: #0d1117; min-height: 100vh; color: #c9d1d9;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="boardViewTitle" style="color: #58a6ff; margin: 0;">ðŸ“‹ Board</h2>
                <button onclick="showPage('mainPage')" style="background: #238636; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">Back</button>
            </div>
            <div id="boardContent" style="background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 20px; min-height: 400px;">
                <div style="text-align: center; color: #666; padding: 40px;">Loading board...</div>
            </div>
        </div>
    </div>
    
    <!-- Board Edit Page -->
    <div class="page hidden" id="boardEditPage">
        <div style="padding: 20px; max-width: 800px; margin: 0 auto; background: #0d1117; min-height: 100vh; color: #c9d1d9;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #58a6ff; margin: 0;">âœï¸ Edit Your Board</h2>
                <button onclick="showPage('mainPage')" style="background: #238636; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">Back</button>
            </div>
            <div style="background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 20px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; color: #c9d1d9; font-weight: bold;">Text Content:</label>
                    <textarea id="boardTextInput" placeholder="Write something on your board..." style="width: 100%; min-height: 200px; padding: 10px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #c9d1d9; font-size: 14px; font-family: inherit; resize: vertical;"></textarea>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; color: #c9d1d9; font-weight: bold;">Upload Images:</label>
                    <input type="file" id="boardImageInput" accept="image/*" multiple style="display: none;">
                    <button onclick="document.getElementById('boardImageInput').click()" style="background: #238636; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; margin-bottom: 10px;">Choose Images</button>
                    <div id="boardImagesPreview" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; margin-top: 10px;"></div>
                </div>
                <div id="boardExistingImages" style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; color: #c9d1d9; font-weight: bold;">Current Images:</label>
                    <div id="boardExistingImagesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;"></div>
                </div>
                <button onclick="saveBoard()" style="background: #238636; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; width: 100%;">Save Board</button>
            </div>
        </div>
    </div>
    
    <!-- Visit Counter -->
    <div class="visit-counter" id="visitCounter">
        <div class="visit-counter-number" id="visitCounterNumber">0</div>
        <div class="visit-counter-label">Total Visits</div>
    </div>
    
    <!-- Command history toggle -->
    <div class="command-history-toggle" id="commandHistoryToggle" title="Click to toggle command history">ðŸ“œ History</div>
    
    <!-- Command history display -->
    <div class="command-history" id="commandHistory">
        <div class="command-history-header">Command History (Last 10)</div>
        <div id="commandHistoryEntries"></div>
    </div>
    
    <!-- Command bar in bottom left -->
    <div class="command-bar">
        <input type="text" class="command-input" id="commandInput" placeholder="Type a color or 'home'..." autocomplete="off">
    </div>
    
        <!-- Commands menu - draggable -->
    <div class="commands-menu" id="commandsMenu">
        <div class="commands-menu-header" id="commandsMenuHeader">
            <h3>Commands</h3>
            <button class="commands-menu-close" id="commandsMenuClose">Ã—</button>
        </div>
        <div class="commands-list" id="commandsList">
            <!-- Commands will be dynamically generated based on unlocks -->
        </div>
    </div>

    <script>
        // Letters from "finley" to use
        const finleyLetters = ['f', 'i', 'n', 'l', 'e', 'y'];
        
        // Function to expand pattern: make 3x wider and 2x taller
        function expandPattern(pattern) {
            const expanded = [];
            // Make each row 3x wider
            pattern.forEach(row => {
                const wideRow = [];
                row.forEach(cell => {
                    // Repeat each cell 3 times
                    wideRow.push(cell, cell, cell);
                });
                expanded.push(wideRow);
            });
            // Make 2x taller by duplicating each row
            const tallExpanded = [];
            expanded.forEach(row => {
                tallExpanded.push(row); // Original row
                tallExpanded.push(row); // Duplicate row
            });
            return tallExpanded;
        }
        
        // Function to create letter patterns
        function createLetterPattern(letter, pattern, sourceLetters = finleyLetters) {
            const container = document.getElementById(`letter-${letter}`);
            if (!container) return;
            container.innerHTML = ''; // Clear existing
            const expandedPattern = expandPattern(pattern);
            expandedPattern.forEach(row => {
                row.forEach(cell => {
                    const span = document.createElement('span');
                    span.className = 'small-letter';
                    if (cell === 1) {
                        // Randomly pick a letter from source
                        const randomLetter = sourceLetters[Math.floor(Math.random() * sourceLetters.length)];
                        span.textContent = randomLetter;
                        span.classList.add(randomLetter);
                } else {
                        span.textContent = ' ';
                    }
                    container.appendChild(span);
                });
            });
        }
        
        // Letters for GooseHub (TYLER)
        const tylerLetters = ['t', 'y', 'l', 'e', 'r'];
        
        // Letter patterns for GOOSEHUB
        const gPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const oPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const sPattern = [
            [0,1,1,1,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [0,1,1,1,1,1,0],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        const ePattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,1,1]
        ];
        
        // Transform to FinHub mode (revert from GooseHub)
        function transformToFinHubMode() {
            isGooseMode = false;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with code, powered by Finley';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            }
            
            // Clear and recreate title with FINHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for F, I, N, H, U, B
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern, finleyLetters);
                createLetterPattern('i', iPattern, finleyLetters);
                createLetterPattern('n', nPattern, finleyLetters);
                createLetterPattern('h', hPattern, finleyLetters);
                createLetterPattern('u', uPattern, finleyLetters);
                createLetterPattern('b', bPattern, finleyLetters);
            }
            
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Transform to GooseHub mode
        function transformToGooseMode() {
            isGooseMode = true;
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            
            if (subtitle) {
                subtitle.textContent = 'Built with feathers, powered by birds';
            }
            if (lettersSource) {
                lettersSource.textContent = 'Spelled with letters from: T-Y-L-E-R';
            }
            
            // Clear and recreate title with GOOSEHUB letters
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                // Create containers for G, O, O, S, E, H, U, B (need unique IDs for the two O's)
                const gooseLetters = ['g', 'o', 'o2', 's', 'e', 'h', 'u', 'b'];
                gooseLetters.forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter.replace('2', '')}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                // Wait a tiny bit for DOM to update, then create patterns
                setTimeout(() => {
                    createLetterPattern('g', gPattern, tylerLetters);
                    createLetterPattern('o', oPattern, tylerLetters);
                    createLetterPattern('o2', oPattern, tylerLetters);
                    createLetterPattern('s', sPattern, tylerLetters);
                    createLetterPattern('e', ePattern, tylerLetters);
                    createLetterPattern('h', hPattern, tylerLetters);
                    createLetterPattern('u', uPattern, tylerLetters);
                    createLetterPattern('b', bPattern, tylerLetters);
                }, 10);
            }
            
            // Unlock honk and gooserain commands
            unlockCommand('honk');
            unlockCommand('gooserain');
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Render commands menu dynamically - show all commands except goose ones until unlocked
        function renderCommandsMenu() {
            const commandsList = document.getElementById('commandsList');
            if (!commandsList) return;
            
            const gooseCommands = ['goose', 'honk', 'gooserain']; // Goose commands that need to be unlocked
            
            const commandDefinitions = {
                'Navigation': [
                    { name: 'home', desc: 'Go to home page' },
                    { name: 'back', desc: 'Return to main page' },
                    { name: 'sweeper', desc: 'Play Minesweeper' },
                    { name: 'pong', desc: 'Play Pong' },
                    { name: 'sandboxles', desc: 'Open Sandboxels' },
                    { name: 'paint', desc: 'Open Paint game' },
                    { name: 'drawing board', desc: 'Open collaborative drawing board' },
                    { name: 'remote desktop', desc: 'Open Windows 95 style desktop' },
                    { name: 'desktop', desc: 'Open Windows 95 style desktop' },
                    { name: 'snake', desc: 'Play Google Snake' },
                    { name: 'coinflip', desc: 'Flip a coin' },
                    { name: 'clicker', desc: 'Play clicker game' },
                    { name: 'finley', desc: 'Transform back to FinHub' },
                    { name: 'achievements', desc: 'View achievements' },
                    { name: 'changelog', desc: 'View changelog and updates' },
                    { name: 'suggest', desc: 'Open suggestions area to view and create suggestions' },
                    { name: 'party', desc: 'Open party GUI with minigames' },
                    { name: 'background', desc: 'Change background' },
                    { name: 'bg', desc: 'Change background' },
                    { name: 'goose', desc: 'Transform to GooseHub' },
                    { name: 'gooserain', desc: 'Make it rain geese!', isGoose: true },
                    { name: 'stones', desc: 'Throw stones!' },
                    { name: 'wooper', desc: 'Wooper colors!' },
                    { name: 'wooperbird', desc: 'WooperBird command', isWooper: true },
                    { name: 'panicmenu', desc: 'Panic menu settings' },
                ],
                'Colors': [
                    { name: 'rainbow', desc: 'Rainbow colors' },
                    { name: 'black', desc: 'Black' },
                    { name: 'red', desc: 'Red' },
                    { name: 'blue', desc: 'Blue' },
                    { name: 'green', desc: 'Green' },
                    { name: 'yellow', desc: 'Yellow' },
                    { name: 'purple', desc: 'Purple' },
                    { name: 'orange', desc: 'Orange' },
                    { name: 'white', desc: 'White' },
                    { name: 'pink', desc: 'Pink' },
                    { name: 'cyan', desc: 'Cyan' },
                    { name: 'gold', desc: 'Gold' },
                    { name: 'silver', desc: 'Silver' },
                ],
                'Actions': [
                    { name: 'honk', desc: 'Play honk sound', isGoose: true },
                    { name: 'whoami', desc: 'Display your user profile' },
                    { name: 'whoami [id]', desc: 'Display another user\'s profile by ID' },
                    { name: 'iam [bio]', desc: 'Set your bio/profile text' },
                    { name: 'friend [id]', desc: 'Add a user as a friend' },
                    { name: 'friends', desc: 'View your friends list' },
                ],
                'Themes': [
                    { name: 'theme 1995', desc: 'Windows 95 grey boxed look' },
                    { name: 'theme cyberpunk', desc: 'Neon pink/blue with glitch font' },
                    { name: 'theme terminal', desc: 'CRT green with scanlines' },
                    { name: 'theme coffee', desc: 'Warm brown/cream sepia mode' },
                    { name: 'theme dark', desc: 'Dark mode (default)' },
                    { name: 'theme light', desc: 'Light mode' },
                    { name: 'theme matrix', desc: 'Matrix style - press keys to create falling columns' },
                    { name: 'theme paper', desc: 'Paper notebook with grid lines' },
                    { name: 'theme space', desc: 'Space theme with interactive stars' },
                    { name: 'theme ocean', desc: 'Ocean theme with wave animation' },
                    { name: 'theme clouds', desc: 'Clouds theme with animated clouds' },
                    { name: 'theme flashcard', desc: 'Flashcard theme with writable flashcards' },
                    { name: 'theme minecraft', desc: 'Minecraft theme - press SPACE for explosions!' },
                    { name: 'theme pirate', desc: 'Pirate theme with cannonballs across screen' },
                    { name: 'theme firework', desc: 'Firework theme - press letters for fireworks!' },
                    { name: 'theme mlg', desc: 'MLG theme - OH OH OHHHHH! Press SPACE for effects!' },
                    { name: 'stars', desc: 'Spawn more stars (space theme only)' },
                    { name: 'flashcard', desc: 'Create a new flashcard (flashcard theme only)' },
                    { name: 'fc', desc: 'Create a new flashcard (flashcard theme only)' },
                ],
                'Menu': [
                    { name: 'cmds', desc: 'Show/hide this menu' },
                    { name: 'clock', desc: 'Toggle clock (true/false)' },
                    { name: 'whoami', desc: 'Display your user profile' },
                    { name: 'whoami [id]', desc: 'Display another user\'s profile by ID' },
                    { name: 'iam [bio]', desc: 'Set your bio/profile text' },
                    { name: 'boardedit', desc: 'Edit your personal board (text and images)' },
                    { name: 'edit', desc: 'Edit your profile settings' },
                ]
            };
            
            let html = '';
            Object.keys(commandDefinitions).forEach(category => {
                const commands = commandDefinitions[category];
                const visibleCommands = commands.filter(cmd => {
                    // Hide goose commands if not unlocked
                    if (cmd.isGoose && !unlockedCommands.has(cmd.name)) {
                        return false;
                    }
                    // Hide wooper commands if not unlocked
                    if (cmd.isWooper && !unlockedCommands.has(cmd.name)) {
                        return false;
                    }
                    return true;
                });
                
                if (visibleCommands.length > 0) {
                    html += `<div class="command-category"><h4>${category}</h4>`;
                    visibleCommands.forEach(cmd => {
                        html += `<div class="command-item"><span class="command-name">${cmd.name}</span><span class="command-desc">- ${cmd.desc}</span></div>`;
                    });
                    html += `</div>`;
                }
            });
            
            commandsList.innerHTML = html;
        }
        
        // Unlock a command
        function unlockCommand(commandName) {
            unlockedCommands.add(commandName);
            renderCommandsMenu();
            saveGlobalData();
        }
        
        // Play honk sound
        function playHonkSound() {
            try {
                // Generate honk sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(180, audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Could not play honk sound:', e);
            }
        }
        
        // Big F pattern (original - will be expanded to 3x wide, 2x tall)
        const fPattern = [
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0],
            [1,0,0,0,0,0,0]
        ];
        
        // Big i pattern
        const iPattern = [
            [1,1,1],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [1,1,1]
        ];
        
        // Big n pattern
        const nPattern = [
            [1,0,0,0,0,0,1],
            [1,1,0,0,0,0,1],
            [1,0,1,0,0,0,1],
            [1,0,0,1,0,0,1],
            [1,0,0,0,1,0,1],
            [1,0,0,0,0,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big H pattern
        const hPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1]
        ];
        
        // Big u pattern
        const uPattern = [
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,1,1,1,0]
        ];
        
        // Big b pattern
        const bPattern = [
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,0,0],
            [1,0,0,0,0,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,1,0],
            [1,1,1,1,1,0,0]
        ];
        
        // Create all letters
        createLetterPattern('f', fPattern);
        createLetterPattern('i', iPattern);
        createLetterPattern('n', nPattern);
        createLetterPattern('h', hPattern);
        createLetterPattern('u', uPattern);
        createLetterPattern('b', bPattern);
        
        // Global money system - shared across all tabs
        let globalMoney = 0;
        let unlockedColors = new Set(); // Colors are unlocked by default (not used anymore but keeping for compatibility)
        let clickerPerClick = 1; // Clicker base money per click
        let unlockedCommands = new Set(); // Only goose commands need to be unlocked
        let isGooseMode = false; // Track if in goose mode
        let resetConfirm = false; // Track if reset command was just used (needs confirmation)
        let resetUsed = false; // Track if reset has been used (can only use once)
        let globalWindowZIndex = 10000; // Global z-index for leaderboards and popup windows
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load global data
        function loadGlobalData() {
            const saved = localStorage.getItem('globalData');
            if (saved) {
                const data = JSON.parse(saved);
                globalMoney = data.money || 0;
                unlockedColors = new Set(data.unlockedColors || []);
                clickerPerClick = data.clickerPerClick || 1;
                unlockedCommands = new Set(data.unlockedCommands || []); // Only goose commands stored
                isGooseMode = data.isGooseMode || false;
            }
            // Check if reset was used in this session
            if (sessionStorage.getItem('resetUsed') === 'true') {
                resetUsed = true;
            }
            updateAllMoneyDisplays();
            renderCommandsMenu();
            if (isGooseMode) {
                transformToGooseMode();
            }
        }
        
        // Save global data
        function saveGlobalData() {
            localStorage.setItem('globalData', JSON.stringify({
                money: globalMoney,
                unlockedColors: Array.from(unlockedColors),
                clickerPerClick: clickerPerClick,
                unlockedCommands: Array.from(unlockedCommands),
                isGooseMode: isGooseMode
            }));
        }
        
        // Reset everything - clears ALL progress and data
        function resetEverything() {
            // Clear ALL localStorage - this removes EVERYTHING
            localStorage.clear();
            
            // Clear ALL sessionStorage
            sessionStorage.clear();
            
            // Reset all variables
            globalMoney = 0;
            unlockedColors = new Set();
            clickerPerClick = 1;
            unlockedCommands = new Set(); // Reset goose command unlocks
            isGooseMode = false;
            resetConfirm = false;
            resetUsed = false; // Allow reset to be used again after page reload
            
            // Reset coinflip data
            coinflipStreak = 0;
            winChanceUpgrades = 0;
            
            // Reset achievements
            foundAchievements = new Set();
            colorChangeCount = 0;
            commandsUsed = new Set();
            coinflipWins = 0;
            
            // Recreate FinHub letters (reset from GooseHub if needed)
            const titleContainer = document.querySelector('.finhub-title');
            if (titleContainer) {
                titleContainer.innerHTML = '';
                ['f', 'i', 'n', 'h', 'u', 'b'].forEach(letter => {
                    const div = document.createElement('div');
                    div.className = `big-letter letter-${letter}`;
                    div.id = `letter-${letter}`;
                    titleContainer.appendChild(div);
                });
                
                createLetterPattern('f', fPattern);
                createLetterPattern('i', iPattern);
                createLetterPattern('n', nPattern);
                createLetterPattern('h', hPattern);
                createLetterPattern('u', uPattern);
                createLetterPattern('b', bPattern);
            }
            
            const subtitle = document.querySelector('.subtitle');
            const lettersSource = document.querySelector('.letters-source');
            if (subtitle) subtitle.textContent = 'Built with code, powered by Finley';
            if (lettersSource) lettersSource.textContent = 'Spelled with letters from: F-I-N-L-E-Y';
            
            // Update displays
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
            const clickerAmount = document.getElementById('clicker-amount');
            if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            
            // Re-render menu and achievements
            renderCommandsMenu();
            renderAchievements();
            
            // Clear color changes
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                letter.style.color = '';
            });
            
            // Reset desktop state (if exists)
            try {
                if (typeof saveDesktopState === 'function') {
                    // Will be reset when desktop initializes
                }
            } catch(e) {}
            
            // Reset command history
            if (typeof commandHistory !== 'undefined') {
                commandHistory = [];
            }
            
            // Clear all input fields if they exist
            const commandInputEl = document.getElementById('commandInput');
            if (commandInputEl) {
                commandInputEl.value = '';
            }
            
            // Go back to main page
            showPage('mainPage');
        }
        
        // Update all money displays across all pages
        function updateAllMoneyDisplays() {
            const displays = ['money-count', 'clicker-money-count'];
            displays.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = globalMoney;
            });
        }
        
        // Add money (global)
        function addMoney(amount) {
            globalMoney += amount;
            updateAllMoneyDisplays();
            saveGlobalData();
        }
        
        // Spend money (global)
        function spendMoney(amount) {
            if (globalMoney >= amount) {
                globalMoney -= amount;
                updateAllMoneyDisplays();
                saveGlobalData();
                return true;
            }
            return false;
        }
        
        // Color command system with multiple shades
        const colorPalettes = {
            'black': ['#000000', '#1a1a1a', '#333333', '#4d4d4d', '#666666', '#000000', '#0d0d0d', '#262626'],
            'red': ['#ff0000', '#cc0000', '#ff3333', '#990000', '#ff6666', '#ff1a1a', '#b30000', '#ff4d4d'],
            'blue': ['#0000ff', '#0000cc', '#3333ff', '#000099', '#6666ff', '#1a1aff', '#0000b3', '#4d4dff'],
            'green': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'yellow': ['#ffff00', '#cccc00', '#ffff33', '#999900', '#ffff66', '#ffff1a', '#b3b300', '#ffff4d'],
            'purple': ['#800080', '#660066', '#993399', '#4d004d', '#b366b3', '#8c1a8c', '#5c005c', '#cc66cc'],
            'orange': ['#ffa500', '#cc8400', '#ffb833', '#996300', '#ffcc66', '#ffad1a', '#b37500', '#ffd24d'],
            'white': ['#ffffff', '#e6e6e6', '#cccccc', '#f5f5f5', '#ffffff', '#fafafa', '#d9d9d9', '#ffffff'],
            'pink': ['#ff69b4', '#cc5490', '#ff7fc4', '#993f6c', '#ff99d4', '#ff73ba', '#b34a85', '#ff8fce'],
            'cyan': ['#00ffff', '#00cccc', '#33ffff', '#009999', '#66ffff', '#1affff', '#00b3b3', '#4dffff'],
            'lime': ['#00ff00', '#00cc00', '#33ff33', '#009900', '#66ff66', '#1aff1a', '#00b300', '#4dff4d'],
            'magenta': ['#ff00ff', '#cc00cc', '#ff33ff', '#990099', '#ff66ff', '#ff1aff', '#b300b3', '#ff4dff'],
            'brown': ['#a52a2a', '#842121', '#b84d4d', '#661919', '#cc7070', '#ad3333', '#8b1f1f', '#c55c5c'],
            'gray': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'grey': ['#808080', '#666666', '#999999', '#4d4d4d', '#b3b3b3', '#737373', '#595959', '#a6a6a6'],
            'gold': ['#ffd700', '#ccac00', '#ffdd33', '#998000', '#ffe666', '#ffdb1a', '#b39900', '#ffe84d'],
            'silver': ['#c0c0c0', '#999999', '#d4d4d4', '#737373', '#e6e6e6', '#b8b8b8', '#8c8c8c', '#d9d9d9']
        };
        
        // Color costs in shop
        const colorCosts = {
            'black': 10,
            'red': 20,
            'blue': 20,
            'green': 20,
            'yellow': 25,
            'purple': 30,
            'orange': 30,
            'white': 15,
            'pink': 35,
            'cyan': 25,
            'lime': 20,
            'magenta': 35,
            'brown': 25,
            'gray': 15,
            'grey': 15,
            'gold': 50,
            'silver': 40,
            'rainbow': 100
        };
        
        // Function to change all letter colors with different shades (all colors unlocked)
        function changeAllColors(colorName) {
            const palette = colorPalettes[colorName];
            if (!palette) {
                // Special case for rainbow
                if (colorName === 'rainbow') {
                    applyRainbowColors();
                }
                return;
            }
            
            const allSmallLetters = document.querySelectorAll('.small-letter');
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    // Randomly pick a shade from the palette
                    const randomShade = palette[Math.floor(Math.random() * palette.length)];
                    letter.style.color = randomShade;
                }
            });
        }

        // Function to apply rainbow colors
        function applyRainbowColors() {
            const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = rainbowColors[colorIndex % rainbowColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Function to apply wooper colors (blue and pink)
        function applyWooperColors() {
            const wooperColors = ['#0000ff', '#ff69b4']; // Blue and pink
            const allSmallLetters = document.querySelectorAll('.small-letter');
            let colorIndex = 0;
            allSmallLetters.forEach(letter => {
                if (letter.textContent.trim() !== '') {
                    letter.style.color = wooperColors[colorIndex % wooperColors.length];
                    colorIndex++;
                }
            });
        }
        
        // Navigation system
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            document.getElementById(pageId).classList.remove('hidden');
            
            // Show/hide command bar based on page
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) {
                if (pageId === 'remoteDesktopPage') {
                    commandBar.style.display = 'none';
                } else {
                    commandBar.style.display = 'flex';
                }
            }
        }
        
        // Commands menu functionality
        const commandsMenu = document.getElementById('commandsMenu');
        const commandsMenuHeader = document.getElementById('commandsMenuHeader');
        const commandsMenuClose = document.getElementById('commandsMenuClose');
        
        function toggleCommandsMenu() {
            commandsMenu.classList.toggle('open');
        }
        
        // Close menu button
        commandsMenuClose.addEventListener('click', () => {
            commandsMenu.classList.remove('open');
        });
        
        // Make menu draggable
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        commandsMenuHeader.addEventListener('mousedown', dragStart);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', dragEnd);
        
        function dragStart(e) {
            if (e.target === commandsMenuClose || !commandsMenu.classList.contains('open')) return;
            const rect = commandsMenu.getBoundingClientRect();
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;
            isDragging = true;
            commandsMenu.classList.add('dragging');
            commandsMenu.style.transition = 'none';
        }
        
        function drag(e) {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                
                // Keep menu within viewport
                const maxX = window.innerWidth - commandsMenu.offsetWidth;
                const maxY = window.innerHeight - commandsMenu.offsetHeight;
                currentX = Math.max(0, Math.min(currentX, maxX));
                currentY = Math.max(0, Math.min(currentY, maxY));
                
                commandsMenu.style.right = 'auto';
                commandsMenu.style.left = `${currentX}px`;
                commandsMenu.style.top = `${currentY}px`;
            }
        }
        
        function dragEnd(e) {
            if (isDragging) {
                isDragging = false;
                commandsMenu.classList.remove('dragging');
                commandsMenu.style.transition = 'right 0.3s ease';
            }
        }
        
        // Clock system
        let clockEnabled = false;
        let clockInterval = null;
        const clockDisplay = document.getElementById('clockDisplay');
        
        function loadClockSetting() {
            const saved = localStorage.getItem('clockEnabled');
            clockEnabled = saved === 'true';
            if (clockEnabled) {
                showClock();
            } else {
                hideClock();
            }
        }
        
        function saveClockSetting() {
            localStorage.setItem('clockEnabled', clockEnabled.toString());
        }
        
        function updateClock() {
            if (!clockDisplay) return;
            const now = new Date();
            // Florida timezone (America/New_York - EST/EDT)
            const options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false, // Military time
                timeZone: 'America/New_York'
            };
            const timeString = new Intl.DateTimeFormat('en-US', options).format(now);
            clockDisplay.textContent = timeString;
        }
        
        function showClock() {
            if (!clockDisplay) return;
            clockEnabled = true;
            clockDisplay.classList.remove('hidden');
            updateClock();
            if (clockInterval) clearInterval(clockInterval);
            clockInterval = setInterval(updateClock, 1000);
            saveClockSetting();
        }
        
        function hideClock() {
            if (!clockDisplay) return;
            clockEnabled = false;
            clockDisplay.classList.add('hidden');
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
            saveClockSetting();
        }
        
        // Command history storage (last 10 commands)
        let commandHistory = [];
        const MAX_HISTORY = 10;
        
        // Command feedback helper with history
        function showCommandFeedback(command, feedback, isSuccess = true) {
            const feedbackEl = document.getElementById('commandFeedback');
            const commandTextEl = feedbackEl?.querySelector('.command-text');
            const feedbackTextEl = feedbackEl?.querySelector('.feedback-text');
            
            // Remove previous success/error classes
            feedbackEl.classList.remove('success', 'error');
            
            if (feedbackEl && commandTextEl && feedbackTextEl) {
                commandTextEl.textContent = `> ${command}`;
                feedbackTextEl.textContent = feedback ? ` ${feedback}` : '';
                
                // Add success/error styling
                if (isSuccess) {
                    feedbackEl.classList.add('success');
                } else {
                    feedbackEl.classList.add('error');
                }
                
                feedbackEl.classList.remove('hidden');
                
                // Store in history
                addToHistory(command, feedback, isSuccess);
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    feedbackEl.classList.add('hidden');
                }, 3000);
            }
        }
        
        // Add command to history
        function addToHistory(command, feedback, isSuccess) {
            // Add to beginning of array
            commandHistory.unshift({
                command: command,
                feedback: feedback || (isSuccess ? 'Success' : 'Error'),
                success: isSuccess,
                timestamp: new Date().toLocaleTimeString()
            });
            
            // Keep only last 10
            if (commandHistory.length > MAX_HISTORY) {
                commandHistory.pop();
            }
            
            // Save to localStorage
            saveCommandHistory();
            
            // Update history display
            renderCommandHistory();
        }
        
        // Render command history
        function renderCommandHistory() {
            const historyEntries = document.getElementById('commandHistoryEntries');
            if (!historyEntries) return;
            
            if (commandHistory.length === 0) {
                historyEntries.innerHTML = '<div style="color: #6e7681; font-style: italic;">No commands yet...</div>';
                return;
            }
            
            let html = '';
            commandHistory.forEach(entry => {
                const statusClass = entry.success ? 'success' : 'error';
                html += `
                    <div class="command-history-entry ${statusClass}">
                        <span class="command-text">> ${entry.command}</span>
                        <span class="feedback-text">${entry.feedback}</span>
                        <span style="color: #6e7681; margin-left: 8px; font-size: 10px;">(${entry.timestamp})</span>
                    </div>
                `;
            });
            
            historyEntries.innerHTML = html;
        }
        
        // Toggle command history visibility
        function toggleCommandHistory() {
            const historyEl = document.getElementById('commandHistory');
            if (historyEl) {
                historyEl.classList.toggle('visible');
            }
        }
        
        // Terms and Agreements
        function checkTermsAgreement() {
            // Only show on finleychang.com, not localhost
            const hostname = window.location.hostname;
            if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.')) {
                return; // Don't show on localhost
            }
            
            const termsAccepted = localStorage.getItem('termsAccepted');
            const termsVersion = localStorage.getItem('termsVersion') || '1.0';
            const currentTermsVersion = '1.0'; // Update this when you change terms
            
            if (!termsAccepted || termsVersion !== currentTermsVersion) {
                showTermsModal();
            }
        }
        
        function showTermsModal() {
            const modal = document.getElementById('termsModal');
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideTermsModal() {
            const modal = document.getElementById('termsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function acceptTerms() {
            localStorage.setItem('termsAccepted', 'true');
            localStorage.setItem('termsVersion', '1.0');
            hideTermsModal();
        }
        
        function rejectTerms() {
            alert('You must accept the terms to use this website.');
        }
        
        // Edit Profile Menu
        const popularEmojis = ['ðŸ‘¤', 'ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜Š', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜', 'ðŸ˜Œ', 'ðŸ˜‰', 'ðŸ¤—', 'ðŸ˜', 'ðŸ¥°', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜™', 'ðŸ˜š', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ¤¨', 'ðŸ§', 'ðŸ¤©', 'ðŸ¥³', 'ðŸ˜‡', 'ðŸ¤ ', 'ðŸ¤¡', 'ðŸ¥¸', 'ðŸ˜º', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸ˜»', 'ðŸ˜¼', 'ðŸ˜½', 'ðŸ™€', 'ðŸ˜¿', 'ðŸ˜¾', 'ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ¨', 'ðŸ¯', 'ðŸ¦', 'ðŸ®', 'ðŸ·', 'ðŸ¸', 'ðŸµ', 'ðŸ”', 'ðŸ§', 'ðŸ¦‰', 'ðŸ¦„', 'ðŸ', 'ðŸ¦‹', 'ðŸ›', 'ðŸŒ', 'ðŸž', 'ðŸœ', 'ðŸ¦Ÿ', 'ðŸ¦—', 'ðŸ•·ï¸', 'ðŸ¦‚', 'ðŸ¢', 'ðŸ', 'ðŸ¦Ž', 'ðŸ¦–', 'ðŸ¦•', 'ðŸ™', 'ðŸ¦‘', 'ðŸ¦', 'ðŸ¦ž', 'ðŸ¦€', 'ðŸ¡', 'ðŸ ', 'ðŸŸ', 'ðŸ¬', 'ðŸ³', 'ðŸ‹', 'ðŸ¦ˆ', 'ðŸŠ', 'ðŸ…', 'ðŸ†', 'ðŸ¦“', 'ðŸ¦', 'ðŸ¦§', 'ðŸ˜', 'ðŸ¦›', 'ðŸ¦', 'ðŸª', 'ðŸ«', 'ðŸ¦’', 'ðŸ¦˜', 'ðŸ¦¬', 'ðŸƒ', 'ðŸ‚', 'ðŸ„', 'ðŸŽ', 'ðŸ–', 'ðŸ', 'ðŸ‘', 'ðŸ¦™', 'ðŸ', 'ðŸ¦Œ', 'ðŸ•', 'ðŸ©', 'ðŸ¦®', 'ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸ“', 'ðŸ¦ƒ', 'ðŸ¦¤', 'ðŸ¦š', 'ðŸ¦œ', 'ðŸ¦¢', 'ðŸ¦©', 'ðŸ•Šï¸', 'ðŸ‡', 'ðŸ¦', 'ðŸ¦¨', 'ðŸ¦¡', 'ðŸ¦«', 'ðŸ¦¦', 'ðŸ¦¥', 'ðŸ', 'ðŸ€', 'ðŸ¿ï¸', 'ðŸ¦”'];
        
        function openEditMenu() {
            const modal = document.getElementById('editModal');
            const userIdInput = document.getElementById('editUserId');
            const bioInput = document.getElementById('editBio');
            const emojiPreview = document.getElementById('emojiPreview');
            const emojiGrid = document.getElementById('emojiGrid');
            
            if (!modal) return;
            
            const currentUserId = getUserId();
            const currentBio = getUserBio(currentUserId) || '';
            const currentAvatar = getUserAvatar(currentUserId);
            
            // Populate fields
            userIdInput.value = currentUserId;
            bioInput.value = currentBio;
            emojiPreview.textContent = currentAvatar;
            updateBioCharCount();
            
            // Populate emoji grid
            emojiGrid.innerHTML = '';
            popularEmojis.forEach(emoji => {
                const emojiBtn = document.createElement('div');
                emojiBtn.className = 'emoji-option';
                if (emoji === currentAvatar) {
                    emojiBtn.classList.add('selected');
                }
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = () => {
                    // Remove previous selection
                    emojiGrid.querySelectorAll('.emoji-option').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    // Select this one
                    emojiBtn.classList.add('selected');
                    emojiPreview.textContent = emoji;
                };
                emojiGrid.appendChild(emojiBtn);
            });
            
            // Show modal
            modal.classList.add('show');
        }
        
        function closeEditMenu() {
            const modal = document.getElementById('editModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function saveEditProfile() {
            const userIdInput = document.getElementById('editUserId');
            const bioInput = document.getElementById('editBio');
            const emojiPreview = document.getElementById('emojiPreview');
            
            if (!userIdInput || !bioInput || !emojiPreview) return;
            
            const newUserId = userIdInput.value.trim();
            const newBio = bioInput.value.trim();
            const newAvatar = emojiPreview.textContent;
            
            // Validate user ID
            if (newUserId.length < 3 || newUserId.length > 20) {
                showCommandFeedback('edit', 'User ID must be 3-20 characters', false);
                return;
            }
            
            const validIdPattern = /^[a-zA-Z0-9_-]+$/;
            if (!validIdPattern.test(newUserId)) {
                showCommandFeedback('edit', 'User ID can only contain letters, numbers, _, and -', false);
                return;
            }
            
            const oldUserId = getUserId();
            
            // Change user ID if different
            if (newUserId !== oldUserId) {
                const result = setUserId(newUserId);
                if (result === false) {
                    showCommandFeedback('edit', 'User ID already taken. Choose a different one.', false);
                    return;
                } else if (result === true) {
                    finishSaving(newUserId, newBio, newAvatar);
                } else {
                    // Promise result
                    result.then((success) => {
                        if (success) {
                            finishSaving(newUserId, newBio, newAvatar);
                        } else {
                            showCommandFeedback('edit', 'User ID already taken. Choose a different one.', false);
                        }
                    });
                    return;
                }
            } else {
                finishSaving(newUserId, newBio, newAvatar);
            }
        }
        
        function finishSaving(userId, bio, avatar) {
            // Save bio
            setUserBio(userId, bio);
            
            // Save avatar
            setUserAvatar(userId, avatar);
            
            // Sync to Firebase if available
            if (database) {
                try {
                    database.ref(`users/${userId}`).update({
                        bio: bio,
                        avatar: avatar,
                        lastSeen: Date.now()
                    });
                } catch (e) {
                    console.warn('Could not sync profile to Firebase:', e);
                }
            }
            
            showCommandFeedback('edit', 'Profile saved successfully!', true);
            closeEditMenu();
        }
        
        function updateBioCharCount() {
            const bioInput = document.getElementById('editBio');
            const charCount = document.getElementById('bioCharCount');
            if (bioInput && charCount) {
                charCount.textContent = bioInput.value.length;
            }
        }
        
        // Initialize command history toggle
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('commandHistoryToggle');
            if (toggle) {
                toggle.addEventListener('click', toggleCommandHistory);
            }
            
            // Load history from localStorage
            loadCommandHistory();
            
            // Check terms agreement
            checkTermsAgreement();
            
            // Terms modal buttons
            const agreeBtn = document.getElementById('termsAgreeBtn');
            const disagreeBtn = document.getElementById('termsDisagreeBtn');
            if (agreeBtn) {
                agreeBtn.addEventListener('click', acceptTerms);
            }
            if (disagreeBtn) {
                disagreeBtn.addEventListener('click', rejectTerms);
            }
            
            // Edit modal buttons
            const editSaveBtn = document.getElementById('editSaveBtn');
            const editCancelBtn = document.getElementById('editCancelBtn');
            const editBio = document.getElementById('editBio');
            
            if (editSaveBtn) {
                editSaveBtn.addEventListener('click', saveEditProfile);
            }
            if (editCancelBtn) {
                editCancelBtn.addEventListener('click', closeEditMenu);
            }
            if (editBio) {
                editBio.addEventListener('input', updateBioCharCount);
            }
            
            // Close edit modal when clicking outside
            const editModal = document.getElementById('editModal');
            if (editModal) {
                editModal.addEventListener('click', (e) => {
                    if (e.target === editModal) {
                        closeEditMenu();
                    }
                });
            }
            
            // Friends modal
            const friendsCloseBtn = document.getElementById('friendsCloseBtn');
            if (friendsCloseBtn) {
                friendsCloseBtn.addEventListener('click', closeFriendsList);
            }
            
            const friendsModal = document.getElementById('friendsModal');
            if (friendsModal) {
                friendsModal.addEventListener('click', (e) => {
                    if (e.target === friendsModal) {
                        closeFriendsList();
                    }
                });
            }
            
            // Private chat
            const privateChatBackBtn = document.getElementById('privateChatBackBtn');
            if (privateChatBackBtn) {
                privateChatBackBtn.addEventListener('click', () => {
                    showPage('mainPage');
                    openFriendsList();
                });
            }
            
            const privateChatSendBtn = document.getElementById('privateChatSendBtn');
            const privateChatInput = document.getElementById('privateChatInput');
            
            if (privateChatSendBtn && privateChatInput) {
                privateChatSendBtn.onclick = () => {
                    if (currentPrivateChatWith) {
                        const text = privateChatInput.value;
                        if (text.trim()) {
                            sendPrivateMessage(text, currentPrivateChatWith);
                            privateChatInput.value = '';
                        }
                    }
                };
                
                privateChatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && currentPrivateChatWith) {
                        const text = privateChatInput.value;
                        if (text.trim()) {
                            sendPrivateMessage(text, currentPrivateChatWith);
                            privateChatInput.value = '';
                        }
                    }
                });
            }
            
            // Update visit counter
            updateVisitCounter();
        });
        
        // Load command history from localStorage
        function loadCommandHistory() {
            const saved = localStorage.getItem('commandHistory');
            if (saved) {
                try {
                    commandHistory = JSON.parse(saved);
                    // Ensure we only keep last 10
                    if (commandHistory.length > MAX_HISTORY) {
                        commandHistory = commandHistory.slice(0, MAX_HISTORY);
                    }
                    renderCommandHistory();
                } catch (e) {
                    console.error('Error loading command history:', e);
                    commandHistory = [];
                }
            }
        }
        
        // Save command history to localStorage
        function saveCommandHistory() {
            localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
        }
        
        // Login System
        // Simple password hashing function
        function hashPassword(password) {
            let hash = 0;
            for (let i = 0; i < password.length; i++) {
                const char = password.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash.toString(36);
        }
        
        // Check if user is logged in
        function isLoggedIn() {
            return localStorage.getItem('loggedInUsername') !== null;
        }
        
        // Get logged in username
        function getLoggedInUsername() {
            return localStorage.getItem('loggedInUsername') || null;
        }
        
        // Check if user is admin
        function isAdmin() {
            return getLoggedInUsername() === 'finleymain';
        }
        
        // Show login form
        function showLoginForm() {
            document.getElementById('loginPage').style.display = 'flex';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('loginError').textContent = '';
            document.getElementById('registerError').textContent = '';
        }
        
        // Show register form
        function showRegisterForm() {
            document.getElementById('registerForm').style.display = 'block';
            document.getElementById('loginError').textContent = '';
            document.getElementById('registerError').textContent = '';
        }
        
        // Attempt to register new user
        function attemptRegister() {
            const username = document.getElementById('registerUsername').value.trim();
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
            const errorEl = document.getElementById('registerError');
            
            // Validation
            if (!username || username.length < 3 || username.length > 20) {
                errorEl.textContent = 'Username must be 3-20 characters';
                return;
            }
            
            const validIdPattern = /^[a-zA-Z0-9_-]+$/;
            if (!validIdPattern.test(username)) {
                errorEl.textContent = 'Username can only contain letters, numbers, _, and -';
                return;
            }
            
            if (!password || password.length < 4) {
                errorEl.textContent = 'Password must be at least 4 characters';
                return;
            }
            
            if (password !== passwordConfirm) {
                errorEl.textContent = 'Passwords do not match';
                return;
            }
            
            // Check for duplicate username
            if (database) {
                database.ref(`userAccounts/${username}`).once('value', (snapshot) => {
                    if (snapshot.exists()) {
                        errorEl.textContent = 'Username already taken';
                        return;
                    }
                    
                    // Create account
                    const hashedPassword = hashPassword(password);
                    database.ref(`userAccounts/${username}`).set({
                        username: username,
                        passwordHash: hashedPassword,
                        createdAt: Date.now(),
                        isAdmin: username === 'finleymain'
                    }).then(() => {
                        // Auto-login after registration
                        localStorage.setItem('loggedInUsername', username);
                        localStorage.setItem('userPasswordHash', hashedPassword);
                        showMainContent();
                    }).catch((error) => {
                        errorEl.textContent = 'Registration failed: ' + error.message;
                    });
                });
            } else {
                // Fallback to localStorage
                const accounts = JSON.parse(localStorage.getItem('userAccounts') || '{}');
                if (accounts[username]) {
                    errorEl.textContent = 'Username already taken';
                    return;
                }
                
                const hashedPassword = hashPassword(password);
                accounts[username] = {
                    username: username,
                    passwordHash: hashedPassword,
                    createdAt: Date.now(),
                    isAdmin: username === 'finleymain'
                };
                localStorage.setItem('userAccounts', JSON.stringify(accounts));
                localStorage.setItem('loggedInUsername', username);
                localStorage.setItem('userPasswordHash', hashedPassword);
                showMainContent();
            }
        }
        
        // Check if user is timed out
        function checkUserTimeout(username) {
            if (database) {
                return new Promise((resolve) => {
                    database.ref(`userTimeouts/${username}`).once('value', (snapshot) => {
                        if (!snapshot.exists()) {
                            resolve(null);
                            return;
                        }
                        const timeout = snapshot.val();
                        if (Date.now() < timeout.timeoutUntil) {
                            resolve(timeout);
                        } else {
                            // Timeout expired, remove it
                            database.ref(`userTimeouts/${username}`).remove();
                            resolve(null);
                        }
                    });
                });
            } else {
                const timeouts = JSON.parse(localStorage.getItem('userTimeouts') || '{}');
                if (timeouts[username]) {
                    const timeout = timeouts[username];
                    if (Date.now() < timeout.timeoutUntil) {
                        return timeout;
                    } else {
                        // Timeout expired, remove it
                        delete timeouts[username];
                        localStorage.setItem('userTimeouts', JSON.stringify(timeouts));
                        return null;
                    }
                }
                return null;
            }
        }
        
        // Attempt to login
        function attemptLogin() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            const errorEl = document.getElementById('loginError');
            
            if (!username || !password) {
                errorEl.textContent = 'Please enter both username and password';
                return;
            }
            
            const hashedPassword = hashPassword(password);
            
            if (database) {
                // Check timeout first
                checkUserTimeout(username).then((timeout) => {
                    if (timeout) {
                        const minutesLeft = Math.ceil((timeout.timeoutUntil - Date.now()) / (60 * 1000));
                        errorEl.textContent = `You are timed out for ${minutesLeft} more minute(s)`;
                        return;
                    }
                    
                    database.ref(`userAccounts/${username}`).once('value', (snapshot) => {
                        if (!snapshot.exists()) {
                            errorEl.textContent = 'Invalid username or password';
                            return;
                        }
                        
                        const account = snapshot.val();
                        if (account.passwordHash !== hashedPassword) {
                            errorEl.textContent = 'Invalid username or password';
                            return;
                        }
                        
                        // Login successful
                        localStorage.setItem('loggedInUsername', username);
                        localStorage.setItem('userPasswordHash', hashedPassword);
                        showMainContent();
                    });
                });
            } else {
                // Check timeout first (localStorage)
                const timeout = checkUserTimeout(username);
                if (timeout) {
                    const minutesLeft = Math.ceil((timeout.timeoutUntil - Date.now()) / (60 * 1000));
                    errorEl.textContent = `You are timed out for ${minutesLeft} more minute(s)`;
                    return;
                }
                
                // Fallback to localStorage
                const accounts = JSON.parse(localStorage.getItem('userAccounts') || '{}');
                if (!accounts[username] || accounts[username].passwordHash !== hashedPassword) {
                    errorEl.textContent = 'Invalid username or password';
                    return;
                }
                
                localStorage.setItem('loggedInUsername', username);
                localStorage.setItem('userPasswordHash', hashedPassword);
                showMainContent();
            }
        }
        
        // Show main content after login
        function showMainContent() {
            document.getElementById('loginPage').style.display = 'none';
            document.getElementById('mainPage').classList.remove('hidden');
            // Update profile display
            updateProfileDisplay();
            // Initialize everything that needs the user to be logged in
            if (typeof initChat === 'function') initChat();
            if (typeof loadOnlineUsers === 'function') loadOnlineUsers();
        }
        
        // Update profile display with username and admin badge
        function updateProfileDisplay() {
            const profileDisplay = document.getElementById('profileDisplay');
            const profileUsernameText = document.getElementById('profileUsernameText');
            const profileAdminBadge = document.getElementById('profileAdminBadge');
            
            if (!profileDisplay || !profileUsernameText) return;
            
            const username = getLoggedInUsername();
            if (username) {
                profileDisplay.style.display = 'block';
                profileUsernameText.textContent = username;
                
                // Show admin badge if user is admin
                if (isAdmin()) {
                    profileAdminBadge.style.display = 'inline-block';
                } else {
                    profileAdminBadge.style.display = 'none';
                }
            } else {
                profileDisplay.style.display = 'none';
            }
        }
        
        // Toggle profile menu
        function toggleProfileMenu(e) {
            if (e) {
                e.stopPropagation();
            }
            const profileMenu = document.getElementById('profileMenu');
            if (profileMenu) {
                profileMenu.classList.toggle('show');
            }
        }
        
        // Close profile menu when clicking outside
        document.addEventListener('click', (e) => {
            const profileDisplay = document.getElementById('profileDisplay');
            const profileMenu = document.getElementById('profileMenu');
            if (profileDisplay && profileMenu && !profileDisplay.contains(e.target)) {
                profileMenu.classList.remove('show');
            }
        });
        
        // Logout function
        function logout() {
            // Clear login data
            localStorage.removeItem('loggedInUsername');
            localStorage.removeItem('userPasswordHash');
            
            // Hide profile display
            const profileDisplay = document.getElementById('profileDisplay');
            if (profileDisplay) {
                profileDisplay.style.display = 'none';
            }
            
            // Redirect to login page
            checkLoginStatus();
            
            // Clear form fields
            const loginUsername = document.getElementById('loginUsername');
            const loginPassword = document.getElementById('loginPassword');
            if (loginUsername) loginUsername.value = '';
            if (loginPassword) loginPassword.value = '';
        }
        
        // Block access until logged in
        function checkLoginStatus() {
            if (!isLoggedIn()) {
                // Hide all pages except login
                document.querySelectorAll('.page').forEach(page => {
                    if (page.id !== 'loginPage') {
                        page.classList.add('hidden');
                    }
                });
                document.getElementById('loginPage').style.display = 'flex';
            } else {
                // Check if user is timed out
                const username = getLoggedInUsername();
                if (username) {
                    if (database) {
                        checkUserTimeout(username).then((timeout) => {
                            if (timeout) {
                                // User is timed out, log them out
                                localStorage.removeItem('loggedInUsername');
                                localStorage.removeItem('userPasswordHash');
                                const minutesLeft = Math.ceil((timeout.timeoutUntil - Date.now()) / (60 * 1000));
                                document.getElementById('loginError').textContent = `You are timed out for ${minutesLeft} more minute(s)`;
                                checkLoginStatus();
                            } else {
                                showMainContent();
                            }
                        });
                    } else {
                        const timeout = checkUserTimeout(username);
                        if (timeout) {
                            // User is timed out, log them out
                            localStorage.removeItem('loggedInUsername');
                            localStorage.removeItem('userPasswordHash');
                            const minutesLeft = Math.ceil((timeout.timeoutUntil - Date.now()) / (60 * 1000));
                            document.getElementById('loginError').textContent = `You are timed out for ${minutesLeft} more minute(s)`;
                            checkLoginStatus();
                        } else {
                            showMainContent();
                        }
                    }
                } else {
                    showMainContent();
                }
            }
        }
        
        // Allow Enter key to submit login/register
        document.addEventListener('DOMContentLoaded', () => {
            const loginUsername = document.getElementById('loginUsername');
            const loginPassword = document.getElementById('loginPassword');
            const registerUsername = document.getElementById('registerUsername');
            const registerPassword = document.getElementById('registerPassword');
            const registerPasswordConfirm = document.getElementById('registerPasswordConfirm');
            
            if (loginUsername && loginPassword) {
                loginPassword.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') attemptLogin();
                });
            }
            
            if (registerPasswordConfirm) {
                registerPasswordConfirm.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') attemptRegister();
                });
            }
            
            // Check login status on page load
            checkLoginStatus();
        });
        
        // Firebase Configuration
        // Your Firebase config for online chat and profile sharing
        const firebaseConfig = {
            apiKey: "AIzaSyB_jv2W9Hvt0QFJlVN4ZcdrT1mtwP-fWFE",
            authDomain: "finhub-41eaf.firebaseapp.com",
            databaseURL: "https://finhub-41eaf-default-rtdb.firebaseio.com",
            projectId: "finhub-41eaf",
            storageBucket: "finhub-41eaf.firebasestorage.app",
            messagingSenderId: "96393027883",
            appId: "1:96393027883:web:4db59a7a6d020c7eba256e",
            measurementId: "G-GDEJMDDEG6"
        };
        
        // Initialize Firebase (only if config is provided)
        let firebaseApp, database;
        if (firebaseConfig && typeof firebase !== 'undefined') {
            try {
                if (!firebase.apps || firebase.apps.length === 0) {
                    firebaseApp = firebase.initializeApp(firebaseConfig);
                    database = firebase.database();
                    console.log('âœ… Firebase connected - Online features enabled!');
                } else {
                    firebaseApp = firebase.app();
                    database = firebase.database();
                }
            } catch (e) {
                console.warn('âš ï¸ Firebase initialization failed, using localStorage fallback:', e);
                database = null;
            }
        } else {
            database = null;
            console.log('â„¹ï¸ Running in offline mode (localStorage). To enable online chat, configure Firebase.');
        }
        
        // User Profile System
        function getUserId() {
            // Use logged-in username if available, otherwise fall back to old system
            const loggedInUsername = getLoggedInUsername();
            if (loggedInUsername) {
                return loggedInUsername;
            }
            
            // Fallback for backwards compatibility (shouldn't happen if login is required)
            let userId = localStorage.getItem('userId');
            if (!userId) {
                // Generate a more unique ID using timestamp + random to avoid collisions
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 6);
                userId = 'user_' + timestamp + '_' + random;
                
                // If Firebase is available, check if this ID exists and regenerate if needed
                if (database) {
                    database.ref(`users/${userId}`).once('value', (snapshot) => {
                        if (snapshot.exists()) {
                            // ID collision, regenerate with more randomness
                            const newRandom = Math.random().toString(36).substr(2, 8);
                            userId = 'user_' + Date.now().toString(36) + '_' + newRandom;
                            localStorage.setItem('userId', userId);
                        } else {
                            localStorage.setItem('userId', userId);
                        }
                    });
                } else {
                    localStorage.setItem('userId', userId);
                }
            }
            return userId;
        }
        
        function setUserId(newUserId) {
            if (!newUserId || newUserId.trim() === '') {
                return false;
            }
            
            // Validate user ID format (alphanumeric, underscore, dash, 3-20 chars)
            const validIdPattern = /^[a-zA-Z0-9_-]{3,20}$/;
            if (!validIdPattern.test(newUserId.trim())) {
                return false;
            }
            
            const oldUserId = getUserId();
            const newUserIdTrimmed = newUserId.trim();
            
            // If same username, no change needed
            if (newUserIdTrimmed === oldUserId) {
                return true;
            }
            
            // Check if new username is already taken in userAccounts
            if (database) {
                return new Promise((resolve) => {
                    // Check userAccounts first
                    database.ref(`userAccounts/${newUserIdTrimmed}`).once('value', (accountSnapshot) => {
                        if (accountSnapshot.exists() && newUserIdTrimmed !== oldUserId) {
                            resolve(false); // Username already taken
                            return;
                        }
                        
                        // Check users table for backwards compatibility
                        database.ref(`users/${newUserIdTrimmed}`).once('value', (snapshot) => {
                            if (snapshot.exists() && newUserIdTrimmed !== oldUserId) {
                                resolve(false); // ID already taken
                                return;
                            }
                            
                            // Get old account data
                            database.ref(`userAccounts/${oldUserId}`).once('value', (oldAccountSnapshot) => {
                                const oldAccount = oldAccountSnapshot.val();
                                
                                if (oldAccount) {
                                    // Update account with new username (keep password)
                                    database.ref(`userAccounts/${newUserIdTrimmed}`).set({
                                        ...oldAccount,
                                        username: newUserIdTrimmed,
                                        isAdmin: newUserIdTrimmed === 'finleymain'
                                    });
                                    // Remove old account
                                    database.ref(`userAccounts/${oldUserId}`).remove();
                                }
                                
                                // Update localStorage
                                localStorage.setItem('loggedInUsername', newUserIdTrimmed);
                                localStorage.setItem('userId', newUserIdTrimmed);
                                
                                // Migrate bio if exists
                                const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
                                if (bios[oldUserId]) {
                                    bios[newUserIdTrimmed] = bios[oldUserId];
                                    delete bios[oldUserId];
                                    localStorage.setItem('userBios', JSON.stringify(bios));
                                }
                                
                                // Update Firebase users table if connected
                                const userRef = database.ref(`users/${oldUserId}`);
                                userRef.once('value', (oldSnapshot) => {
                                    const oldData = oldSnapshot.val();
                                    if (oldData) {
                                        // Move data to new ID
                                        database.ref(`users/${newUserIdTrimmed}`).set({
                                            ...oldData,
                                            id: newUserIdTrimmed
                                        });
                                        // Remove old ID
                                        userRef.remove();
                                    }
                                });
                                
                                resolve(true);
                            });
                        });
                    });
                });
            } else {
                // Check localStorage userAccounts
                const accounts = JSON.parse(localStorage.getItem('userAccounts') || '{}');
                if (accounts[newUserIdTrimmed] && newUserIdTrimmed !== oldUserId) {
                    return false; // Username already taken
                }
                
                // Update account if exists
                if (accounts[oldUserId]) {
                    accounts[newUserIdTrimmed] = {
                        ...accounts[oldUserId],
                        username: newUserIdTrimmed,
                        isAdmin: newUserIdTrimmed === 'finleymain'
                    };
                    delete accounts[oldUserId];
                    localStorage.setItem('userAccounts', JSON.stringify(accounts));
                }
                
                // Update localStorage
                localStorage.setItem('loggedInUsername', newUserIdTrimmed);
                localStorage.setItem('userId', newUserIdTrimmed);
                
                // Migrate bio
                const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
                if (bios[oldUserId]) {
                    bios[newUserIdTrimmed] = bios[oldUserId];
                    delete bios[oldUserId];
                    localStorage.setItem('userBios', JSON.stringify(bios));
                }
                
                return true;
            }
        }
        
        function getUserBio(userId) {
            const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
            return bios[userId] || null;
        }
        
        function setUserBio(userId, bio) {
            const bios = JSON.parse(localStorage.getItem('userBios') || '{}');
            bios[userId] = bio;
            localStorage.setItem('userBios', JSON.stringify(bios));
        }
        
        function getUserAvatar(userId) {
            const avatars = JSON.parse(localStorage.getItem('userAvatars') || '{}');
            return avatars[userId] || 'ðŸ‘¤';
        }
        
        function setUserAvatar(userId, emoji) {
            const avatars = JSON.parse(localStorage.getItem('userAvatars') || '{}');
            avatars[userId] = emoji;
            localStorage.setItem('userAvatars', JSON.stringify(avatars));
        }
        
        // Friends System
        function getFriends() {
            const friends = JSON.parse(localStorage.getItem('friends') || '[]');
            return friends;
        }
        
        function addFriend(friendId) {
            const friends = getFriends();
            if (!friends.includes(friendId)) {
                friends.push(friendId);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function removeFriend(friendId) {
            const friends = getFriends();
            const index = friends.indexOf(friendId);
            if (index > -1) {
                friends.splice(index, 1);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function isFriend(userId) {
            const friends = getFriends();
            return friends.includes(userId);
        }
        
        function openFriendsList() {
            const modal = document.getElementById('friendsModal');
            const friendsList = document.getElementById('friendsList');
            
            if (!modal || !friendsList) return;
            
            const friends = getFriends();
            
            if (friends.length === 0) {
                friendsList.innerHTML = '<div style="color: #8b949e; text-align: center; padding: 40px;">No friends yet. Use "friend [id]" to add someone!</div>';
            } else {
                friendsList.innerHTML = '';
                friends.forEach(friendId => {
                    const friendItem = document.createElement('div');
                    friendItem.className = 'friend-item';
                    
                    const avatar = getUserAvatar(friendId);
                    const bio = getUserBio(friendId) || 'No bio';
                    
                    friendItem.innerHTML = `
                        <div class="friend-avatar">${avatar}</div>
                        <div class="friend-info">
                            <div class="friend-name">${friendId}</div>
                            <div class="friend-bio">${bio.substring(0, 50)}${bio.length > 50 ? '...' : ''}</div>
                        </div>
                    `;
                    
                    friendItem.onclick = () => {
                        openPrivateChat(friendId);
                        closeFriendsList();
                    };
                    
                    friendsList.appendChild(friendItem);
                });
            }
            
            modal.classList.add('show');
        }
        
        function closeFriendsList() {
            const modal = document.getElementById('friendsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function openPrivateChat(friendId) {
            currentPrivateChatWith = friendId;
            const title = document.getElementById('privateChatTitle');
            const avatar = getUserAvatar(friendId);
            if (title) {
                title.textContent = `ðŸ’¬ Private Chat with ${avatar} ${friendId}`;
            }
            showPage('privateChatPage');
            loadPrivateChatMessages(friendId);
        }
        
        function loadPrivateChatMessages(friendId) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            
            if (database) {
                const messagesRef = database.ref(`privateChats/${chatId}/messages`).limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addPrivateMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messagesContainer.innerHTML = '';
                messages.forEach(msg => {
                    addPrivateMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addPrivateMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const avatar = getUserAvatar(message.userId);
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user">${avatar} ${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendPrivateMessage(text, friendId) {
            if (!text || !text.trim()) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            const message = {
                userId: currentUserId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                database.ref(`privateChats/${chatId}/messages`).push(message);
            } else {
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messages.push(message);
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem(`privateChat_${chatId}`, JSON.stringify(messages));
                addPrivateMessageToUI(message, true);
            }
        }
        
        // Visit Counter
        function updateVisitCounter() {
            const counter = document.getElementById('visitCounterNumber');
            if (!counter) return;
            
            if (database) {
                const visitsRef = database.ref('siteStats/visits');
                visitsRef.transaction((current) => {
                    return (current || 0) + 1;
                }, (error, committed, snapshot) => {
                    if (!error && committed && snapshot) {
                        counter.textContent = snapshot.val().toLocaleString();
                    }
                });
                
                // Listen for updates
                visitsRef.on('value', (snapshot) => {
                    const visits = snapshot.val() || 0;
                    counter.textContent = visits.toLocaleString();
                });
            } else {
                // Fallback to localStorage
                let visits = parseInt(localStorage.getItem('siteVisits') || '0');
                visits++;
                localStorage.setItem('siteVisits', visits.toString());
                counter.textContent = visits.toLocaleString();
            }
        }
        
        function getAllUserBios() {
            return JSON.parse(localStorage.getItem('userBios') || '{}');
        }
        
        // Friends System
        let currentPrivateChatWith = null;
        function getFriends() {
            const friends = JSON.parse(localStorage.getItem('friends') || '[]');
            return friends;
        }
        
        function addFriend(friendId) {
            const friends = getFriends();
            if (!friends.includes(friendId)) {
                friends.push(friendId);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function removeFriend(friendId) {
            const friends = getFriends();
            const index = friends.indexOf(friendId);
            if (index > -1) {
                friends.splice(index, 1);
                localStorage.setItem('friends', JSON.stringify(friends));
                
                // Sync to Firebase if available
                if (database) {
                    try {
                        const userId = getUserId();
                        database.ref(`users/${userId}/friends`).set(friends);
                    } catch (e) {
                        console.warn('Could not sync friends to Firebase:', e);
                    }
                }
                return true;
            }
            return false;
        }
        
        function isFriend(userId) {
            const friends = getFriends();
            return friends.includes(userId);
        }
        
        function openFriendsList() {
            const modal = document.getElementById('friendsModal');
            const friendsList = document.getElementById('friendsList');
            
            if (!modal || !friendsList) return;
            
            const friends = getFriends();
            
            if (friends.length === 0) {
                friendsList.innerHTML = '<div style="color: #8b949e; text-align: center; padding: 40px;">No friends yet. Use "friend [id]" to add someone!</div>';
            } else {
                friendsList.innerHTML = '';
                friends.forEach(friendId => {
                    const friendItem = document.createElement('div');
                    friendItem.className = 'friend-item';
                    
                    const avatar = getUserAvatar(friendId);
                    const bio = getUserBio(friendId) || 'No bio';
                    
                    friendItem.innerHTML = `
                        <div class="friend-avatar">${avatar}</div>
                        <div class="friend-info">
                            <div class="friend-name">${friendId}</div>
                            <div class="friend-bio">${bio.substring(0, 50)}${bio.length > 50 ? '...' : ''}</div>
                        </div>
                    `;
                    
                    friendItem.onclick = () => {
                        openPrivateChat(friendId);
                        closeFriendsList();
                    };
                    
                    friendsList.appendChild(friendItem);
                });
            }
            
            modal.classList.add('show');
        }
        
        function closeFriendsList() {
            const modal = document.getElementById('friendsModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        function openPrivateChat(friendId) {
            currentPrivateChatWith = friendId;
            const title = document.getElementById('privateChatTitle');
            const avatar = getUserAvatar(friendId);
            if (title) {
                title.textContent = `ðŸ’¬ Private Chat with ${avatar} ${friendId}`;
            }
            showPage('privateChatPage');
            loadPrivateChatMessages(friendId);
        }
        
        function loadPrivateChatMessages(friendId) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            
            if (database) {
                const messagesRef = database.ref(`privateChats/${chatId}/messages`).limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addPrivateMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messagesContainer.innerHTML = '';
                messages.forEach(msg => {
                    addPrivateMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addPrivateMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('privateChatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const avatar = getUserAvatar(message.userId);
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user">${avatar} ${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendPrivateMessage(text, friendId) {
            if (!text || !text.trim()) return;
            
            const currentUserId = getUserId();
            const chatId = [currentUserId, friendId].sort().join('_');
            const message = {
                userId: currentUserId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                database.ref(`privateChats/${chatId}/messages`).push(message);
            } else {
                const messages = JSON.parse(localStorage.getItem(`privateChat_${chatId}`) || '[]');
                messages.push(message);
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem(`privateChat_${chatId}`, JSON.stringify(messages));
                addPrivateMessageToUI(message, true);
            }
        }
        
        // Visit Counter
        function updateVisitCounter() {
            const counter = document.getElementById('visitCounterNumber');
            if (!counter) return;
            
            if (database) {
                const visitsRef = database.ref('siteStats/visits');
                visitsRef.transaction((current) => {
                    return (current || 0) + 1;
                }, (error, committed, snapshot) => {
                    if (!error && committed && snapshot) {
                        counter.textContent = snapshot.val().toLocaleString();
                    }
                });
                
                // Listen for updates
                visitsRef.on('value', (snapshot) => {
                    const visits = snapshot.val() || 0;
                    counter.textContent = visits.toLocaleString();
                });
            } else {
                // Fallback to localStorage
                let visits = parseInt(localStorage.getItem('siteVisits') || '0');
                visits++;
                localStorage.setItem('siteVisits', visits.toString());
                counter.textContent = visits.toLocaleString();
            }
        }
        
        // Whoami profile
        function showWhoami(targetUserId = null) {
            const currentUserId = getUserId();
            const userId = targetUserId || currentUserId;
            
            // Try to get profile from Firebase first (for online users)
            if (database && userId !== currentUserId) {
                database.ref(`users/${userId}`).once('value', (snapshot) => {
                    const userData = snapshot.val();
                    if (userData) {
                        const bio = userData.bio || getUserBio(userId);
                        const isOnline = userData.online || (Date.now() - (userData.lastSeen || 0) < 60000);
                        const status = isOnline ? 'ðŸŸ¢ Online' : 'âš« Offline';
                        const profile = `ID: ${userId} | ${status} | Bio: ${bio || '(No bio set)'}`;
                        showCommandFeedback('whoami', profile, true);
                    } else {
                        // Fallback to localStorage
                        const bio = getUserBio(userId);
                        if (bio) {
                            showCommandFeedback('whoami', `ID: ${userId} | Bio: ${bio}`, true);
                        } else {
                            showCommandFeedback('whoami', `ID: ${userId} | Bio: (User not found or has no bio)`, false);
                        }
                    }
                });
            } else {
                // Use localStorage
                let profile;
                if (userId === currentUserId) {
                    // Show own profile
                    const bio = getUserBio(userId);
                    if (bio) {
                        profile = `ID: ${userId} | Bio: ${bio}`;
                    } else {
                        profile = `ID: ${userId} | Bio: (No bio set. Use "iam [your bio]" to set one)`;
                    }
                } else {
                    // Show other user's profile
                    const bio = getUserBio(userId);
                    if (bio) {
                        profile = `ID: ${userId} | Bio: ${bio}`;
                    } else {
                        profile = `ID: ${userId} | Bio: (User not found or has no bio)`;
                    }
                }
                showCommandFeedback('whoami', profile, true);
            }
            
            const commandInput = document.getElementById('commandInput');
            if (commandInput) {
                commandInput.value = '';
                commandInput.placeholder = 'Profile displayed!';
                setTimeout(() => {
                    commandInput.placeholder = 'Type a color or "home"...';
                }, 2000);
            }
        }
        
        function setBio(bioText) {
            if (!bioText || bioText.trim() === '') {
                showCommandFeedback('iam', 'Please provide a bio. Usage: iam [your bio]', false);
                return;
            }
            
            const userId = getUserId();
            setUserBio(userId, bioText.trim());
            
            // Sync bio to Firebase if available
            if (database) {
                try {
                    database.ref(`users/${userId}`).update({
                        bio: bioText.trim(),
                        lastSeen: Date.now()
                    });
                } catch (e) {
                    console.warn('Could not sync bio to Firebase:', e);
                }
            }
            
            showCommandFeedback('iam', `Bio updated! Your ID is: ${userId}`, true);
            
            const commandInput = document.getElementById('commandInput');
            if (commandInput) {
                commandInput.value = '';
                commandInput.placeholder = `Bio set! Your ID: ${userId}`;
                setTimeout(() => {
                    commandInput.placeholder = 'Type a color or "home"...';
                }, 3000);
            }
        }
        
        // Chat System
        let chatListeners = [];
        let onlineUsersListeners = [];
        
        let onlineStatusInterval = null;
        
        function initChat() {
            if (!database) {
                console.warn('Firebase not available - chat will use localStorage only');
                return;
            }
            
            const userId = getUserId();
            const userBio = getUserBio(userId);
            
            // Mark user as online
            const userRef = database.ref(`users/${userId}`);
            const updateOnlineStatus = () => {
                userRef.set({
                    id: userId,
                    bio: userBio || getUserBio(userId) || '',
                    online: true,
                    lastSeen: Date.now()
                }).catch(err => {
                    console.warn('Failed to update online status:', err);
                });
            };
            
            // Initial update
            updateOnlineStatus();
            
            // Update online status every 30 seconds (heartbeat)
            if (onlineStatusInterval) {
                clearInterval(onlineStatusInterval);
            }
            onlineStatusInterval = setInterval(updateOnlineStatus, 30000);
            
            // Remove online status when page unloads
            window.addEventListener('beforeunload', () => {
                if (onlineStatusInterval) {
                    clearInterval(onlineStatusInterval);
                }
                userRef.update({ online: false, lastSeen: Date.now() });
            });
        }
        
        function loadChatMessages() {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            if (database) {
                // Load from Firebase
                const messagesRef = database.ref('messages').limitToLast(50);
                messagesRef.on('value', (snapshot) => {
                    const messages = snapshot.val() || {};
                    messagesContainer.innerHTML = '';
                    
                    const currentUserId = getUserId();
                    const messagesArray = Object.entries(messages)
                        .map(([id, msg]) => ({ id, ...msg }))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    messagesArray.forEach(msg => {
                        addMessageToUI(msg, msg.userId === currentUserId);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                });
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
                messagesContainer.innerHTML = '';
                const currentUserId = getUserId();
                messages.forEach(msg => {
                    addMessageToUI(msg, msg.userId === currentUserId);
                });
            }
        }
        
        function addMessageToUI(message, isOwn = false) {
            const messagesContainer = document.getElementById('chatMessages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(message.timestamp);
            const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-message-user" onclick="showWhoami('${message.userId}')">${message.userId}</span>
                    <span class="chat-message-time">${timeStr}</span>
                </div>
                <div class="chat-message-text">${escapeHtml(message.text)}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function sendChatMessage(text) {
            if (!text || !text.trim()) return;
            
            const userId = getUserId();
            const message = {
                userId: userId,
                text: text.trim(),
                timestamp: Date.now()
            };
            
            if (database) {
                // Send to Firebase
                database.ref('messages').push(message);
            } else {
                // Fallback to localStorage
                const messages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
                messages.push(message);
                // Keep only last 100 messages
                if (messages.length > 100) {
                    messages.shift();
                }
                localStorage.setItem('chatMessages', JSON.stringify(messages));
                addMessageToUI(message, true);
            }
        }
        
        let onlineUsersListener = null;
        let onlineUsersRefreshInterval = null;
        
        function loadOnlineUsers() {
            const usersList = document.getElementById('onlineUsersList');
            if (!usersList) return;
            
            if (database) {
                // Remove old listener if exists
                if (onlineUsersListener) {
                    database.ref('users').off('value', onlineUsersListener);
                }
                
                const updateOnlineUsersList = (snapshot) => {
                    const users = snapshot.val() || {};
                    const currentTime = Date.now();
                    const onlineThreshold = 60000; // 1 minute
                    const currentUserId = getUserId();
                    const friends = getFriends();
                    
                    usersList.innerHTML = '';
                    
                    Object.entries(users).forEach(([id, user]) => {
                        const isOnline = user.online || (currentTime - (user.lastSeen || 0) < onlineThreshold);
                        if (isOnline) {
                            const userDiv = document.createElement('div');
                            userDiv.className = 'online-user-item';
                            // Include unique identifier in data attribute for debugging
                            userDiv.setAttribute('data-user-id', id);
                            userDiv.innerHTML = `<span class="user-id">${escapeHtml(id)}</span>${user.bio ? `: ${escapeHtml(user.bio.substring(0, 30))}` : ''}`;
                            userDiv.onclick = () => showWhoami(id);
                            
                            // Add right-click context menu for friend requests
                            if (id !== currentUserId) {
                                userDiv.addEventListener('contextmenu', (e) => {
                                    e.preventDefault();
                                    showOnlineUserContextMenu(e, id, friends.includes(id));
                                });
                            }
                            
                            usersList.appendChild(userDiv);
                        }
                    });
                };
                
                // Set up real-time listener
                onlineUsersListener = updateOnlineUsersList;
                database.ref('users').on('value', onlineUsersListener);
                
                // Also refresh every 5 seconds to catch any missed updates
                if (onlineUsersRefreshInterval) {
                    clearInterval(onlineUsersRefreshInterval);
                }
                onlineUsersRefreshInterval = setInterval(() => {
                    database.ref('users').once('value', updateOnlineUsersList);
                }, 5000);
            } else {
                // Fallback: show local users
                usersList.innerHTML = '<div class="online-user-item"><span class="user-id">' + getUserId() + '</span> (Local only)</div>';
            }
        }
        
        function showOnlineUserContextMenu(event, userId, isAlreadyFriend) {
            const contextMenu = document.getElementById('onlineUserContextMenu');
            const addFriendItem = document.getElementById('addFriendContextItem');
            const viewBoardItem = document.getElementById('viewBoardContextItem');
            const currentUserId = getUserId();
            const friends = getFriends();
            const isFriend = friends.includes(userId);
            const isOwnProfile = userId === currentUserId;
            
            if (!contextMenu || !addFriendItem || !viewBoardItem) return;
            
            // Hide other context menus
            document.querySelectorAll('.context-menu').forEach(menu => {
                if (menu.id !== 'onlineUserContextMenu') {
                    menu.classList.add('hidden');
                }
            });
            
            // Update context menu item text
            if (isAlreadyFriend) {
                addFriendItem.textContent = 'Already Friends';
                addFriendItem.style.cursor = 'default';
                addFriendItem.style.color = '#666';
                addFriendItem.onclick = null;
            } else {
                addFriendItem.textContent = 'Add Friend';
                addFriendItem.style.cursor = 'pointer';
                addFriendItem.style.color = '#000';
                addFriendItem.onclick = () => {
                    // Verify user exists before adding
                    if (database) {
                        database.ref(`users/${userId}`).once('value', (snapshot) => {
                            if (snapshot.exists()) {
                                const userData = snapshot.val();
                                const userBio = userData.bio || '(No bio)';
                                if (addFriend(userId)) {
                                    alert(`Added ${userId} as a friend!\nBio: ${userBio.substring(0, 50)}`);
                                    loadOnlineUsers(); // Refresh the list
                                } else {
                                    alert(`Failed to add ${userId} as a friend. They might already be your friend.`);
                                }
                            } else {
                                alert(`User ${userId} not found. They may have disconnected.`);
                            }
                            contextMenu.classList.add('hidden');
                        });
                    } else {
                        // No Firebase, just add directly
                        if (addFriend(userId)) {
                            alert(`Added ${userId} as a friend!`);
                            loadOnlineUsers(); // Refresh the list
                        } else {
                            alert(`Failed to add ${userId} as a friend.`);
                        }
                        contextMenu.classList.add('hidden');
                    }
                };
            }
            
            // Position and show context menu
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
            contextMenu.classList.remove('hidden');
            
            // Hide menu when clicking elsewhere
            const hideMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.classList.add('hidden');
                    document.removeEventListener('click', hideMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', hideMenu);
            }, 100);
        }
        
        // Board System
        function getBoard(userId) {
            if (!userId) userId = getUserId();
            if (database) {
                return new Promise((resolve) => {
                    database.ref(`boards/${userId}`).once('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            resolve(data);
                        } else {
                            const boards = JSON.parse(localStorage.getItem('userBoards') || '{}');
                            resolve(boards[userId] || { text: '', images: [] });
                        }
                    });
                });
            } else {
                const boards = JSON.parse(localStorage.getItem('userBoards') || '{}');
                return Promise.resolve(boards[userId] || { text: '', images: [] });
            }
        }
        
        function saveBoardData(userId, boardData) {
            if (!userId) userId = getUserId();
            const boardObj = { text: boardData.text || '', images: boardData.images || [], updatedAt: Date.now() };
            const boards = JSON.parse(localStorage.getItem('userBoards') || '{}');
            boards[userId] = boardObj;
            localStorage.setItem('userBoards', JSON.stringify(boards));
            if (database) database.ref(`boards/${userId}`).set(boardObj);
        }
        
        function openBoardEditor() {
            const userId = getUserId();
            showPage('boardEditPage');
            getBoard(userId).then(board => {
                const textInput = document.getElementById('boardTextInput');
                const existingImagesContainer = document.getElementById('boardExistingImagesContainer');
                const previewContainer = document.getElementById('boardImagesPreview');
                if (textInput) textInput.value = board.text || '';
                if (previewContainer) previewContainer.innerHTML = '';
                if (existingImagesContainer) {
                    existingImagesContainer.innerHTML = '';
                    if (board.images && board.images.length > 0) {
                        board.images.forEach((imageData, index) => {
                            const imgDiv = document.createElement('div');
                            imgDiv.style.position = 'relative';
                            imgDiv.innerHTML = `<img src="${imageData}" alt="Board image" style="width: 100%; height: 150px; object-fit: cover; border-radius: 6px; border: 1px solid #30363d;"><button onclick="removeBoardImage(${index})" style="position: absolute; top: 5px; right: 5px; background: #f85149; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px; line-height: 1;">Ã—</button>`;
                            existingImagesContainer.appendChild(imgDiv);
                        });
                    } else {
                        existingImagesContainer.innerHTML = '<div style="color: #666; font-size: 12px;">No images yet</div>';
                    }
                }
            });
            const imageInput = document.getElementById('boardImageInput');
            if (imageInput) {
                imageInput.onchange = (e) => {
                    const files = Array.from(e.target.files);
                    const previewContainer = document.getElementById('boardImagesPreview');
                    files.forEach(file => {
                        if (file.type.startsWith('image/')) {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                const imgDiv = document.createElement('div');
                                imgDiv.style.position = 'relative';
                                imgDiv.innerHTML = `<img src="${event.target.result}" alt="Preview" style="width: 100%; height: 150px; object-fit: cover; border-radius: 6px; border: 1px solid #30363d;"><div style="position: absolute; top: 5px; left: 5px; background: #238636; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px;">New</div>`;
                                if (previewContainer) previewContainer.appendChild(imgDiv);
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                };
            }
        }
        
        window.removeBoardImage = (index) => {
            const userId = getUserId();
            getBoard(userId).then(board => {
                const images = board.images || [];
                images.splice(index, 1);
                saveBoardData(userId, { text: board.text, images: images });
                openBoardEditor();
            });
        };
        
        function saveBoardToStorage() {
            const userId = getUserId();
            const textInput = document.getElementById('boardTextInput');
            const previewContainer = document.getElementById('boardImagesPreview');
            const text = textInput ? textInput.value : '';
            getBoard(userId).then(board => {
                const existingImages = board.images || [];
                const newImages = [];
                if (previewContainer) {
                    previewContainer.querySelectorAll('img').forEach(img => {
                        if (img.src && !existingImages.includes(img.src)) newImages.push(img.src);
                    });
                }
                saveBoardData(userId, { text, images: [...existingImages, ...newImages] });
                alert('Board saved successfully!');
                showPage('mainPage');
            });
        }
        window.saveBoard = saveBoardToStorage;
        
        function viewBoard(userId) {
            if (!userId) userId = getUserId();
            const currentUserId = getUserId();
            const friends = getFriends();
            if (userId !== currentUserId && !friends.includes(userId)) {
                alert('You can only view boards of friends or your own board!');
                return;
            }
            showPage('boardViewPage');
            const titleEl = document.getElementById('boardViewTitle');
            const contentEl = document.getElementById('boardContent');
            if (titleEl) titleEl.textContent = userId === currentUserId ? 'ðŸ“‹ Your Board' : `ðŸ“‹ ${escapeHtml(userId)}'s Board`;
            if (contentEl) contentEl.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;">Loading board...</div>';
            getBoard(userId).then(board => {
                if (contentEl) {
                    let html = '';
                    if (board.text && board.text.trim()) html += `<div style="margin-bottom: 20px; padding: 15px; background: #0d1117; border-radius: 6px; border: 1px solid #30363d; white-space: pre-wrap; line-height: 1.6; color: #c9d1d9;">${escapeHtml(board.text)}</div>`;
                    if (board.images && board.images.length > 0) {
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">';
                        board.images.forEach(imageData => {
                            html += `<img src="${imageData}" alt="Board image" style="width: 100%; height: auto; border-radius: 6px; border: 1px solid #30363d; cursor: pointer;" onclick="window.open('${imageData}', '_blank')">`;
                        });
                        html += '</div>';
                    }
                    if (!board.text && (!board.images || board.images.length === 0)) html = '<div style="text-align: center; color: #666; padding: 40px;">This board is empty.</div>';
                    contentEl.innerHTML = html;
                }
            });
        }
        window.viewBoard = viewBoard;
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize chat when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initChat();
            loadOnlineUsers();
            
            const chatInput = document.getElementById('chatInput');
            const chatSendBtn = document.getElementById('chatSendBtn');
            
            if (chatInput && chatSendBtn) {
                chatSendBtn.onclick = () => {
                    const text = chatInput.value;
                    if (text.trim()) {
                        sendChatMessage(text);
                        chatInput.value = '';
                    }
                };
                
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        chatSendBtn.click();
                    }
                });
            }
        });
        
        // Load clock setting on page load
        loadClockSetting();
        
        // Command input handler
        const commandInput = document.getElementById('commandInput');
        
        // Semicolon key to focus command bar (works even when paper app is active)
        document.addEventListener('keydown', (e) => {
            // Only trigger if semicolon is pressed and not already typing in command input
            if (e.key === ';' && document.activeElement !== commandInput) {
                const activeEl = document.activeElement;
                
                // Block semicolon only if in a regular input/textarea (not contentEditable like paper app)
                const isRegularInput = activeEl && (
                    (activeEl.tagName === 'INPUT' && activeEl.id !== 'commandInput') || 
                    activeEl.tagName === 'TEXTAREA'
                );
                
                // Allow semicolon from anywhere except regular inputs/textareas
                // This includes paper app (contentEditable) and other places
                if (!isRegularInput) {
                    e.preventDefault();
                    commandInput.focus();
                    commandInput.select(); // Select any existing text
                }
            }
        });
        
        commandInput.addEventListener('keydown', (e) => {
            // Disable commands when on remote desktop
            const remoteDesktopPage = document.getElementById('remoteDesktopPage');
            if (remoteDesktopPage && !remoteDesktopPage.classList.contains('hidden')) {
                // Allow semicolon to work, but block other commands
                if (e.key !== ';' && e.key !== 'Enter') {
                    return;
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    showCommandFeedback('command', 'Commands disabled on desktop. Use ; to exit.', false);
                    return;
                }
            }
            
            if (e.key === 'Enter') {
                const command = commandInput.value.toLowerCase().trim();
                const hasColorPalette = colorPalettes.hasOwnProperty(command);
                
                // Handle navigation commands
                if (command === 'reset') {
                    if (resetConfirm) {
                        // Second time - actually reset EVERYTHING
                        resetEverything();
                        commandInput.value = '';
                        resetConfirm = false;
                        showCommandFeedback('reset', 'âš ï¸ EVERYTHING HAS BEEN RESET! Page will reload...', true);
                        // Reload page after a short delay to ensure everything is cleared
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    } else {
                        // First time - ask for confirmation
                        resetConfirm = true;
                        commandInput.value = '';
                        commandInput.placeholder = 'âš ï¸ Type "reset" again to confirm - THIS WILL DELETE EVERYTHING!';
                        showCommandFeedback('reset', 'âš ï¸ WARNING: This will clear ALL data including desktop, changelog, suggestions, achievements, money, friends, messages, and MORE!', false);
                        setTimeout(() => {
                            resetConfirm = false;
                            if (commandInput.placeholder.includes('confirm')) {
                                commandInput.placeholder = 'Type a color or "home"...';
                            }
                        }, 10000);
                    }
                } else if (command === 'home') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('homePage');
                    showCommandFeedback('home', 'Navigated to home page', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'back') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    showPage('mainPage');
                    showCommandFeedback('back', 'Returned to main page', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type a color or "home"...';
                } else if (command === 'sweeper') {
                    resetConfirm = false;
                    showPage('minesweeperPage');
                    initMinesweeper();
                    showCommandFeedback('sweeper', 'Minesweeper game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'pong') {
                    resetConfirm = false;
                    showPage('pongPage');
                    showCommandFeedback('pong', 'Pong game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'sandboxles') {
                    resetConfirm = false;
                    showPage('sandboxelsPage');
                    showCommandFeedback('sandboxles', 'Sandboxels opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'paint') {
                    resetConfirm = false;
                    showPage('paintPage');
                    initPaint();
                    showCommandFeedback('paint', 'Paint game opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'drawing board' || command === 'drawingboard' || command === 'collab') {
                    resetConfirm = false;
                    showPage('drawingBoardPage');
                    showCommandFeedback('drawing board', 'Collaborative drawing board opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'remote desktop' || command === 'remotedesktop' || command === 'desktop') {
                    resetConfirm = false;
                    showPage('remoteDesktopPage');
                    setTimeout(() => {
                        initRemoteDesktop();
                    }, 100);
                    showCommandFeedback('remote desktop', 'Remote desktop opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'snake') {
                    resetConfirm = false;
                    // Execute snake game JavaScript
                    (function() {
                        if(window.snakeGameActive) return;
                        window.snakeGameActive = true;

                        const snakeColor = '#00FF00';
                        const headColor = '#FFFF00';
                        const snakeSpeed = 80; // faster for smoother movement
                        const snakeSize = 20;
                        const maxLength = 50;

                        let snake = [{x: 100, y: 100}];
                        let direction = 'right';
                        let grow = 0;

                        const canvas = document.createElement('canvas');
                        canvas.style.position = 'fixed';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.zIndex = '9999';
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        document.body.appendChild(canvas);
                        const ctx = canvas.getContext('2d');

                        // Polyfill for roundRect if not available
                        if (!ctx.roundRect) {
                            ctx.roundRect = function(x, y, width, height, radius) {
                                this.beginPath();
                                this.moveTo(x + radius, y);
                                this.lineTo(x + width - radius, y);
                                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                                this.lineTo(x + width, y + height - radius);
                                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                this.lineTo(x + radius, y + height);
                                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                                this.lineTo(x, y + radius);
                                this.quadraticCurveTo(x, y, x + radius, y);
                                this.closePath();
                            };
                        }

                        window.addEventListener('keydown', e => {
                            if(e.key === 'ArrowUp' && direction !== 'down') direction = 'up';
                            if(e.key === 'ArrowDown' && direction !== 'up') direction = 'down';
                            if(e.key === 'ArrowLeft' && direction !== 'right') direction = 'left';
                            if(e.key === 'ArrowRight' && direction !== 'left') direction = 'right';
                            // Allow escape to close
                            if(e.key === 'Escape') {
                                canvas.remove();
                                window.snakeGameActive = false;
                            }
                        });

                        function wrapWords() {
                            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
                            const textNodes = [];
                            while(walker.nextNode()) textNodes.push(walker.currentNode);

                            textNodes.forEach(node => {
                                if(node.nodeValue.trim() === '') return;
                                const words = node.nodeValue.split(/(\s+)/);
                                const fragment = document.createDocumentFragment();
                                words.forEach(word => {
                                    if(word.trim() === '') {
                                        fragment.appendChild(document.createTextNode(word));
                                    } else {
                                        const span = document.createElement('span');
                                        span.textContent = word;
                                        span.style.display = 'inline-block';
                                        fragment.appendChild(span);
                                    }
                                });
                                node.parentNode.replaceChild(fragment, node);
                            });
                        }

                        wrapWords();

                        function moveSnake() {
                            const head = {...snake[0]};
                            const step = 10; // smaller step for better collision
                            if(direction === 'up') head.y -= step;
                            if(direction === 'down') head.y += step;
                            if(direction === 'left') head.x -= step;
                            if(direction === 'right') head.x += step;

                            snake.unshift(head);

                            if(grow > 0) grow--;
                            else snake.pop();

                            if(snake.length > maxLength) snake.pop();

                            // Eat one word at a time
                            const elements = Array.from(document.body.querySelectorAll('span')).filter(el => el !== canvas);
                            for(let el of elements) {
                                const rect = el.getBoundingClientRect();
                                const padding = 4; // smaller hitbox
                                if(head.x + padding < rect.right && head.x + snakeSize - padding > rect.left &&
                                   head.y + padding < rect.bottom && head.y + snakeSize - padding > rect.top) {
                                    el.style.visibility = 'hidden';
                                    grow += 1;
                                    break;
                                }
                            }
                        }

                        function drawSnake() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // Draw tail with gradient effect
                            for(let i = 0; i < snake.length; i++) {
                                const seg = snake[i];
                                const t = i / snake.length;
                                ctx.fillStyle = `rgba(${Math.floor(0 + t*255)}, ${Math.floor(255 - t*100)}, 0, 1)`;
                                ctx.beginPath();
                                ctx.roundRect(seg.x, seg.y, snakeSize, snakeSize, 6); // rounded corners
                                ctx.fill();
                            }

                            // Draw head
                            const head = snake[0];
                            ctx.fillStyle = headColor;
                            ctx.beginPath();
                            ctx.roundRect(head.x, head.y, snakeSize, snakeSize, 8);
                            ctx.fill();
                        }

                        function gameLoop() {
                            moveSnake();
                            drawSnake();
                        }

                        setInterval(gameLoop, snakeSpeed);

                        console.log("Snake game started! Arrow keys move. Snake eats one word at a time, hitbox improved. Press ESC to exit.");
                    })();
                    commandsUsed.add('snake');
                    commandInput.value = '';
                    commandInput.placeholder = 'Snake game started! Press ESC to exit.';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 3000);
                } else if (command === 'finley') {
                    resetConfirm = false;
                    transformToFinHubMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Welcome back to FinHub!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'coinflip') {
                    resetConfirm = false;
                    showPage('coinflipPage');
                    resetCoinFlip();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'clicker') {
                    resetConfirm = false;
                    showPage('clickerPage');
                    updateAllMoneyDisplays();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'achievements' || command === 'ach') {
                    resetConfirm = false;
                    showPage('achievementsPage');
                    renderAchievements();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'changelog') {
                    resetConfirm = false;
                    showPage('changelogPage');
                    loadChangelog();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'suggest') {
                    resetConfirm = false;
                    showPage('suggestionsPage');
                    loadSuggestions();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'party') {
                    resetConfirm = false;
                    openPartyGUI();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'background' || command === 'bg') {
                    resetConfirm = false;
                    showPage('backgroundPage');
                    initBackground();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'goose') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    transformToGooseMode();
                    commandInput.value = '';
                    commandInput.placeholder = 'Honk! GooseHub activated!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'honk') {
                    resetConfirm = false; // Clear reset confirmation if other command is used
                    if (unlockedCommands.has('honk')) {
                        playHonkSound();
                        showCommandFeedback('honk', 'HONK! ðŸ¦¢', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'HONK! ðŸ¦¢';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                                    } else {
                        showCommandFeedback('honk', 'Command not unlocked yet! Use "goose" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'Honk command not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'gooserain') {
                    resetConfirm = false;
                    if (unlockedCommands.has('gooserain')) {
                        showPage('gooserainPage');
                        initGooseRain();
                        showCommandFeedback('gooserain', 'Goose rain activated!', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'Type "back" to return';
                    } else {
                        showCommandFeedback('gooserain', 'Command not unlocked yet! Use "goose" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'Goose rain not unlocked yet! Use "goose" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'stones') {
                    resetConfirm = false;
                    showPage('stonesPage');
                    initStones();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'wooper') {
                    resetConfirm = false;
                    applyWooperColors();
                    unlockCommand('wooperbird');
                    commandInput.value = '';
                    commandInput.placeholder = 'Wooper colors applied! ðŸŸ';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'wooperbird') {
                    resetConfirm = false;
                    if (unlockedCommands.has('wooperbird')) {
                        spawnWooperbirdGoose();
                        showCommandFeedback('wooperbird', 'WooperBird dropped! ðŸ¦', true);
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird dropped! ðŸ¦';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    } else {
                        showCommandFeedback('wooperbird', 'Command not unlocked yet! Use "wooper" first.', false);
                        commandInput.value = '';
                        commandInput.placeholder = 'WooperBird not unlocked yet! Use "wooper" first.';
                        setTimeout(() => {
                            commandInput.placeholder = 'Type a color or "home"...';
                        }, 2000);
                    }
                } else if (command === 'panicmenu' || command === 'panic') {
                    resetConfirm = false;
                    showPage('panicmenuPage');
                    initPanicMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Type "back" to return';
                } else if (command === 'jumpscare') {
                    resetConfirm = false;
                    triggerJumpscare();
                    commandInput.value = '';
                    commandInput.placeholder = 'BOO! ðŸ‘»';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === '67') {
                    resetConfirm = false;
                    // Get current count
                    let count67 = parseInt(localStorage.getItem('count67') || '0');
                    count67++;
                    localStorage.setItem('count67', count67.toString());
                    
                    commandInput.value = '';
                    commandInput.placeholder = 'DONT SAY THAT';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                    
                    // Block after 3 uses
                    if (count67 >= 3) {
                        localStorage.setItem('isBlocked', 'true');
                        showPage('limboPage');
                        const commandBar = document.querySelector('.command-bar');
                        if (commandBar) commandBar.style.display = 'none';
                    }
                } else if (command === 'cmds') {
                    resetConfirm = false;
                    toggleCommandsMenu();
                    commandInput.value = '';
                    commandInput.placeholder = 'Commands menu toggled!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'clock') {
                    resetConfirm = false;
                    const wasEnabled = clockEnabled;
                    if (clockEnabled) {
                        hideClock();
                        showCommandFeedback('clock', `Clock: ${wasEnabled} â†’ false`, true);
                    } else {
                        showClock();
                        showCommandFeedback('clock', `Clock: ${wasEnabled} â†’ true`, true);
                    }
                    commandInput.value = '';
                    commandInput.placeholder = `Clock: ${clockEnabled}`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command.startsWith('whoami ')) {
                    resetConfirm = false;
                    const targetId = command.substring(7).trim();
                    showWhoami(targetId);
                } else if (command === 'edit') {
                    resetConfirm = false;
                    openEditMenu();
                } else if (command === 'boardedit') {
                    resetConfirm = false;
                    openBoardEditor();
                    showCommandFeedback('boardedit', 'Board editor opened', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Edit your board';
                } else if (command.startsWith('friend ')) {
                    resetConfirm = false;
                    const friendId = command.substring(7).trim();
                    if (!friendId) {
                        showCommandFeedback('friend', 'Please provide a user ID. Usage: friend [user id]', false);
                    } else if (friendId === getUserId()) {
                        showCommandFeedback('friend', 'You cannot add yourself as a friend!', false);
                    } else {
                        // Check if user exists and get their info to verify
                        if (database) {
                            database.ref(`users/${friendId}`).once('value', (snapshot) => {
                                if (snapshot.exists()) {
                                    const userData = snapshot.val();
                                    const userBio = userData.bio || '(No bio)';
                                    const isOnline = userData.online || (Date.now() - (userData.lastSeen || 0) < 60000);
                                    const status = isOnline ? 'ðŸŸ¢ Online' : 'âš« Offline';
                                    
                                    if (addFriend(friendId)) {
                                        showCommandFeedback('friend', `Added ${friendId} (${status}) as a friend! Bio: ${userBio.substring(0, 30)}`, true);
                                    } else {
                                        showCommandFeedback('friend', `${friendId} is already your friend!`, false);
                                    }
                                } else {
                                    // User doesn't exist in Firebase, but still allow adding (might be offline)
                                    if (addFriend(friendId)) {
                                        showCommandFeedback('friend', `Added ${friendId} as a friend! (User not currently online)`, true);
                                    } else {
                                        showCommandFeedback('friend', `${friendId} is already your friend!`, false);
                                    }
                                }
                            });
                        } else {
                            // No Firebase, just add directly
                            if (addFriend(friendId)) {
                                showCommandFeedback('friend', `Added ${friendId} as a friend!`, true);
                            } else {
                                showCommandFeedback('friend', `${friendId} is already your friend!`, false);
                            }
                        }
                    }
                } else if (command === 'friends') {
                    resetConfirm = false;
                    openFriendsList();
                } else if (command === 'chat') {
                    resetConfirm = false;
                    const chatPage = document.getElementById('chatPage');
                    if (chatPage && !chatPage.classList.contains('hidden')) {
                        // Chat is open, close it
                        showPage('mainPage');
                        showCommandFeedback('chat', 'Chat closed!', true);
                    } else {
                        // Chat is closed, open it
                        showPage('chatPage');
                        loadChatMessages();
                        loadOnlineUsers();
                        showCommandFeedback('chat', 'Chat opened!', true);
                    }
                } else if (command === 'whoami') {
                    resetConfirm = false;
                    showWhoami();
                } else if (command.startsWith('setid ') || command.startsWith('setuserid ')) {
                    resetConfirm = false;
                    const newId = command.startsWith('setid ') ? command.substring(6).trim() : command.substring(10).trim();
                    if (!newId) {
                        showCommandFeedback('setid', 'Please provide a user ID. Usage: setid [your new id]', false);
                    } else {
                        const result = setUserId(newId);
                        if (result === false) {
                            showCommandFeedback('setid', 'Invalid ID or ID already taken. Use 3-20 characters (letters, numbers, _, -)', false);
                        } else if (result === true) {
                            showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                        } else {
                            // Promise result
                            result.then((success) => {
                                if (success) {
                                    showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                                } else {
                                    showCommandFeedback('setid', 'ID already taken by another user. Choose a different ID.', false);
                                }
                            });
                        }
                    }
                } else if (command.startsWith('setid ') || command.startsWith('setuserid ')) {
                    resetConfirm = false;
                    const newId = command.startsWith('setid ') ? command.substring(6).trim() : command.substring(10).trim();
                    if (!newId) {
                        showCommandFeedback('setid', 'Please provide a user ID. Usage: setid [your new id]', false);
                    } else {
                        const result = setUserId(newId);
                        if (result === false) {
                            showCommandFeedback('setid', 'Invalid ID or ID already taken. Use 3-20 characters (letters, numbers, _, -)', false);
                        } else if (result === true) {
                            showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                        } else {
                            // Promise result
                            result.then((success) => {
                                if (success) {
                                    showCommandFeedback('setid', `User ID changed to: ${newId}`, true);
                                } else {
                                    showCommandFeedback('setid', 'ID already taken by another user. Choose a different ID.', false);
                                }
                            });
                        }
                    }
                } else if (command.startsWith('iam ')) {
                    resetConfirm = false;
                    const bioText = command.substring(4).trim();
                    setBio(bioText);
                } else if (command === 'stars') {
                    resetConfirm = false;
                    spawnMoreStars(50);
                    commandInput.value = '';
                    commandInput.placeholder = 'More stars spawned!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'flashcard' || command === 'fc') {
                    resetConfirm = false;
                    createFlashcard();
                    commandInput.value = '';
                    commandInput.placeholder = 'Flashcard created!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command.startsWith('theme ')) {
                    resetConfirm = false;
                    const themeName = command.substring(6).trim().toLowerCase();
                    applyTheme(themeName);
                    commandInput.value = '';
                    commandInput.placeholder = `Theme changed to ${themeName}!`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command === 'rainbow') {
                    resetConfirm = false;
                    applyRainbowColors();
                    showCommandFeedback('rainbow', 'Rainbow colors applied!', true);
                    commandInput.value = '';
                    commandInput.placeholder = 'Rainbow colors applied!';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else if (command.startsWith('timeout ') && isAdmin()) {
                    resetConfirm = false;
                    const parts = command.substring(8).trim().split(' ');
                    if (parts.length < 2) {
                        showCommandFeedback('timeout', 'Usage: timeout [username] [minutes]', false);
                    } else {
                        const targetUsername = parts[0];
                        const minutes = parseInt(parts[1]);
                        if (isNaN(minutes) || minutes < 1) {
                            showCommandFeedback('timeout', 'Invalid timeout duration. Must be a positive number of minutes.', false);
                        } else {
                            const timeoutUntil = Date.now() + (minutes * 60 * 1000);
                            if (database) {
                                database.ref(`userTimeouts/${targetUsername}`).set({
                                    timeoutUntil: timeoutUntil,
                                    timedOutBy: getLoggedInUsername(),
                                    timedOutAt: Date.now(),
                                    durationMinutes: minutes
                                }).then(() => {
                                    showCommandFeedback('timeout', `Timed out ${targetUsername} for ${minutes} minute(s)`, true);
                                });
                            } else {
                                const timeouts = JSON.parse(localStorage.getItem('userTimeouts') || '{}');
                                timeouts[targetUsername] = {
                                    timeoutUntil: timeoutUntil,
                                    timedOutBy: getLoggedInUsername(),
                                    timedOutAt: Date.now(),
                                    durationMinutes: minutes
                                };
                                localStorage.setItem('userTimeouts', JSON.stringify(timeouts));
                                showCommandFeedback('timeout', `Timed out ${targetUsername} for ${minutes} minute(s)`, true);
                            }
                        }
                    }
                } else if (command === 'clear' && isAdmin()) {
                    resetConfirm = false;
                    if (database) {
                        database.ref('messages').remove().then(() => {
                            showCommandFeedback('clear', 'Chat cleared!', true);
                            loadChatMessages();
                        });
                    } else {
                        localStorage.setItem('chatMessages', JSON.stringify([]));
                        showCommandFeedback('clear', 'Chat cleared!', true);
                        loadChatMessages();
                    }
                } else if (hasColorPalette) {
                    resetConfirm = false;
                    changeAllColors(command);
                    showCommandFeedback(command, `Changed to ${command}!`, true);
                    commandInput.value = '';
                    commandInput.placeholder = `Changed to ${command}!`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                } else {
                    resetConfirm = false; // Clear reset confirmation if invalid command
                    showCommandFeedback(command, 'Command not found. Try: cmds, home, back, or a color name...', false);
                    commandInput.value = '';
                    commandInput.placeholder = 'Command not found. Try: cmds, home, back, or a color name...';
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 2000);
                }
            }
        });
        
        // Minesweeper game code
        const GRID_SIZE = 10;
        const NUM_MINES = 10;
        const gridEl = document.getElementById('minesweeper-grid');
        const messageEl = document.getElementById('message');
        const restartBtn = document.getElementById('restart-btn');
        const timerEl = document.getElementById('minesweeper-timer-text');

        let board = [];
        let isGameOver = false;
        let flagsRemaining = NUM_MINES;
        let revealedCount = 0;
        let gameStarted = false;
        let gameWon = false;
        let timer = 0;
        let timerInterval = null;

        function createBoard() {
            board = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill({ 
                    isMine: false, 
                    isRevealed: false, 
                    isFlagged: false, 
                    mineCount: 0,
                    el: null
                })
            );
            let minesPlaced = 0;
            while (minesPlaced < NUM_MINES) {
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);
                if (!board[r][c].isMine) {
                    board[r][c] = { ...board[r][c], isMine: true }; 
                    minesPlaced++;
                }
            }
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (!board[r][c].isMine) {
                        board[r][c] = { ...board[r][c], mineCount: countMines(r, c) };
                    }
                }
            }
        }

        function countMines(r, c) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                        if (board[nr][nc].isMine) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        function revealCell(r, c) {
            if (isGameOver || r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE || board[r][c].isRevealed || board[r][c].isFlagged) {
                return;
            }
            
            // Start timer on first click
            if (!gameStarted) {
                gameStarted = true;
                timer = 0;
                if (timerEl) timerEl.textContent = timer;
                timerInterval = setInterval(() => {
                    if (isGameOver || gameWon) {
                        if (timerInterval) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                        }
                        return;
                    }
                    timer++;
                    if (timerEl) timerEl.textContent = timer;
                }, 1000);
            }
            
            const cell = board[r][c];
            cell.isRevealed = true;
            revealedCount++;
            cell.el.classList.add('revealed');
            cell.el.innerHTML = '';
            cell.el.style.borderColor = 'transparent';

            if (cell.isMine) {
                cell.el.classList.add('mine');
                cell.el.innerHTML = 'ðŸ’£';
                gameOver(false);
                return;
            } 
            
            if (cell.mineCount > 0) {
                cell.el.innerHTML = cell.mineCount;
                cell.el.classList.add(`number-${cell.mineCount}`);
                    } else {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        revealCell(r + dr, c + dc);
                    }
                }
            }
            checkWin();
        }

        function toggleFlag(r, c) {
            if (isGameOver || board[r][c].isRevealed) return;
            const cell = board[r][c];
            if (cell.isFlagged) {
                cell.isFlagged = false;
                flagsRemaining++;
                cell.el.innerHTML = '';
                cell.el.classList.remove('flag');
            } else if (flagsRemaining > 0) {
                cell.isFlagged = true;
                flagsRemaining--;
                cell.el.innerHTML = 'ðŸš©';
                cell.el.classList.add('flag');
            }
            updateMessage();
        }

        function drawGrid() {
            if (!gridEl) return;
            gridEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = board[r][c];
                    const cellEl = document.createElement('div');
                    cellEl.classList.add('cell');
                    cellEl.dataset.r = r;
                    cellEl.dataset.c = c;
                    cell.el = cellEl;
                    cellEl.addEventListener('click', () => revealCell(r, c));
                    cellEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(r, c);
                    });
                    gridEl.appendChild(cellEl);
                }
            }
            updateMessage();
        }

        function updateMessage() {
            if (!messageEl) return;
            if (!isGameOver) {
                messageEl.innerHTML = `Flags Remaining: ${flagsRemaining}`;
            }
        }

        function checkWin() {
            if (revealedCount === (GRID_SIZE * GRID_SIZE) - NUM_MINES) {
                gameOver(true);
            }
        }

        function gameOver(win) {
            isGameOver = true;
            gameWon = win;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (!messageEl) return;
            if (win) {
                messageEl.innerHTML = `ðŸŽ‰ YOU WIN! ðŸŽ‰ Time: ${timer}s`;
                messageEl.style.color = 'green';
                // Save score to leaderboard
                const userId = getUserId() || 'Anonymous';
                saveMinesweeperPageScore(timer, userId);
            } else {
                messageEl.innerHTML = 'ðŸ’£ GAME OVER! ðŸ’£';
                messageEl.style.color = 'red';
                board.flat().forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.el.classList.add('mine');
                        cell.el.innerHTML = 'ðŸ’£';
                    }
                });
            }
        }
        
        // Save score to Firebase leaderboard (for page version)
        function saveMinesweeperPageScore(time, userId) {
            if (database) {
                const scoreData = {
                    userId: userId,
                    time: time,
                    timestamp: Date.now()
                };
                database.ref('minesweeperLeaderboard').push(scoreData);
            } else {
                // localStorage fallback
                const saved = localStorage.getItem('minesweeperLeaderboard');
                const scores = saved ? JSON.parse(saved) : [];
                scores.push({
                    id: 'score_' + Date.now(),
                    userId: userId,
                    time: time,
                    timestamp: Date.now()
                });
                // Keep only top 50
                scores.sort((a, b) => a.time - b.time);
                scores.splice(50);
                localStorage.setItem('minesweeperLeaderboard', JSON.stringify(scores));
            }
        }

        function initGame() {
            isGameOver = false;
            gameStarted = false;
            gameWon = false;
            flagsRemaining = NUM_MINES;
            revealedCount = 0;
            timer = 0;
            if (timerEl) timerEl.textContent = timer;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (messageEl) {
                messageEl.style.color = 'black';
            }
            createBoard();
            drawGrid();
        }

        function initMinesweeper() {
            if (restartBtn) {
                restartBtn.addEventListener('click', initGame);
            }
            
            // Add leaderboard button handler
            const leaderboardBtn = document.getElementById('minesweeper-page-leaderboard-btn');
            if (leaderboardBtn) {
                leaderboardBtn.addEventListener('click', showMinesweeperPageLeaderboard);
            }
            
            initGame();
        }
        
        // Show leaderboard for minesweeper page (sweeper command)
        function showMinesweeperPageLeaderboard() {
            globalWindowZIndex++;
            const leaderboardWindow = document.createElement('div');
            leaderboardWindow.className = 'win95-window';
            leaderboardWindow.style.left = '150px';
            leaderboardWindow.style.top = '100px';
            leaderboardWindow.style.width = '400px';
            leaderboardWindow.style.height = '500px';
            leaderboardWindow.style.zIndex = globalWindowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = 'Minesweeper Leaderboard';
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => leaderboardWindow.remove();
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            content.innerHTML = '<div style="text-align: center; margin-bottom: 10px;"><div style="font-size: 14px; font-weight: bold; margin-bottom: 10px;">Top Speed Times</div><div id="minesweeper-page-leaderboard-list">Loading...</div></div>';
            
            leaderboardWindow.appendChild(header);
            leaderboardWindow.appendChild(content);
            
            // Append to remoteDesktop if it exists, otherwise append to body
            const remoteDesktop = document.getElementById('remoteDesktop');
            if (remoteDesktop) {
                remoteDesktop.appendChild(leaderboardWindow);
            } else {
                document.body.appendChild(leaderboardWindow);
            }
            
            function loadLeaderboard() {
                const listEl = content.querySelector('#minesweeper-page-leaderboard-list');
                
                if (database) {
                    database.ref('minesweeperLeaderboard').orderByChild('time').limitToFirst(10).once('value', (snapshot) => {
                        const scores = [];
                        snapshot.forEach((child) => {
                            const data = child.val();
                            if (data) {
                                scores.push({
                                    id: child.key,
                                    ...data
                                });
                            }
                        });
                        // Sort by time (ascending - fastest first)
                        scores.sort((a, b) => (a.time || 999999) - (b.time || 999999));
                        renderLeaderboard(scores);
                    }, (error) => {
                        console.error('Error loading leaderboard:', error);
                        // Fallback to localStorage
                        loadFromLocalStorage();
                    });
                } else {
                    loadFromLocalStorage();
                }
                
                function loadFromLocalStorage() {
                    const saved = localStorage.getItem('minesweeperLeaderboard');
                    const scores = saved ? JSON.parse(saved) : [];
                    // Sort by time (ascending - fastest first)
                    scores.sort((a, b) => (a.time || 999999) - (b.time || 999999));
                    // Get top 10
                    renderLeaderboard(scores.slice(0, 10));
                }
                
                function renderLeaderboard(scores) {
                    const listEl = content.querySelector('#minesweeper-page-leaderboard-list');
                    if (scores.length === 0) {
                        listEl.innerHTML = '<div style="font-size: 11px; color: #666; text-align: center; margin: 10px 0;">No scores yet. Be the first!</div>';
                        return;
                    }
                    
                    let html = '<div style="font-size: 11px;">';
                    scores.forEach((score, index) => {
                        const rank = index + 1;
                        const time = score.time || 0;
                        const userId = escapeHtml(score.userId || 'Anonymous');
                        const date = score.timestamp ? new Date(score.timestamp).toLocaleDateString() : 'Unknown';
                        const medal = rank === 1 ? 'ðŸ¥‡' : rank === 2 ? 'ðŸ¥ˆ' : rank === 3 ? 'ðŸ¥‰' : `${rank}.`;
                        
                        html += `<div style="border: 1px inset #c0c0c0; padding: 8px; margin: 5px 0; background: #fff;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-weight: bold; font-size: 12px;">${medal}</span>
                                    <span style="font-size: 11px; margin-left: 5px;">${userId}</span>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold; font-size: 12px; color: #238636;">${time}s</div>
                                    <div style="font-size: 9px; color: #666;">${date}</div>
                                </div>
                            </div>
                        </div>`;
                    });
                    html += '</div>';
                    listEl.innerHTML = html;
                }
            }
            
            loadLeaderboard();
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                leaderboardWindow.style.zIndex = ++globalWindowZIndex;
                const initialX = e.clientX - leaderboardWindow.offsetLeft;
                const initialY = e.clientY - leaderboardWindow.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        leaderboardWindow.style.left = (e.clientX - initialX) + 'px';
                        leaderboardWindow.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        
        // Pong game code - placeholder for JavaScript
        function initPong() {
            // Pong game initialization will go here
            // Waiting for JavaScript code...
        }
        
        // Pong settings modal functions
        window.toggleSettingsModal = function() {
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.toggle('hidden');
            }
        };
        
        window.saveSettingsAndRestart = function() {
            // Settings save and restart will go here
            // Waiting for JavaScript code...
            const modal = document.getElementById('settingsModal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };
        
        // Sandboxels close function
        function closeSandboxels() {
            showPage('mainPage');
        }
        
        // Pong close function
        function closePong() {
            showPage('mainPage');
        }
        
        // Jumpscare function
        function triggerJumpscare() {
            // Remove any existing jumpscare overlay
            const existing = document.getElementById('jumpscareOverlay');
            if (existing) {
                existing.remove();
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'jumpscareOverlay';
            overlay.className = 'jumpscare-overlay';
            
            // Create image element
            const img = document.createElement('img');
            img.className = 'jumpscare-image';
            // Note: You'll need to add your image file to the project and set the src
            // For now, using a placeholder - replace with your image path/URL
            img.src = 'jumpscare.jpg'; // Change this to your image file path or URL
            img.alt = 'Jumpscare';
            
            overlay.appendChild(img);
            document.body.appendChild(overlay);
            
            // Trigger animation by adding active class
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
            
            // Remove overlay after animation completes
            setTimeout(() => {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, 1300); // 300ms pop + 800ms delay + 500ms fade
        }
        
        // Background selection system
        let bgMode = 'solid'; // 'solid' or 'gradient'
        let selectedGradientColor1 = null;
        let selectedGradientColor2 = null;
        let selectedSolidColor = null;
        
        // Map color names to hex values (use first color from each palette)
        const bgColorMap = {
            'black': '#000000',
            'red': '#ff0000',
            'blue': '#0000ff',
            'green': '#00ff00',
            'yellow': '#ffff00',
            'purple': '#800080',
            'orange': '#ffa500',
            'white': '#ffffff',
            'pink': '#ff69b4',
            'cyan': '#00ffff',
            'lime': '#00ff00',
            'magenta': '#ff00ff',
            'brown': '#a52a2a',
            'gray': '#808080',
            'grey': '#808080',
            'gold': '#ffd700',
            'silver': '#c0c0c0'
        };
        
        // Load background preferences
        function loadBackgroundPreferences() {
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
                // Only apply if on dark or light theme
                if (currentTheme === 'dark' || currentTheme === 'light') {
                    if (prefs.mode === 'solid' && prefs.color) {
                        applyBackgroundColor(prefs.color);
                        selectedSolidColor = prefs.color;
                    } else if (prefs.mode === 'gradient' && prefs.color1 && prefs.color2) {
                        const gradient = `linear-gradient(to bottom, ${prefs.color1}, ${prefs.color2})`;
                        applyBackgroundColor(gradient);
                        selectedGradientColor1 = prefs.color1;
                        selectedGradientColor2 = prefs.color2;
                    }
                }
            }
        }
        
        // Save background preferences
        function saveBackgroundPreferences() {
            const prefs = {
                mode: bgMode,
                color: bgMode === 'solid' ? selectedSolidColor : null,
                color1: bgMode === 'gradient' ? selectedGradientColor1 : null,
                color2: bgMode === 'gradient' ? selectedGradientColor2 : null
            };
            localStorage.setItem('backgroundPrefs', JSON.stringify(prefs));
        }
        
        // Initialize background page
        function initBackground() {
            // Show/hide warning based on current theme
            const warningEl = document.getElementById('bg-theme-warning');
            if (warningEl) {
                if (currentTheme === 'dark' || currentTheme === 'light') {
                    warningEl.style.display = 'none';
                } else {
                    warningEl.style.display = 'block';
                }
            }
            
            // Load saved preferences
            const saved = localStorage.getItem('backgroundPrefs');
            if (saved) {
                const prefs = JSON.parse(saved);
                bgMode = prefs.mode || 'solid';
            }
            
            setBgMode(bgMode);
            renderColorButtons();
        }
        
        // Set background mode (solid or gradient)
        function setBgMode(mode) {
            bgMode = mode;
            
            const solidSection = document.getElementById('bg-solid-section');
            const gradientSection = document.getElementById('bg-gradient-section');
            const solidBtn = document.getElementById('bg-solid-btn');
            const gradientBtn = document.getElementById('bg-gradient-btn');
            
            if (mode === 'solid') {
                if (solidSection) solidSection.style.display = 'block';
                if (gradientSection) gradientSection.style.display = 'none';
                if (solidBtn) solidBtn.style.background = '#238636';
                if (gradientBtn) gradientBtn.style.background = '#30363d';
                } else {
                if (solidSection) solidSection.style.display = 'none';
                if (gradientSection) gradientSection.style.display = 'block';
                if (solidBtn) solidBtn.style.background = '#30363d';
                if (gradientBtn) gradientBtn.style.background = '#238636';
                selectedGradientColor1 = null;
                selectedGradientColor2 = null;
                updateGradientSelection();
            }
        }
        
        // Render color buttons
        function renderColorButtons() {
            const solidColors = document.getElementById('bg-solid-colors');
            const gradientColors = document.getElementById('bg-gradient-colors');
            
            if (solidColors) {
                solidColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => applySolidBackground(colorName);
                    btn.title = colorName;
                    solidColors.appendChild(btn);
                });
            }
            
            if (gradientColors) {
                gradientColors.innerHTML = '';
                Object.keys(bgColorMap).forEach(colorName => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `width: 100px; height: 60px; background: ${bgColorMap[colorName]}; border: 2px solid #30363d; border-radius: 8px; cursor: pointer; margin: 5px;`;
                    btn.onclick = () => selectGradientColor(colorName);
                    btn.title = colorName;
                    gradientColors.appendChild(btn);
                });
            }
        }
        
        // Apply solid background
        function applySolidBackground(colorName) {
            // Only allow colors on dark and light themes
            if (currentTheme !== 'dark' && currentTheme !== 'light') {
                showCommandFeedback('background', 'Background colors only work on dark or light theme', false);
                return;
            }
            
            const color = bgColorMap[colorName];
            if (color) {
                // Apply with !important using a style element
                applyBackgroundColor(color);
                selectedSolidColor = color;
                saveBackgroundPreferences();
                showCommandFeedback('background', `Background changed to ${colorName}`, true);
            }
        }
        
        // Select gradient color
        function selectGradientColor(colorName) {
            const color = bgColorMap[colorName];
            if (!color) return;
            
            if (!selectedGradientColor1) {
                selectedGradientColor1 = color;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
            } else if (!selectedGradientColor2) {
                selectedGradientColor2 = color;
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color2NameEl) color2NameEl.textContent = colorName;
                
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = false;
                    applyBtn.style.cursor = 'pointer';
                    applyBtn.style.background = '#238636';
                }
                        } else {
                // Reset and select first color again
                selectedGradientColor1 = color;
                selectedGradientColor2 = null;
                const color1NameEl = document.getElementById('bg-gradient-color1-name');
                const color2NameEl = document.getElementById('bg-gradient-color2-name');
                if (color1NameEl) color1NameEl.textContent = colorName;
                if (color2NameEl) color2NameEl.textContent = 'Not selected';
                const applyBtn = document.getElementById('bg-apply-gradient-btn');
                if (applyBtn) {
                    applyBtn.disabled = true;
                    applyBtn.style.cursor = 'not-allowed';
                    applyBtn.style.background = '#30363d';
                }
            }
        }
        
        // Update gradient selection display
        function updateGradientSelection() {
            const color1NameEl = document.getElementById('bg-gradient-color1-name');
            const color2NameEl = document.getElementById('bg-gradient-color2-name');
            const applyBtn = document.getElementById('bg-apply-gradient-btn');
            
            if (color1NameEl) color1NameEl.textContent = 'Not selected';
            if (color2NameEl) color2NameEl.textContent = 'Not selected';
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.style.cursor = 'not-allowed';
                applyBtn.style.background = '#30363d';
            }
        }
        
        // Apply gradient background
        function applyGradientBackground() {
            // Only allow colors on dark and light themes
            if (currentTheme !== 'dark' && currentTheme !== 'light') {
                showCommandFeedback('background', 'Background colors only work on dark or light theme', false);
                return;
            }
            
            if (selectedGradientColor1 && selectedGradientColor2) {
                const gradient = `linear-gradient(to bottom, ${selectedGradientColor1}, ${selectedGradientColor2})`;
                applyBackgroundColor(gradient);
                saveBackgroundPreferences();
                showCommandFeedback('background', 'Gradient background applied', true);
            }
        }
        
        // Helper function to apply background color with !important
        let customBgStyleEl = null;
        function applyBackgroundColor(colorOrGradient) {
            // Remove existing custom background style
            if (customBgStyleEl) {
                customBgStyleEl.remove();
            }
            
            // Create new style element with !important
            customBgStyleEl = document.createElement('style');
            customBgStyleEl.id = 'custom-background-style';
            customBgStyleEl.textContent = `body.theme-dark, body.theme-light { background: ${colorOrGradient} !important; } body.theme-dark .page, body.theme-light .page { background: ${colorOrGradient} !important; }`;
            document.head.appendChild(customBgStyleEl);
        }
        
        // Remove custom background when switching themes
        function removeCustomBackground() {
            if (customBgStyleEl) {
                customBgStyleEl.remove();
                customBgStyleEl = null;
            }
        }
        
        // Theme System
        const availableThemes = ['1995', 'cyberpunk', 'terminal', 'coffee', 'dark', 'light', 'matrix', 'paper', 'space', 'ocean', 'clouds', 'flashcard', 'minecraft', 'pirate', 'firework', 'mlg'];
        let currentTheme = 'dark'; // Default theme
        
        // Load saved theme
        function loadTheme() {
            const saved = localStorage.getItem('selectedTheme');
            if (saved && availableThemes.includes(saved)) {
                currentTheme = saved;
                applyTheme(saved, false); // false = don't save (already loaded)
            } else {
                applyTheme('dark', false); // Apply default without saving
            }
        }
        
        // Save theme preference
        function saveTheme(themeName) {
            localStorage.setItem('selectedTheme', themeName);
        }
        
        // Apply theme
        function applyTheme(themeName, save = true) {
            // Remove all theme classes
            document.body.classList.remove(...availableThemes.map(t => `theme-${t}`));
            
            // Validate theme name
            if (!availableThemes.includes(themeName)) {
                showCommandFeedback(`theme ${themeName}`, `Invalid theme. Available: ${availableThemes.join(', ')}`, false);
                const commandInput = document.getElementById('commandInput');
                if (commandInput) {
                    commandInput.placeholder = `Invalid theme: ${themeName}. Available: ${availableThemes.join(', ')}`;
                    setTimeout(() => {
                        commandInput.placeholder = 'Type a color or "home"...';
                    }, 3000);
                }
                return;
            }
            
            // Handle custom backgrounds
            const wasDarkOrLight = (currentTheme === 'dark' || currentTheme === 'light');
            const willBeDarkOrLight = (themeName === 'dark' || themeName === 'light');
            
            // Remove custom background if switching away from dark/light
            if (wasDarkOrLight && !willBeDarkOrLight) {
                removeCustomBackground();
            }
            
            // Add new theme class
            document.body.classList.add(`theme-${themeName}`);
            currentTheme = themeName;
            
            // Setup theme-specific features
            if (themeName === 'space') {
                initStars();
            } else if (themeName === 'ocean') {
                setupOceanTheme();
            } else if (themeName === 'minecraft') {
                setupMinecraftTheme();
            } else if (themeName === 'pirate') {
                setupPirateTheme();
            } else if (themeName === 'paper') {
                initPaperDrawing();
            } else if (themeName === 'flashcard') {
                // Flashcard theme setup if needed
            } else if (themeName === 'firework') {
                setupFireworkTheme();
            } else if (themeName === 'mlg') {
                setupMLGTheme();
            }
            
            // Reapply custom background if switching to dark/light and one exists
            if (willBeDarkOrLight) {
                const saved = localStorage.getItem('backgroundPrefs');
                if (saved) {
                    const prefs = JSON.parse(saved);
                    if (prefs.mode === 'solid' && prefs.color) {
                        applyBackgroundColor(prefs.color);
                    } else if (prefs.mode === 'gradient' && prefs.color1 && prefs.color2) {
                        const gradient = `linear-gradient(to bottom, ${prefs.color1}, ${prefs.color2})`;
                        applyBackgroundColor(gradient);
                    }
                }
            }
            
            if (save) {
                saveTheme(themeName);
            }
            
            showCommandFeedback(`theme ${themeName}`, `Theme changed to ${themeName}!`, true);
        }
        
        // Note: applyTheme will be wrapped below, so we'll set window.applyTheme after wrapping
        
        // Matrix theme keypress handler
        let matrixColumns = [];
        const matrixSpecialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';
        
        function createMatrixColumn(key, x) {
            if (!document.body.classList.contains('theme-matrix')) return;
            
            // Don't create columns for command input
            const commandInput = document.getElementById('commandInput');
            if (commandInput && document.activeElement === commandInput) return;
            
            const column = document.createElement('div');
            column.className = 'matrix-column';
            column.style.left = x + 'px';
            column.style.top = '0px';
            column.style.position = 'fixed';
            
            // Random speed for this column
            const baseSpeed = 1.5 + Math.random() * 1.5; // 1.5-3 seconds per character
            const charCount = 25 + Math.floor(Math.random() * 15); // 25-40 characters
            const charSpacing = 18; // Vertical spacing between characters
            const delayBetweenChars = baseSpeed * 0.06; // Delay between each character appearing
            
            // Start with the pressed key (bright) - this is the "head"
            const startChar = document.createElement('span');
            startChar.className = 'char bright';
            startChar.textContent = key;
            startChar.style.animationDuration = baseSpeed + 's';
            startChar.style.animationDelay = '0s';
            startChar.style.top = '-20px';
            column.appendChild(startChar);
            
            // Add random special characters that cascade down
            for (let i = 0; i < charCount; i++) {
                const char = document.createElement('span');
                char.className = 'char';
                
                // Randomly make some characters bright (the "head" of the trail)
                if (Math.random() < 0.12) {
                    char.classList.add('bright');
                } else if (i > charCount - 8) {
                    char.classList.add('fade');
                }
                
                char.textContent = matrixSpecialChars[Math.floor(Math.random() * matrixSpecialChars.length)];
                
                // Stagger animation delays to create cascading effect
                // Each character starts slightly after the one above it
                const delay = (i + 1) * delayBetweenChars;
                char.style.animationDuration = baseSpeed + 's';
                char.style.animationDelay = delay + 's';
                // Position characters above the start character, cascading upward
                char.style.top = (-20 - (i + 1) * charSpacing) + 'px';
                
                column.appendChild(char);
            }
            
            document.body.appendChild(column);
            matrixColumns.push(column);
            
            // Remove column after all characters have fallen
            const totalDuration = (charCount * baseSpeed * 0.08) + baseSpeed + 1;
            setTimeout(() => {
                if (column.parentNode) {
                    column.remove();
                }
                const index = matrixColumns.indexOf(column);
                if (index > -1) {
                    matrixColumns.splice(index, 1);
                }
            }, totalDuration * 1000);
        }
        
        // Matrix theme keypress listener
        let matrixKeyHandler = null;
        
        function setupMatrixKeyHandler() {
            // Always remove existing handler first to prevent duplicates
            if (typeof matrixKeyHandler !== 'undefined' && matrixKeyHandler) {
                try {
                    document.removeEventListener('keydown', matrixKeyHandler);
                } catch (e) {
                    console.error('Error removing matrix handler:', e);
                }
                matrixKeyHandler = null;
            }
            
            // Only add handler if matrix theme is active
            if (document.body.classList.contains('theme-matrix')) {
                matrixKeyHandler = (e) => {
                    // Don't trigger on command input
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && document.activeElement === commandInput) return;
                    
                    // Don't trigger on special keys (Ctrl, Alt, etc.)
                    if (e.ctrlKey || e.altKey || e.metaKey) return;
                    
                    // Get the key character
                    let key = e.key;
                    
                    // Handle special keys
                    if (key.length > 1) {
                        // Map special keys to symbols
                        const specialKeyMap = {
                            'Enter': 'â†µ',
                            ' ': ' ',
                            'Space': ' ',
                            'Tab': 'â†’',
                            'Escape': 'âŽ‹',
                            'Backspace': 'âŒ«',
                            'Delete': 'âŒ¦',
                            'ArrowUp': 'â†‘',
                            'ArrowDown': 'â†“',
                            'ArrowLeft': 'â†',
                            'ArrowRight': 'â†’'
                        };
                        
                        if (specialKeyMap[key]) {
                            key = specialKeyMap[key];
                        } else {
                            // Skip other special keys
                            return;
                        }
                    }
                    
                    // Create column at random x position
                    const x = Math.random() * (window.innerWidth - 50);
                    createMatrixColumn(key, x);
                };
                
                document.addEventListener('keydown', matrixKeyHandler);
            }
        }
        
        // Clean up matrix columns when switching themes
        function cleanupMatrixColumns() {
            matrixColumns.forEach(column => column.remove());
            matrixColumns = [];
        }
        
        // Update applyTheme to setup/remove matrix handler and cleanup
        const originalApplyTheme = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup if switching away from matrix
            if (document.body.classList.contains('theme-matrix') && themeName !== 'matrix') {
                cleanupMatrixColumns();
            }
            
            originalApplyTheme(themeName, save);
            
            // Setup matrix handler if switching to matrix
            setupMatrixKeyHandler();
        };
        
        // Make wrapped applyTheme globally accessible
        window.applyTheme = applyTheme;
        
        // Load theme on page load - will be called from initializeOnLoad
        // loadTheme() is now called in initializeOnLoad()
        
        // Space theme - stars that react to cursor
        let spaceStars = [];
        let spaceMouseHandler = null;
        
        function createSpaceStars() {
            // Remove existing stars
            cleanupSpaceStars();
            
            if (!document.body.classList.contains('theme-space')) return;
            
            // Create stars
            const starCount = 100;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'space-star';
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                star.style.width = (Math.random() * 2 + 1) + 'px';
                star.style.height = star.style.width;
                star.dataset.x = x;
                star.dataset.y = y;
                document.body.appendChild(star);
                spaceStars.push(star);
            }
        }
        
        function cleanupSpaceStars() {
            spaceStars.forEach(star => star.remove());
            spaceStars = [];
        }
        
        function setupSpaceTheme() {
            // Remove existing handler
            if (spaceMouseHandler) {
                document.removeEventListener('mousemove', spaceMouseHandler);
                spaceMouseHandler = null;
            }
            
            if (document.body.classList.contains('theme-space')) {
                createSpaceStars();
                
                spaceMouseHandler = (e) => {
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    const pushRadius = 100; // Distance stars get pushed
                    
                    spaceStars.forEach(star => {
                        const starX = parseFloat(star.dataset.x) || 0;
                        const starY = parseFloat(star.dataset.y) || 0;
                        
                        const dx = starX - mouseX;
                        const dy = starY - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < pushRadius && distance > 0) {
                            // Push star away from cursor
                            const angle = Math.atan2(dy, dx);
                            const pushDistance = (pushRadius - distance) / pushRadius;
                            const newX = starX + Math.cos(angle) * pushDistance * 30;
                            const newY = starY + Math.sin(angle) * pushDistance * 30;
                            
                            // Keep stars within bounds
                            const clampedX = Math.max(0, Math.min(window.innerWidth, newX));
                            const clampedY = Math.max(0, Math.min(window.innerHeight, newY));
                            
                            star.style.left = clampedX + 'px';
                            star.style.top = clampedY + 'px';
                            star.dataset.x = clampedX;
                            star.dataset.y = clampedY;
                        }
                    });
                };
                
                document.addEventListener('mousemove', spaceMouseHandler);
            } else {
                cleanupSpaceStars();
            }
        }
        
        // Update applyTheme to handle space theme
        const originalApplyTheme3 = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup previous theme effects
            if (document.body.classList.contains('theme-space') && themeName !== 'space') {
                cleanupSpaceStars();
            }
            if (document.body.classList.contains('theme-ocean') && themeName !== 'ocean') {
                cleanupOceanFish();
            }
            if (document.body.classList.contains('theme-pirate') && themeName !== 'pirate') {
                cleanupPirateCannonballs();
            }
            if (document.body.classList.contains('theme-firework') && themeName !== 'firework') {
                cleanupFireworks();
            }
            if (document.body.classList.contains('theme-mlg') && themeName !== 'mlg') {
                cleanupMLGEffects();
            }
            
            originalApplyTheme3(themeName, save);
            
            // Setup space theme if switching to it
            if (themeName === 'space') {
                setupSpaceTheme();
            }
            // Setup firework theme if switching to it
            if (themeName === 'firework') {
                setupFireworkTheme();
            }
            // Setup MLG theme if switching to it
            if (themeName === 'mlg') {
                setupMLGTheme();
            }
        };
        
        // Setup space theme on page load if active
        setTimeout(() => {
            setupSpaceTheme();
        }, 100);
        
        // Handle window resize for space stars
        window.addEventListener('resize', () => {
            if (document.body.classList.contains('theme-space')) {
                // Update star positions based on new window size
                spaceStars.forEach(star => {
                    const x = parseFloat(star.style.left) || 0;
                    const y = parseFloat(star.style.top) || 0;
                    star.dataset.x = x;
                    star.dataset.y = y;
                });
            }
        });
        
        // Function to spawn more stars (for "stars" command)
        function spawnMoreStars(count = 50) {
            if (!document.body.classList.contains('theme-space')) {
                showCommandFeedback('stars', 'Stars command only works in space theme', false);
                return;
            }
            
            for (let i = 0; i < count; i++) {
                const star = document.createElement('div');
                star.className = 'space-star';
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                star.style.width = (Math.random() * 2 + 1) + 'px';
                star.style.height = star.style.width;
                star.dataset.x = x;
                star.dataset.y = y;
                document.body.appendChild(star);
                spaceStars.push(star);
            }
            
            showCommandFeedback('stars', `Spawned ${count} more stars!`, true);
        }
        
        // Ocean theme - animated fish
        let oceanFish = [];
        
        function createOceanFish() {
            // Remove existing fish
            cleanupOceanFish();
            
            if (!document.body.classList.contains('theme-ocean')) return;
            
            // Create fish
            const fishEmojis = ['ðŸŸ', 'ðŸ ', 'ðŸ¡', 'ðŸ¦ˆ'];
            const fishCount = 5;
            
            for (let i = 0; i < fishCount; i++) {
                const fish = document.createElement('div');
                fish.className = 'ocean-fish';
                const size = ['small', 'medium', 'large'][Math.floor(Math.random() * 3)];
                fish.classList.add(size);
                fish.textContent = fishEmojis[Math.floor(Math.random() * fishEmojis.length)];
                fish.style.top = (Math.random() * 80 + 10) + '%'; // Random vertical position
                fish.style.animationDelay = (Math.random() * 5) + 's'; // Stagger animations
                document.body.appendChild(fish);
                oceanFish.push(fish);
            }
        }
        
        function cleanupOceanFish() {
            oceanFish.forEach(fish => fish.remove());
            oceanFish = [];
        }
        
        function setupOceanTheme() {
            if (document.body.classList.contains('theme-ocean')) {
                createOceanFish();
            } else {
                cleanupOceanFish();
            }
        }
        
        // Minecraft theme - explosion on space
        let minecraftKeyHandler = null;
        
        function createMinecraftExplosion(x, y) {
            if (!document.body.classList.contains('theme-minecraft')) return;
            
            const explosion = document.createElement('div');
            explosion.className = 'minecraft-explosion';
            explosion.style.left = x + 'px';
            explosion.style.top = y + 'px';
            document.body.appendChild(explosion);
            
            // Create particles
            const particleCount = 20;
            const colors = ['#ff4400', '#ff8800', '#ffff00', '#ffffff'];
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'minecraft-explosion-particle';
                const angle = (Math.PI * 2 * i) / particleCount;
                const distance = 30 + Math.random() * 40;
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;
                particle.style.setProperty('--dx', dx + 'px');
                particle.style.setProperty('--dy', dy + 'px');
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                explosion.appendChild(particle);
            }
            
            // Remove after animation
            setTimeout(() => {
                explosion.remove();
            }, 600);
        }
        
        function setupMinecraftTheme() {
            // Remove old handler if exists
            if (minecraftKeyHandler) {
                document.removeEventListener('keydown', minecraftKeyHandler);
            }
            
            if (document.body.classList.contains('theme-minecraft')) {
                minecraftKeyHandler = (e) => {
                    if (!document.body.classList.contains('theme-minecraft')) return;
                    if (e.code !== 'Space') return;
                    
                    // Don't trigger if typing in command input
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && document.activeElement === commandInput) return;
                    
                    e.preventDefault();
                    
                    // Create explosion at random position or mouse position
                    const x = e.clientX || Math.random() * window.innerWidth;
                    const y = e.clientY || Math.random() * window.innerHeight;
                    createMinecraftExplosion(x, y);
                };
                
                document.addEventListener('keydown', minecraftKeyHandler);
            }
        }
        
        // Pirate theme - cannonballs
        let pirateCannonballs = [];
        let pirateShootInterval = null;
        let pirateClickHandler = null;
        
        function createPirateCannonball() {
            if (!document.body.classList.contains('theme-pirate')) return;
            
            const cannonball = document.createElement('div');
            cannonball.className = 'pirate-cannonball';
            
            // Random direction: left, right, up, down, or diagonal
            const directions = ['left', 'right', 'up', 'down', 'diagonal-tl-br', 'diagonal-tr-bl', 'diagonal-bl-tr', 'diagonal-br-tl'];
            const direction = directions[Math.floor(Math.random() * directions.length)];
            
            // Set animation based on direction
            let animationName = 'cannonball-fly-' + direction;
            
            // Set initial position and CSS variables based on direction
            if (direction === 'left') {
                const startY = Math.random() * window.innerHeight;
                cannonball.style.setProperty('--start-y', startY + 'px');
                cannonball.style.top = startY + 'px';
                cannonball.style.left = '-30px';
            } else if (direction === 'right') {
                const startY = Math.random() * window.innerHeight;
                cannonball.style.setProperty('--start-y', startY + 'px');
                cannonball.style.top = startY + 'px';
                cannonball.style.left = 'calc(100vw + 30px)';
            } else if (direction === 'up') {
                const startX = Math.random() * window.innerWidth;
                cannonball.style.setProperty('--start-x', startX + 'px');
                cannonball.style.left = startX + 'px';
                cannonball.style.top = 'calc(100vh + 30px)';
            } else if (direction === 'down') {
                const startX = Math.random() * window.innerWidth;
                cannonball.style.setProperty('--start-x', startX + 'px');
                cannonball.style.left = startX + 'px';
                cannonball.style.top = '-30px';
            } else {
                // Diagonal directions - no need to set initial position, animation handles it
                cannonball.style.left = '0px';
                cannonball.style.top = '0px';
            }
            
            cannonball.style.animation = animationName + ' 2s linear forwards';
            
            document.body.appendChild(cannonball);
            pirateCannonballs.push(cannonball);
            
            // Remove after animation
            setTimeout(() => {
                if (cannonball.parentNode) {
                    cannonball.remove();
                }
                pirateCannonballs = pirateCannonballs.filter(cb => cb !== cannonball);
            }, 2000);
        }
        
        function cleanupPirateCannonballs() {
            pirateCannonballs.forEach(cb => {
                if (cb.parentNode) cb.remove();
            });
            pirateCannonballs = [];
            if (pirateShootInterval) {
                clearInterval(pirateShootInterval);
                pirateShootInterval = null;
            }
            if (pirateClickHandler) {
                document.removeEventListener('click', pirateClickHandler);
                pirateClickHandler = null;
            }
        }
        
        function setupPirateTheme() {
            // Always clean up first to prevent duplicates
            if (typeof cleanupPirateCannonballs === 'function') {
                try {
                    cleanupPirateCannonballs();
                } catch (e) {
                    console.error('Error cleaning up pirate cannonballs:', e);
                }
            }
            
            if (document.body.classList.contains('theme-pirate')) {
                // Shoot cannonballs periodically
                pirateShootInterval = setInterval(() => {
                    if (document.body.classList.contains('theme-pirate')) {
                        createPirateCannonball();
                    } else {
                        cleanupPirateCannonballs();
                    }
                }, 3000);
                
                // Also shoot on mouse click - use capture phase
                pirateClickHandler = (e) => {
                    if (!document.body.classList.contains('theme-pirate')) return;
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && (e.target === commandInput || commandInput.contains(e.target))) return;
                    // Don't trigger on buttons or interactive elements
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('button')) return;
                    createPirateCannonball();
                };
                document.addEventListener('click', pirateClickHandler, true);
            }
        }
        
        // Paper theme - drawing functionality
        let paperCanvas = null;
        let paperCtx = null;
        let isPaperDrawing = false;
        let lastPaperX = 0;
        let lastPaperY = 0;
        let paperColor = '#000000';
        let paperBrushSize = 3;
        
        function initPaperDrawing() {
            // Clean up existing canvas first
            cleanupPaperDrawing();
            
            if (!document.body.classList.contains('theme-paper')) return;
            
            // Create canvas for drawing
            paperCanvas = document.createElement('canvas');
            paperCanvas.id = 'paper-drawing-canvas';
            paperCanvas.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: 5; background: transparent; cursor: crosshair;';
            paperCanvas.width = window.innerWidth;
            paperCanvas.height = window.innerHeight;
            paperCtx = paperCanvas.getContext('2d');
            paperCtx.strokeStyle = paperColor;
            paperCtx.lineWidth = paperBrushSize;
            paperCtx.lineCap = 'round';
            paperCtx.lineJoin = 'round';
            document.body.appendChild(paperCanvas);
            
            // Drawing events - use capture to ensure they fire
            paperCanvas.addEventListener('mousedown', handlePaperMouseDown, true);
            paperCanvas.addEventListener('mousemove', handlePaperMouseMove, true);
            paperCanvas.addEventListener('mouseup', handlePaperMouseUp, true);
            paperCanvas.addEventListener('mouseleave', handlePaperMouseUp, true);
            paperCanvas.addEventListener('touchstart', handlePaperTouchStart, { passive: false, capture: true });
            paperCanvas.addEventListener('touchmove', handlePaperTouchMove, { passive: false, capture: true });
            paperCanvas.addEventListener('touchend', handlePaperTouchEnd, { capture: true });
        }
        
        function handlePaperMouseDown(e) {
            isPaperDrawing = true;
            const rect = paperCanvas.getBoundingClientRect();
            lastPaperX = e.clientX - rect.left;
            lastPaperY = e.clientY - rect.top;
            drawPaperPoint(lastPaperX, lastPaperY);
        }
        
        function handlePaperMouseMove(e) {
            if (!isPaperDrawing) return;
            const rect = paperCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawPaperLine(lastPaperX, lastPaperY, x, y);
            lastPaperX = x;
            lastPaperY = y;
        }
        
        function handlePaperMouseUp() {
            isPaperDrawing = false;
        }
        
        function handlePaperTouchStart(e) {
            e.preventDefault();
            isPaperDrawing = true;
            const touch = e.touches[0];
            const rect = paperCanvas.getBoundingClientRect();
            lastPaperX = touch.clientX - rect.left;
            lastPaperY = touch.clientY - rect.top;
            drawPaperPoint(lastPaperX, lastPaperY);
        }
        
        function handlePaperTouchMove(e) {
            e.preventDefault();
            if (!isPaperDrawing) return;
            const touch = e.touches[0];
            const rect = paperCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawPaperLine(lastPaperX, lastPaperY, x, y);
            lastPaperX = x;
            lastPaperY = y;
        }
        
        function handlePaperTouchEnd(e) {
            e.preventDefault();
            isPaperDrawing = false;
        }
        
        function drawPaperPoint(x, y) {
            if (!paperCtx) return;
            paperCtx.fillStyle = paperColor;
            paperCtx.beginPath();
            paperCtx.arc(x, y, paperBrushSize / 2, 0, Math.PI * 2);
            paperCtx.fill();
        }
        
        function drawPaperLine(x1, y1, x2, y2) {
            if (!paperCtx) return;
            paperCtx.strokeStyle = paperColor;
            paperCtx.lineWidth = paperBrushSize;
            paperCtx.beginPath();
            paperCtx.moveTo(x1, y1);
            paperCtx.lineTo(x2, y2);
            paperCtx.stroke();
        }
        
        function cleanupPaperDrawing() {
            if (paperCanvas) {
                paperCanvas.remove();
                paperCanvas = null;
                paperCtx = null;
            }
        }
        
        function setupPaperTheme() {
            if (document.body.classList.contains('theme-paper')) {
                setTimeout(() => {
                    initPaperDrawing();
                }, 100);
            } else {
                cleanupPaperDrawing();
            }
        }
        
        // Clouds theme - animated clouds
        let cloudElements = [];
        let cloudInterval = null;
        
        function createCloud() {
            if (!document.body.classList.contains('theme-clouds')) return;
            
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            const size = 60 + Math.random() * 80; // Random size between 60-140px
            cloud.style.width = size + 'px';
            cloud.style.height = size * 0.6 + 'px';
            cloud.style.top = (Math.random() * 60 + 10) + '%'; // Random vertical position
            cloud.style.left = '-200px';
            cloud.style.animationDuration = (15 + Math.random() * 10) + 's'; // Random speed
            cloud.style.animationDelay = (Math.random() * 5) + 's';
            document.body.appendChild(cloud);
            cloudElements.push(cloud);
            
            // Remove cloud after animation
            setTimeout(() => {
                if (cloud.parentNode) {
                    cloud.remove();
                    cloudElements = cloudElements.filter(c => c !== cloud);
                }
            }, 30000);
        }
        
        function cleanupClouds() {
            cloudElements.forEach(cloud => cloud.remove());
            cloudElements = [];
            if (cloudInterval) {
                clearInterval(cloudInterval);
                cloudInterval = null;
            }
        }
        
        function setupCloudsTheme() {
            if (document.body.classList.contains('theme-clouds')) {
                // Create initial clouds
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => createCloud(), i * 2000);
                }
                // Create new clouds periodically
                cloudInterval = setInterval(() => {
                    if (cloudElements.length < 8) {
                        createCloud();
                    }
                }, 5000);
            } else {
                cleanupClouds();
            }
        }
        
        // Flashcard theme - interactive flashcards
        let flashcards = [];
        let flashcardCounter = 0;
        
        function saveFlashcards() {
            const flashcardData = flashcards.map(flashcard => {
                const header = flashcard.querySelector('.flashcard-header');
                const content = flashcard.querySelector('.flashcard-content');
                return {
                    id: flashcard.id,
                    x: parseInt(flashcard.style.left) || 0,
                    y: parseInt(flashcard.style.top) || 0,
                    headerText: header ? header.textContent : '',
                    contentText: content ? (content.textContent === 'Click to write...' ? '' : content.textContent) : ''
                };
            });
            localStorage.setItem('flashcards', JSON.stringify(flashcardData));
            localStorage.setItem('flashcardCounter', flashcardCounter.toString());
        }
        
        function loadFlashcards() {
            const savedFlashcards = localStorage.getItem('flashcards');
            const savedCounter = localStorage.getItem('flashcardCounter');
            
            if (savedCounter) {
                flashcardCounter = parseInt(savedCounter) || 0;
            }
            
            if (savedFlashcards) {
                try {
                    const flashcardData = JSON.parse(savedFlashcards);
                    flashcardData.forEach(data => {
                        createFlashcard(data.x, data.y, data.id, data.headerText, data.contentText);
                    });
                } catch (e) {
                    console.error('Error loading flashcards:', e);
                }
            }
        }
        
        function createFlashcard(x = null, y = null, id = null, headerText = null, contentText = null) {
            if (!document.body.classList.contains('theme-flashcard')) {
                showCommandFeedback('flashcard', 'Flashcards only work in flashcard theme', false);
                return;
            }
            
            const flashcard = document.createElement('div');
            flashcard.className = 'flashcard';
            
            if (id) {
                flashcard.id = id;
                const idNum = parseInt(id.replace('flashcard-', ''));
                if (idNum > flashcardCounter) {
                    flashcardCounter = idNum;
                }
            } else {
                flashcardCounter++;
                flashcard.id = `flashcard-${flashcardCounter}`;
            }
            
            // Position
            if (x === null || y === null) {
                x = window.innerWidth / 2 - 150;
                y = window.innerHeight / 2 - 100;
            }
            flashcard.style.left = x + 'px';
            flashcard.style.top = y + 'px';
            
            // Header
            const header = document.createElement('div');
            header.className = 'flashcard-header';
            header.textContent = headerText || `Flashcard ${flashcardCounter}`;
            header.contentEditable = true;
            
            // Save on header edit
            header.addEventListener('input', () => {
                saveFlashcards();
            });
            header.addEventListener('blur', () => {
                saveFlashcards();
            });
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'flashcard-close';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                flashcard.remove();
                flashcards = flashcards.filter(f => f !== flashcard);
                saveFlashcards();
            };
            
            // Content area
            const content = document.createElement('div');
            content.className = 'flashcard-content';
            content.contentEditable = true;
            if (contentText !== null && contentText !== '') {
                content.textContent = contentText;
            } else {
                content.textContent = 'Click to write...';
            }
            content.onfocus = function() {
                if (this.textContent === 'Click to write...') {
                    this.textContent = '';
                }
            };
            content.onblur = function() {
                if (this.textContent.trim() === '') {
                    this.textContent = 'Click to write...';
                }
                saveFlashcards();
            };
            
            // Save on content edit
            content.addEventListener('input', () => {
                saveFlashcards();
            });
            
            flashcard.appendChild(closeBtn);
            flashcard.appendChild(header);
            flashcard.appendChild(content);
            document.body.appendChild(flashcard);
            flashcards.push(flashcard);
            
            // Make draggable
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            
            header.addEventListener('mousedown', (e) => {
                if (e.target === header || e.target === closeBtn) {
                    isDragging = true;
                    flashcard.classList.add('dragging');
                    initialX = e.clientX - flashcard.offsetLeft;
                    initialY = e.clientY - flashcard.offsetTop;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    // Keep within bounds
                    currentX = Math.max(0, Math.min(window.innerWidth - flashcard.offsetWidth, currentX));
                    currentY = Math.max(0, Math.min(window.innerHeight - flashcard.offsetHeight, currentY));
                    
                    flashcard.style.left = currentX + 'px';
                    flashcard.style.top = currentY + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    flashcard.classList.remove('dragging');
                    saveFlashcards(); // Save position after dragging
                }
            });
            
            if (!id) {
                saveFlashcards();
                showCommandFeedback('flashcard', `Created flashcard ${flashcardCounter}`, true);
            }
        }
        
        function cleanupFlashcards() {
            flashcards.forEach(flashcard => flashcard.remove());
            flashcards = [];
            // Don't reset counter, keep it for continuity
        }
        
        function setupFlashcardTheme() {
            if (document.body.classList.contains('theme-flashcard')) {
                // Load saved flashcards
                setTimeout(() => {
                    loadFlashcards();
                    // If no saved flashcards, create a default one
                    if (flashcards.length === 0) {
                        createFlashcard();
                    }
                }, 100);
            } else {
                cleanupFlashcards();
            }
        }
        
        // Make createFlashcard globally accessible
        window.createFlashcard = createFlashcard;
        
        // Firework Theme
        let fireworkKeyHandler = null;
        const fireworkColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#ff0088', '#88ff00', '#0088ff'];
        
        function setupFireworkTheme() {
            // Always remove existing handler first to prevent duplicates
            if (typeof fireworkKeyHandler !== 'undefined' && fireworkKeyHandler) {
                try {
                    document.removeEventListener('keydown', fireworkKeyHandler);
                } catch (e) {
                    console.error('Error removing firework handler:', e);
                }
                fireworkKeyHandler = null;
            }
            
            // Clean up any existing fireworks
            if (typeof cleanupFireworks === 'function') {
                try {
                    cleanupFireworks();
                } catch (e) {
                    console.error('Error cleaning up fireworks:', e);
                }
            }
            
            // Only add handler if firework theme is active
            if (document.body.classList.contains('theme-firework')) {
                fireworkKeyHandler = (e) => {
                    // Check if still in firework theme
                    if (!document.body.classList.contains('theme-firework')) return;
                    
                    // Don't trigger on command input
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && document.activeElement === commandInput) return;
                    
                    // Don't trigger on special keys (Ctrl, Alt, etc.)
                    if (e.ctrlKey || e.altKey || e.metaKey) return;
                    
                    // Only handle letter keys (a-z, A-Z)
                    const key = e.key;
                    if (key.length === 1 && /[a-zA-Z]/.test(key)) {
                        // Shoot from random position at bottom
                        createFirework(key.toUpperCase());
                    }
                };
                
                document.addEventListener('keydown', fireworkKeyHandler);
            }
        }
        
        function createFirework(letter, startX) {
            // Use random position at bottom if no x position provided
            const x = startX || (50 + Math.random() * (window.innerWidth - 100));
            const y = window.innerHeight;
            
            // Create rocket
            const rocket = document.createElement('div');
            rocket.className = 'firework-rocket';
            rocket.textContent = 'ðŸš€';
            rocket.style.left = x + 'px';
            rocket.style.bottom = '0px';
            document.body.appendChild(rocket);
            
            // Calculate explosion position (near top of screen)
            const explosionY = window.innerHeight * 0.3 + Math.random() * (window.innerHeight * 0.2);
            const explosionX = x + (Math.random() - 0.5) * 100; // Slight random offset
            
            // Remove rocket after launch
            setTimeout(() => {
                rocket.remove();
                
                // Create explosion with letter
                const explosion = document.createElement('div');
                explosion.className = 'firework-explosion';
                explosion.textContent = letter;
                explosion.style.left = explosionX + 'px';
                explosion.style.top = explosionY + 'px';
                explosion.style.color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
                explosion.style.transform = 'translate(-50%, -50%)';
                document.body.appendChild(explosion);
                
                // Create particles
                const particleCount = 30;
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'firework-particle';
                    particle.style.left = explosionX + 'px';
                    particle.style.top = explosionY + 'px';
                    
                    // Random direction and distance
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const distance = 50 + Math.random() * 100;
                    const dx = Math.cos(angle) * distance;
                    const dy = Math.sin(angle) * distance;
                    
                    particle.style.setProperty('--dx', dx + 'px');
                    particle.style.setProperty('--dy', dy + 'px');
                    particle.style.background = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
                    particle.style.boxShadow = `0 0 10px ${particle.style.background}`;
                    
                    document.body.appendChild(particle);
                    
                    // Remove particle after animation
                    setTimeout(() => {
                        particle.remove();
                    }, 1500);
                }
                
                // Remove explosion after animation
                setTimeout(() => {
                    explosion.remove();
                }, 1500);
            }, 1000);
        }
        
        function cleanupFireworks() {
            // Remove all firework elements
            document.querySelectorAll('.firework-rocket, .firework-explosion, .firework-particle').forEach(el => el.remove());
            
            // Remove handler if it exists
            if (fireworkKeyHandler) {
                document.removeEventListener('keydown', fireworkKeyHandler);
                fireworkKeyHandler = null;
            }
        }
        
        // MLG Theme
        let mlgKeyHandler = null;
        let mlgClickHandler = null;
        let mlgMouseHandler = null;
        let mlgEmojiInterval = null;
        const mlgEmojis = ['ðŸ”¥', 'ðŸ’¯', 'ðŸ‘Œ', 'ðŸ˜Ž', 'ðŸŽ®', 'ðŸ†', 'â­', 'ðŸ’ª', 'ðŸš€', 'ðŸŽ¯', 'ðŸ’¥', 'âš¡', 'ðŸŽ‰', 'ðŸ’Ž', 'ðŸ‘‘', 'ðŸŽŠ', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸŽˆ', 'ðŸŽ', 'ðŸ…', 'ðŸ¥‡', 'ðŸŽª', 'ðŸŽ­', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽ¸', 'ðŸ¥', 'ðŸŽº', 'ðŸŽ»', 'ðŸŽ¹', 'ðŸŽ²', 'ðŸŽ°', 'ðŸ•¹ï¸', 'ðŸ¹', 'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸŽ±', 'ðŸ“', 'ðŸ¸', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸ¥…', 'â›¸ï¸', 'ðŸ¥Œ', 'ðŸ›·', 'ðŸš²', 'ðŸ›´', 'ðŸ›¹', 'ðŸ›¼', 'ðŸ›¸', 'ðŸš', 'âœˆï¸', 'ðŸ›©ï¸', 'ðŸ›«', 'ðŸ›¬', 'ðŸª‚', 'ðŸ’º', 'ðŸš¢', 'â›µ', 'ðŸ›¥ï¸', 'ðŸš¤', 'ðŸ›³ï¸', 'â›´ï¸', 'ðŸš€', 'ðŸ›¸', 'ðŸ›°ï¸'];
        let mlgAudioContext = null;
        
        // Initialize audio context for MLG sounds
        function initMLGAudio() {
            try {
                if (!mlgAudioContext) {
                    mlgAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            } catch (e) {
                console.error('Error initializing MLG audio:', e);
            }
        }
        
        // Play airhorn sound
        function playMLGAirhorn() {
            if (!mlgAudioContext) initMLGAudio();
            if (!mlgAudioContext) return;
            
            try {
                const oscillator = mlgAudioContext.createOscillator();
                const gainNode = mlgAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(mlgAudioContext.destination);
                
                // Airhorn-like sound (multiple frequencies)
                oscillator.frequency.setValueAtTime(200, mlgAudioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, mlgAudioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(400, mlgAudioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, mlgAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, mlgAudioContext.currentTime + 0.3);
                
                oscillator.start(mlgAudioContext.currentTime);
                oscillator.stop(mlgAudioContext.currentTime + 0.3);
            } catch (e) {
                console.error('Error playing airhorn:', e);
            }
        }
        
        // Play "OH" sound
        function playMLGOh() {
            if (!mlgAudioContext) initMLGAudio();
            if (!mlgAudioContext) return;
            
            try {
                const oscillator = mlgAudioContext.createOscillator();
                const gainNode = mlgAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(mlgAudioContext.destination);
                
                // "OH" sound - rising tone
                oscillator.frequency.setValueAtTime(150, mlgAudioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(300, mlgAudioContext.currentTime + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(500, mlgAudioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0.2, mlgAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, mlgAudioContext.currentTime + 0.4);
                
                oscillator.type = 'sine';
                oscillator.start(mlgAudioContext.currentTime);
                oscillator.stop(mlgAudioContext.currentTime + 0.4);
            } catch (e) {
                console.error('Error playing OH sound:', e);
            }
        }
        
        // Play random MLG sound effect
        function playMLGRandomSound() {
            if (!mlgAudioContext) initMLGAudio();
            if (!mlgAudioContext) return;
            
            try {
                const oscillator = mlgAudioContext.createOscillator();
                const gainNode = mlgAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(mlgAudioContext.destination);
                
                // Random beep
                const freq = 300 + Math.random() * 400;
                oscillator.frequency.setValueAtTime(freq, mlgAudioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freq * 1.5, mlgAudioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.15, mlgAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, mlgAudioContext.currentTime + 0.1);
                
                oscillator.type = 'square';
                oscillator.start(mlgAudioContext.currentTime);
                oscillator.stop(mlgAudioContext.currentTime + 0.1);
            } catch (e) {
                console.error('Error playing random sound:', e);
            }
        }
        
        function setupMLGTheme() {
            // Clean up existing handlers
            if (typeof mlgKeyHandler !== 'undefined' && mlgKeyHandler) {
                try {
                    document.removeEventListener('keydown', mlgKeyHandler);
                } catch (e) {
                    console.error('Error removing MLG key handler:', e);
                }
                mlgKeyHandler = null;
            }
            if (typeof mlgClickHandler !== 'undefined' && mlgClickHandler) {
                try {
                    document.removeEventListener('click', mlgClickHandler);
                } catch (e) {
                    console.error('Error removing MLG click handler:', e);
                }
                mlgClickHandler = null;
            }
            if (typeof mlgMouseHandler !== 'undefined' && mlgMouseHandler) {
                try {
                    document.removeEventListener('mousemove', mlgMouseHandler);
                } catch (e) {
                    console.error('Error removing MLG mouse handler:', e);
                }
                mlgMouseHandler = null;
            }
            
            // Clean up existing MLG elements
            cleanupMLGEffects();
            
            if (document.body.classList.contains('theme-mlg')) {
                // Key handler - create "OH OH OHHHHH" on spacebar
                mlgKeyHandler = (e) => {
                    if (!document.body.classList.contains('theme-mlg')) return;
                    
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && document.activeElement === commandInput) return;
                    
                    if (e.key === ' ' || e.key === 'Space') {
                        e.preventDefault();
                        createMLGOh();
                        playMLGOh();
                    } else if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
                        // Random MLG effects on keypress
                        if (Math.random() < 0.3) {
                            createMLGAirhorn();
                            playMLGAirhorn();
                        } else if (Math.random() < 0.2) {
                            playMLGRandomSound();
                        }
                    }
                };
                document.addEventListener('keydown', mlgKeyHandler);
                
                // Click handler - spawn Doritos and Mountain Dew
                mlgClickHandler = (e) => {
                    if (!document.body.classList.contains('theme-mlg')) return;
                    
                    const commandInput = document.getElementById('commandInput');
                    if (commandInput && (e.target === commandInput || commandInput.contains(e.target))) return;
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (Math.random() < 0.5) {
                        createMLGDorito(e.clientX, e.clientY);
                    } else {
                        createMLGMountainDew(e.clientX, e.clientY);
                    }
                    // Play sound on click
                    if (Math.random() < 0.5) {
                        playMLGRandomSound();
                    }
                };
                document.addEventListener('click', mlgClickHandler, true);
                
                // Mouse move handler - occasional airhorns
                mlgMouseHandler = (e) => {
                    if (!document.body.classList.contains('theme-mlg')) return;
                    if (Math.random() < 0.01) { // 1% chance
                        createMLGAirhorn(e.clientX, e.clientY);
                        playMLGAirhorn();
                    }
                };
                document.addEventListener('mousemove', mlgMouseHandler);
                
                // Spawn emojis from all sides continuously
                mlgEmojiInterval = setInterval(() => {
                    if (!document.body.classList.contains('theme-mlg')) {
                        if (mlgEmojiInterval) {
                            clearInterval(mlgEmojiInterval);
                            mlgEmojiInterval = null;
                        }
                        return;
                    }
                    
                    // Spawn multiple emojis at once
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            createMLGEmojiFromRandomSide();
                            // Occasional sound with emojis
                            if (Math.random() < 0.1) {
                                playMLGRandomSound();
                            }
                        }, i * 100);
                    }
                    
                    // Also spawn Doritos and Mountain Dew occasionally
                    if (Math.random() < 0.3) { // 30% chance
                        const side = Math.floor(Math.random() * 4);
                        let x, y;
                        
                        if (side === 0) { // Top
                            x = Math.random() * window.innerWidth;
                            y = -50;
                        } else if (side === 1) { // Right
                            x = window.innerWidth + 50;
                            y = Math.random() * window.innerHeight;
                        } else if (side === 2) { // Bottom
                            x = Math.random() * window.innerWidth;
                            y = window.innerHeight + 50;
                        } else { // Left
                            x = -50;
                            y = Math.random() * window.innerHeight;
                        }
                        
                        if (Math.random() < 0.5) {
                            createMLGDorito(x, y);
                        } else {
                            createMLGMountainDew(x, y);
                        }
                    }
                }, 200); // Spawn every 200ms
            }
        }
        
        function createMLGEmojiFromRandomSide() {
            if (!document.body.classList.contains('theme-mlg')) return;
            
            const emoji = mlgEmojis[Math.floor(Math.random() * mlgEmojis.length)];
            const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
            
            const emojiEl = document.createElement('div');
            emojiEl.className = 'mlg-emoji-rain';
            emojiEl.textContent = emoji;
            
            let startX, startY, endX, endY;
            
            if (side === 0) { // Top
                startX = Math.random() * window.innerWidth;
                startY = -50;
                endX = startX + (Math.random() - 0.5) * 400;
                endY = window.innerHeight + 50;
            } else if (side === 1) { // Right
                startX = window.innerWidth + 50;
                startY = Math.random() * window.innerHeight;
                endX = -50;
                endY = startY + (Math.random() - 0.5) * 400;
            } else if (side === 2) { // Bottom
                startX = Math.random() * window.innerWidth;
                startY = window.innerHeight + 50;
                endX = startX + (Math.random() - 0.5) * 400;
                endY = -50;
            } else { // Left
                startX = -50;
                startY = Math.random() * window.innerHeight;
                endX = window.innerWidth + 50;
                endY = startY + (Math.random() - 0.5) * 400;
            }
            
            emojiEl.style.left = startX + 'px';
            emojiEl.style.top = startY + 'px';
            
            const dx = endX - startX;
            const dy = endY - startY;
            
            emojiEl.style.setProperty('--dx', dx + 'px');
            emojiEl.style.setProperty('--dy', dy + 'px');
            
            document.body.appendChild(emojiEl);
            
            setTimeout(() => {
                emojiEl.remove();
            }, 3000);
        }
        
        function createMLGOh() {
            const texts = ['OH', 'OH', 'OHHHHH', 'MLG', '360', 'NO SCOPE'];
            const text = texts[Math.floor(Math.random() * texts.length)];
            
            const oh = document.createElement('div');
            oh.className = 'mlg-oh-text';
            oh.textContent = text;
            oh.style.left = (window.innerWidth / 2) + 'px';
            oh.style.top = (window.innerHeight / 2) + 'px';
            oh.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(oh);
            
            setTimeout(() => {
                oh.remove();
            }, 1000);
        }
        
        function createMLGAirhorn(x, y) {
            const airhorn = document.createElement('div');
            airhorn.className = 'mlg-airhorn';
            airhorn.textContent = 'ðŸ”Š';
            airhorn.style.left = (x || window.innerWidth / 2) + 'px';
            airhorn.style.top = (y || window.innerHeight / 2) + 'px';
            airhorn.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(airhorn);
            
            setTimeout(() => {
                airhorn.remove();
            }, 500);
        }
        
        function createMLGDorito(x, y) {
            const dorito = document.createElement('div');
            dorito.className = 'mlg-dorito';
            dorito.textContent = 'ðŸŒ®';
            dorito.style.left = x + 'px';
            dorito.style.top = y + 'px';
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 200;
            const dx = Math.cos(angle) * distance;
            const dy = Math.sin(angle) * distance;
            
            dorito.style.setProperty('--dx', dx + 'px');
            dorito.style.setProperty('--dy', dy + 'px');
            document.body.appendChild(dorito);
            
            setTimeout(() => {
                dorito.remove();
            }, 2000);
        }
        
        function createMLGMountainDew(x, y) {
            const dew = document.createElement('div');
            dew.className = 'mlg-mountain-dew';
            dew.textContent = 'ðŸ¥¤';
            dew.style.left = x + 'px';
            dew.style.top = y + 'px';
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 200;
            const dx = Math.cos(angle) * distance;
            const dy = Math.sin(angle) * distance;
            
            dew.style.setProperty('--dx', dx + 'px');
            dew.style.setProperty('--dy', dy + 'px');
            document.body.appendChild(dew);
            
            setTimeout(() => {
                dew.remove();
            }, 2000);
        }
        
        function cleanupMLGEffects() {
            document.querySelectorAll('.mlg-airhorn, .mlg-oh-text, .mlg-dorito, .mlg-mountain-dew, .mlg-emoji-rain').forEach(el => el.remove());
            
            // Clear emoji interval
            if (typeof mlgEmojiInterval !== 'undefined' && mlgEmojiInterval) {
                try {
                    clearInterval(mlgEmojiInterval);
                } catch (e) {}
                mlgEmojiInterval = null;
            }
            
            // Remove handlers if they exist
            if (typeof mlgKeyHandler !== 'undefined' && mlgKeyHandler) {
                try {
                    document.removeEventListener('keydown', mlgKeyHandler);
                } catch (e) {}
                mlgKeyHandler = null;
            }
            if (typeof mlgClickHandler !== 'undefined' && mlgClickHandler) {
                try {
                    document.removeEventListener('click', mlgClickHandler);
                } catch (e) {}
                mlgClickHandler = null;
            }
            if (typeof mlgMouseHandler !== 'undefined' && mlgMouseHandler) {
                try {
                    document.removeEventListener('mousemove', mlgMouseHandler);
                } catch (e) {}
                mlgMouseHandler = null;
            }
        }
        
        // Remote Desktop System
        let desktopIcons = [];
        let desktopWindows = [];
        let selectedIcon = null;
        let iconCounter = 0;
        let windowZIndex = 100;
        
        function saveDesktopState() {
            const state = {
                icons: desktopIcons.map(icon => ({
                    type: icon.type,
                    name: icon.name,
                    x: icon.x,
                    y: icon.y,
                    id: icon.id
                })),
                iconCounter: iconCounter
            };
            localStorage.setItem('desktopState', JSON.stringify(state));
        }
        
        function loadDesktopState() {
            const saved = localStorage.getItem('desktopState');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    if (state.icons && state.icons.length > 0) {
                        // Restore icon counter
                        iconCounter = state.iconCounter || 0;
                        
                        // Restore icons
                        state.icons.forEach(iconData => {
                            addDesktopIcon(iconData.type, iconData.name, iconData.x, iconData.y, iconData.id);
                        });
                        return true; // State loaded
                    }
                } catch (e) {
                    console.error('Error loading desktop state:', e);
                }
            }
            return false; // No state to load
        }
        
        function initRemoteDesktop() {
            const desktop = document.getElementById('remoteDesktop');
            const iconsContainer = document.getElementById('desktopIcons');
            
            if (!desktop || !iconsContainer) return;
            
            // Hide command bar when on desktop
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) {
                commandBar.style.display = 'none';
            }
            
            // Load saved desktop state, or add default icons
            const stateLoaded = loadDesktopState();
            if (!stateLoaded) {
                // Add default icons only if no saved state
                addDesktopIcon('paper', 'Paper', 10, 10);
                addDesktopIcon('paint', 'Paint', 10, 100);
                addDesktopIcon('computer', 'Computer', 10, 190);
                addDesktopIcon('appstore', 'App Store', 10, 280);
                saveDesktopState();
            }
            
            // Desktop right-click
            desktop.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.desktop-icon') || e.target.closest('.win95-window')) {
                    return; // Don't show menu on icons or windows
                }
                e.preventDefault();
                showDesktopContextMenu(e.clientX, e.clientY);
            });
            
            // Click to close context menus
            desktop.addEventListener('click', () => {
                hideContextMenus();
            });
            
            // Trash can drag and drop
            const trashCan = document.getElementById('trashCan');
            if (trashCan) {
                trashCan.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    trashCan.classList.add('trash-can-drag-over');
                });
                
                trashCan.addEventListener('dragleave', () => {
                    trashCan.classList.remove('trash-can-drag-over');
                });
                
                trashCan.addEventListener('drop', (e) => {
                    e.preventDefault();
                    trashCan.classList.remove('trash-can-drag-over');
                    const iconId = e.dataTransfer.getData('text/plain');
                    deleteDesktopIconById(iconId);
                });
            }
        }
        
        function addDesktopIcon(type, name, x, y) {
            iconCounter++;
            const iconId = `icon-${iconCounter}`;
            const iconsContainer = document.getElementById('desktopIcons');
            if (!iconsContainer) return;
            
            const icon = document.createElement('div');
            icon.className = 'desktop-icon';
            icon.id = iconId;
            icon.style.position = 'absolute';
            icon.style.left = x + 'px';
            icon.style.top = y + 'px';
            icon.draggable = true;
            
            // Icon image
            const iconImg = document.createElement('div');
            iconImg.className = 'desktop-icon-icon';
            if (type === 'paper') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ“„</text></svg>") no-repeat center';
            } else if (type === 'paint') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽ¨</text></svg>") no-repeat center';
            } else if (type === 'computer') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ’»</text></svg>") no-repeat center';
            } else if (type === 'appstore') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸª</text></svg>") no-repeat center';
            } else if (type === 'minesweeper') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ’£</text></svg>") no-repeat center';
            } else if (type === 'pong') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽ®</text></svg>") no-repeat center';
            } else if (type === 'sandboxles') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ–ï¸</text></svg>") no-repeat center';
            } else if (type === 'snake') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ</text></svg>") no-repeat center';
            } else if (type === 'blockbreaker') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ§±</text></svg>") no-repeat center';
            } else if (type === 'chatbot') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ¤–</text></svg>") no-repeat center';
            } else if (type === 'passwordgame') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ”</text></svg>") no-repeat center';
            } else if (type === 'paintv2') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽ¨</text></svg>") no-repeat center';
            } else if (type === 'gifmaker') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽ¬</text></svg>") no-repeat center';
            } else if (type === 'clicker') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ–±ï¸</text></svg>") no-repeat center';
            } else if (type === 'calculator') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ”¢</text></svg>") no-repeat center';
            } else if (type === 'notes') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ“</text></svg>") no-repeat center';
            } else if (type === 'calendar') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ“…</text></svg>") no-repeat center';
            } else if (type === 'weather') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŒ¤ï¸</text></svg>") no-repeat center';
            } else if (type === 'music') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽµ</text></svg>") no-repeat center';
            } else if (type === 'files') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ“</text></svg>") no-repeat center';
            } else if (type === 'terminal') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ’»</text></svg>") no-repeat center';
            } else if (type === 'code') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ’¾</text></svg>") no-repeat center';
            } else if (type === 'image') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸ–¼ï¸</text></svg>") no-repeat center';
            } else if (type === 'video') {
                iconImg.style.background = 'url("data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 32 32\'><rect width=\'32\' height=\'32\' fill=\'%23fff\' stroke=\'%23000\' stroke-width=\'1\'/><text x=\'16\' y=\'20\' font-size=\'20\' text-anchor=\'middle\' fill=\'%23000\'>ðŸŽ¬</text></svg>") no-repeat center';
            }
            iconImg.style.backgroundSize = 'contain';
            
            // Icon label
            const label = document.createElement('div');
            label.className = 'desktop-icon-label';
            label.textContent = name;
            label.contentEditable = false;
            
            icon.appendChild(iconImg);
            icon.appendChild(label);
            
            // Right-click menu
            icon.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                selectedIcon = iconId;
                if (type === 'computer') {
                    showComputerContextMenu(e.clientX, e.clientY);
                } else {
                    showIconContextMenu(e.clientX, e.clientY);
                }
            });
            
            // Click to select
            let clickTimer = null;
            icon.addEventListener('click', (e) => {
                if (e.detail === 1) { // Single click
                    clickTimer = setTimeout(() => {
                        selectIcon(iconId);
                    }, 200); // Delay to detect double-click
                }
            });
            
            // Double-click to open (clear single click timer)
            icon.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                }
                // Actually open the app
                if (type === 'appstore') {
                    openAppStore();
                } else if (type === 'pong') {
                    openPongApp(iconId, name);
                } else if (type === 'sandboxles') {
                    openSandboxlesApp(iconId, name);
                } else if (type === 'snake') {
                    openSnakeApp(iconId, name);
                } else if (type === 'blockbreaker') {
                    openBlockBreakerApp(iconId, name);
                } else if (type === 'chatbot') {
                    openChatbotApp(iconId, name);
                } else if (type === 'passwordgame') {
                    openPasswordGameApp(iconId, name);
                } else if (type === 'paintv2') {
                    openPaintV2App(iconId, name);
                } else if (type === 'gifmaker') {
                    openGifMakerApp(iconId, name);
                } else if (type === 'clicker') {
                    openClickerApp(iconId, name);
                } else if (type === 'calculator') {
                    openCalculatorApp(iconId, name);
                } else if (type === 'notes') {
                    openNotesApp(iconId, name);
                } else if (type === 'calendar') {
                    openCalendarApp(iconId, name);
                } else if (type === 'weather') {
                    openWeatherApp(iconId, name);
                } else if (type === 'music') {
                    openMusicApp(iconId, name);
                } else if (type === 'files') {
                    openFilesApp(iconId, name);
                } else if (type === 'terminal') {
                    openTerminalApp(iconId, name);
                } else if (type === 'code') {
                    openCodeApp(iconId, name);
                } else if (type === 'image') {
                    openImageApp(iconId, name);
                } else if (type === 'video') {
                    openVideoApp(iconId, name);
                } else if (type !== 'computer') {
                    openDesktopApp(type, iconId, name);
                }
            });
            
            // Drag and drop - allow dragging to reposition or to trash
            let isDraggingIcon = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let dragStartTime = 0;
            
            icon.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragStartTime = Date.now();
                    isDraggingIcon = false; // Will be set to true if mouse moves
                }
            });
            
            icon.addEventListener('mousemove', (e) => {
                if (dragStartTime > 0) {
                    const moveDistance = Math.abs(e.clientX - dragStartX) + Math.abs(e.clientY - dragStartY);
                    if (moveDistance > 5) { // Start dragging after 5px movement
                        isDraggingIcon = true;
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                    }
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDraggingIcon && icon.parentNode) {
                    const iconsContainer = document.getElementById('desktopIcons');
                    if (iconsContainer) {
                        const containerRect = iconsContainer.getBoundingClientRect();
                        const iconRect = icon.getBoundingClientRect();
                        const newX = e.clientX - containerRect.left - (iconRect.width / 2);
                        const newY = e.clientY - containerRect.top - (iconRect.height / 2);
                        
                        // Keep within bounds
                        const maxX = iconsContainer.offsetWidth - icon.offsetWidth;
                        const maxY = iconsContainer.offsetHeight - icon.offsetHeight;
                        
                        icon.style.left = Math.max(0, Math.min(maxX, newX)) + 'px';
                        icon.style.top = Math.max(0, Math.min(maxY, newY)) + 'px';
                        
                        // Update stored position
                        const iconData = desktopIcons.find(i => i.id === iconId);
                        if (iconData) {
                            iconData.x = parseFloat(icon.style.left);
                            iconData.y = parseFloat(icon.style.top);
                            saveDesktopState(); // Save after moving
                        }
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDraggingIcon = false;
                dragStartTime = 0;
            });
            
            // Also support HTML5 drag for trash can
            icon.draggable = true;
            icon.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', iconId);
                icon.style.opacity = '0.5';
            });
            
            icon.addEventListener('dragend', () => {
                icon.style.opacity = '1';
            });
            
            iconsContainer.appendChild(icon);
            
            desktopIcons.push({
                id: iconId,
                type: type,
                name: name,
                element: icon,
                x: x,
                y: y
            });
            
            // Save desktop state after adding icon
            saveDesktopState();
            
            // Save desktop state after adding icon
            saveDesktopState();
        }
        
        function selectIcon(iconId) {
            // Deselect all
            desktopIcons.forEach(icon => {
                icon.element.classList.remove('selected');
            });
            
            // Select this one
            const icon = desktopIcons.find(i => i.id === iconId);
            if (icon) {
                icon.element.classList.add('selected');
                selectedIcon = iconId;
            }
        }
        
        function showDesktopContextMenu(x, y) {
            const menu = document.getElementById('desktopContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function showIconContextMenu(x, y) {
            const menu = document.getElementById('iconContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function hideContextMenus() {
            const desktopMenu = document.getElementById('desktopContextMenu');
            const iconMenu = document.getElementById('iconContextMenu');
            const computerMenu = document.getElementById('computerContextMenu');
            if (desktopMenu) desktopMenu.classList.add('hidden');
            if (iconMenu) iconMenu.classList.add('hidden');
            if (computerMenu) computerMenu.classList.add('hidden');
        }
        
        function showComputerContextMenu(x, y) {
            const menu = document.getElementById('computerContextMenu');
            if (menu) {
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.remove('hidden');
            }
        }
        
        function powerOffDesktop() {
            hideContextMenus();
            showPage('mainPage');
        }
        
        function openSelectedIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            const icon = desktopIcons.find(i => i.id === selectedIcon);
            if (icon && icon.type !== 'computer') {
                openDesktopApp(icon.type, icon.id, icon.name);
            }
        }
        
        // App Store
        function openAppStore() {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '500px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = 'App Store';
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                window.remove();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '20px';
            content.style.overflow = 'auto';
            
            // App Store content
            const storeContent = document.createElement('div');
            storeContent.innerHTML = `
                <h2 style="font-size: 16px; margin-bottom: 15px; font-weight: bold;">Available Apps</h2>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ’£</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Minesweeper</div>
                            <div style="font-size: 11px; color: #666;">Classic minesweeper game</div>
                        </div>
                        <button id="install-minesweeper" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŽ®</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Pong</div>
                            <div style="font-size: 11px; color: #666;">Classic Pong game</div>
                        </div>
                        <button id="install-pong" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ–ï¸</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Sandboxles</div>
                            <div style="font-size: 11px; color: #666;">Interactive sandbox playground</div>
                        </div>
                        <button id="install-sandboxles" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Snake</div>
                            <div style="font-size: 11px; color: #666;">Classic snake game - 16x16 grid with 3 red apples</div>
                        </div>
                        <button id="install-snake" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ§±</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Block Breaker</div>
                            <div style="font-size: 11px; color: #666;">Classic brick breaker game - break all the blocks!</div>
                        </div>
                        <button id="install-blockbreaker" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ¤–</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Chatbot</div>
                            <div style="font-size: 11px; color: #666;">AI chatbot assistant</div>
                        </div>
                        <button id="install-chatbot" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ”</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Password Game</div>
                            <div style="font-size: 11px; color: #666;">Guess the password - word guessing game</div>
                        </div>
                        <button id="install-passwordgame" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŽ¨</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Paint v2</div>
                            <div style="font-size: 11px; color: #666;">Multiplayer drawing - draw with others in real-time!</div>
                        </div>
                        <button id="install-paintv2" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŽ¬</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">GIF Maker</div>
                            <div style="font-size: 11px; color: #666;">Create simple animations and export as GIF!</div>
                        </div>
                        <button id="install-gifmaker" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ–±ï¸</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Clicker</div>
                            <div style="font-size: 11px; color: #666;">See how many clicks you can get! Compete with everyone!</div>
                        </div>
                        <button id="install-clicker" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ”¢</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Calculator</div>
                            <div style="font-size: 11px; color: #666;">Scientific calculator with advanced functions</div>
                        </div>
                        <button id="install-calculator" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ“</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Notes</div>
                            <div style="font-size: 11px; color: #666;">Text editor for taking notes</div>
                        </div>
                        <button id="install-notes" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ“…</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Calendar</div>
                            <div style="font-size: 11px; color: #666;">Event planner and calendar</div>
                        </div>
                        <button id="install-calendar" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŒ¤ï¸</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Weather</div>
                            <div style="font-size: 11px; color: #666;">Weather widget for Cooper City, FL</div>
                        </div>
                        <button id="install-weather" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŽµ</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Music Player</div>
                            <div style="font-size: 11px; color: #666;">Play music files</div>
                        </div>
                        <button id="install-music" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ“</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">File Manager</div>
                            <div style="font-size: 11px; color: #666;">Organize files and folders</div>
                        </div>
                        <button id="install-files" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ’»</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Terminal</div>
                            <div style="font-size: 11px; color: #666;">Command-line interface</div>
                        </div>
                        <button id="install-terminal" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ’¾</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Code Editor</div>
                            <div style="font-size: 11px; color: #666;">Code editor with syntax highlighting</div>
                        </div>
                        <button id="install-code" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸ–¼ï¸</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Image Editor</div>
                            <div style="font-size: 11px; color: #666;">Photo editing tools</div>
                        </div>
                        <button id="install-image" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
                <div style="border: 1px inset #c0c0c0; padding: 15px; margin-bottom: 15px; background: #fff;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div style="font-size: 32px;">ðŸŽ¬</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px; margin-bottom: 5px;">Video Player</div>
                            <div style="font-size: 11px; color: #666;">Play video files</div>
                        </div>
                        <button id="install-video" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Install</button>
                    </div>
                </div>
            `;
            
            content.appendChild(storeContent);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            // Install buttons
            setTimeout(() => {
                const installMinesweeperBtn = document.getElementById('install-minesweeper');
                if (installMinesweeperBtn) {
                    installMinesweeperBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'minesweeper');
                        if (alreadyInstalled) {
                            alert('Minesweeper is already installed!');
                            return;
                        }
                        
                        // Add Minesweeper icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('minesweeper', 'Minesweeper', x, y);
                        alert('Minesweeper installed successfully!');
                    };
                }
                
                const installPongBtn = document.getElementById('install-pong');
                if (installPongBtn) {
                    installPongBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'pong');
                        if (alreadyInstalled) {
                            alert('Pong is already installed!');
                            return;
                        }
                        
                        // Add Pong icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('pong', 'Pong', x, y);
                        alert('Pong installed successfully!');
                    };
                }
                
                const installSandboxlesBtn = document.getElementById('install-sandboxles');
                if (installSandboxlesBtn) {
                    installSandboxlesBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'sandboxles');
                        if (alreadyInstalled) {
                            alert('Sandboxles is already installed!');
                            return;
                        }
                        
                        // Add Sandboxles icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('sandboxles', 'Sandboxles', x, y);
                        alert('Sandboxles installed successfully!');
                    };
                }
                
                const installSnakeBtn = document.getElementById('install-snake');
                if (installSnakeBtn) {
                    installSnakeBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'snake');
                        if (alreadyInstalled) {
                            alert('Snake is already installed!');
                            return;
                        }
                        
                        // Add Snake icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('snake', 'Snake', x, y);
                        alert('Snake installed successfully!');
                    };
                }
                
                const installBlockBreakerBtn = document.getElementById('install-blockbreaker');
                if (installBlockBreakerBtn) {
                    installBlockBreakerBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'blockbreaker');
                        if (alreadyInstalled) {
                            alert('Block Breaker is already installed!');
                            return;
                        }
                        
                        // Add Block Breaker icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('blockbreaker', 'Block Breaker', x, y);
                        alert('Block Breaker installed successfully!');
                    };
                }
                
                const installChatbotBtn = document.getElementById('install-chatbot');
                if (installChatbotBtn) {
                    installChatbotBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'chatbot');
                        if (alreadyInstalled) {
                            alert('Chatbot is already installed!');
                            return;
                        }
                        
                        // Add Chatbot icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('chatbot', 'Chatbot', x, y);
                        alert('Chatbot installed successfully!');
                    };
                }
                
                const installPasswordGameBtn = document.getElementById('install-passwordgame');
                if (installPasswordGameBtn) {
                    installPasswordGameBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'passwordgame');
                        if (alreadyInstalled) {
                            alert('Password Game is already installed!');
                            return;
                        }
                        
                        // Add Password Game icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('passwordgame', 'Password Game', x, y);
                        alert('Password Game installed successfully!');
                    };
                }
                
                const installPaintV2Btn = document.getElementById('install-paintv2');
                if (installPaintV2Btn) {
                    installPaintV2Btn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'paintv2');
                        if (alreadyInstalled) {
                            alert('Paint v2 is already installed!');
                            return;
                        }
                        
                        // Add Paint v2 icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('paintv2', 'Paint v2', x, y);
                        alert('Paint v2 installed successfully!');
                    };
                }
                
                const installGifMakerBtn = document.getElementById('install-gifmaker');
                if (installGifMakerBtn) {
                    installGifMakerBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'gifmaker');
                        if (alreadyInstalled) {
                            alert('GIF Maker is already installed!');
                            return;
                        }
                        
                        // Add GIF Maker icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('gifmaker', 'GIF Maker', x, y);
                        alert('GIF Maker installed successfully!');
                    };
                }
                
                const installClickerBtn = document.getElementById('install-clicker');
                if (installClickerBtn) {
                    installClickerBtn.onclick = () => {
                        // Check if already installed
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'clicker');
                        if (alreadyInstalled) {
                            alert('Clicker is already installed!');
                            return;
                        }
                        
                        // Add Clicker icon to desktop
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('clicker', 'Clicker', x, y);
                        alert('Clicker installed successfully!');
                    };
                }
                
                // Calculator install
                const installCalculatorBtn = document.getElementById('install-calculator');
                if (installCalculatorBtn) {
                    installCalculatorBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'calculator');
                        if (alreadyInstalled) {
                            alert('Calculator is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('calculator', 'Calculator', x, y);
                        alert('Calculator installed successfully!');
                    };
                }
                
                // Notes install
                const installNotesBtn = document.getElementById('install-notes');
                if (installNotesBtn) {
                    installNotesBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'notes');
                        if (alreadyInstalled) {
                            alert('Notes is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('notes', 'Notes', x, y);
                        alert('Notes installed successfully!');
                    };
                }
                
                // Calendar install
                const installCalendarBtn = document.getElementById('install-calendar');
                if (installCalendarBtn) {
                    installCalendarBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'calendar');
                        if (alreadyInstalled) {
                            alert('Calendar is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('calendar', 'Calendar', x, y);
                        alert('Calendar installed successfully!');
                    };
                }
                
                // Weather install
                const installWeatherBtn = document.getElementById('install-weather');
                if (installWeatherBtn) {
                    installWeatherBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'weather');
                        if (alreadyInstalled) {
                            alert('Weather is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('weather', 'Weather', x, y);
                        alert('Weather installed successfully!');
                    };
                }
                
                // Music Player install
                const installMusicBtn = document.getElementById('install-music');
                if (installMusicBtn) {
                    installMusicBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'music');
                        if (alreadyInstalled) {
                            alert('Music Player is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('music', 'Music Player', x, y);
                        alert('Music Player installed successfully!');
                    };
                }
                
                // File Manager install
                const installFilesBtn = document.getElementById('install-files');
                if (installFilesBtn) {
                    installFilesBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'files');
                        if (alreadyInstalled) {
                            alert('File Manager is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('files', 'File Manager', x, y);
                        alert('File Manager installed successfully!');
                    };
                }
                
                // Terminal install
                const installTerminalBtn = document.getElementById('install-terminal');
                if (installTerminalBtn) {
                    installTerminalBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'terminal');
                        if (alreadyInstalled) {
                            alert('Terminal is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('terminal', 'Terminal', x, y);
                        alert('Terminal installed successfully!');
                    };
                }
                
                // Code Editor install
                const installCodeBtn = document.getElementById('install-code');
                if (installCodeBtn) {
                    installCodeBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'code');
                        if (alreadyInstalled) {
                            alert('Code Editor is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('code', 'Code Editor', x, y);
                        alert('Code Editor installed successfully!');
                    };
                }
                
                // Image Editor install
                const installImageBtn = document.getElementById('install-image');
                if (installImageBtn) {
                    installImageBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'image');
                        if (alreadyInstalled) {
                            alert('Image Editor is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('image', 'Image Editor', x, y);
                        alert('Image Editor installed successfully!');
                    };
                }
                
                // Video Player install
                const installVideoBtn = document.getElementById('install-video');
                if (installVideoBtn) {
                    installVideoBtn.onclick = () => {
                        const alreadyInstalled = desktopIcons.some(icon => icon.type === 'video');
                        if (alreadyInstalled) {
                            alert('Video Player is already installed!');
                            return;
                        }
                        const x = Math.random() * 200 + 50;
                        const y = Math.random() * 200 + 50;
                        addDesktopIcon('video', 'Video Player', x, y);
                        alert('Video Player installed successfully!');
                    };
                }
                
            }, 100);
        }
        
        // Minesweeper app
        function openMinesweeperApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '450px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            
            // Create simple minesweeper game
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="minesweeper-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 5px;">Mines: <span id="mines-count">10</span></div>
                    <div style="font-size: 12px; margin-bottom: 5px;">Time: <span id="minesweeper-timer">0</span>s</div>
                    <button id="minesweeper-leaderboard-btn" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">Leaderboard</button>
                </div>
                <div id="minesweeper-grid" style="display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; max-width: 360px; margin: 0 auto;"></div>
            `;
            content.innerHTML = gameHTML;
            
            // Initialize minesweeper
            const gridEl = content.querySelector('#minesweeper-grid');
            const restartBtn = content.querySelector('#minesweeper-restart');
            const minesCountEl = content.querySelector('#mines-count');
            const timerEl = content.querySelector('#minesweeper-timer');
            const leaderboardBtn = content.querySelector('#minesweeper-leaderboard-btn');
            
            let minesweeperBoard = [];
            let revealed = [];
            let flagged = [];
            let gameOver = false;
            let gameStarted = false;
            let gameWon = false;
            let timer = 0;
            let timerInterval = null;
            
            // Set up close button to clean up timer
            closeBtn.onclick = () => {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            const GRID_SIZE = 10;
            const NUM_MINES = 10;
            
            function createMinesweeperBoard() {
                minesweeperBoard = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
                revealed = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
                flagged = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
                gameOver = false;
                gameStarted = false;
                gameWon = false;
                timer = 0;
                timerEl.textContent = timer;
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Place mines
                let minesPlaced = 0;
                while (minesPlaced < NUM_MINES) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    if (minesweeperBoard[row][col] !== -1) {
                        minesweeperBoard[row][col] = -1;
                        minesPlaced++;
                    }
                }
                
                // Calculate numbers
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (minesweeperBoard[row][col] !== -1) {
                            let count = 0;
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    const nr = row + dr;
                                    const nc = col + dc;
                                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                                        if (minesweeperBoard[nr][nc] === -1) count++;
                                    }
                                }
                            }
                            minesweeperBoard[row][col] = count;
                        }
                    }
                }
                
                renderMinesweeper();
            }
            
            function renderMinesweeper() {
                gridEl.innerHTML = '';
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = document.createElement('button');
                        cell.style.cssText = 'width: 30px; height: 30px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 12px; cursor: pointer; font-weight: bold;';
                        
                        if (revealed[row][col]) {
                            cell.style.background = '#d4d0c8';
                            cell.style.border = '1px inset #c0c0c0';
                            if (minesweeperBoard[row][col] === -1) {
                                cell.textContent = 'ðŸ’£';
                                cell.style.background = '#ff0000';
                            } else if (minesweeperBoard[row][col] > 0) {
                                cell.textContent = minesweeperBoard[row][col];
                                const colors = ['', '#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000000', '#808080'];
                                cell.style.color = colors[minesweeperBoard[row][col]] || '#000000';
                            }
                        } else if (flagged[row][col]) {
                            cell.textContent = 'ðŸš©';
                        }
                        
                        cell.onclick = () => {
                            if (gameOver || flagged[row][col]) return;
                            revealCell(row, col);
                        };
                        
                        cell.oncontextmenu = (e) => {
                            e.preventDefault();
                            if (gameOver || revealed[row][col]) return;
                            flagged[row][col] = !flagged[row][col];
                            renderMinesweeper();
                            updateMinesCount();
                        };
                        
                        gridEl.appendChild(cell);
                    }
                }
            }
            
            function revealCell(row, col) {
                if (revealed[row][col] || flagged[row][col] || gameOver) return;
                
                // Start timer on first click
                if (!gameStarted) {
                    gameStarted = true;
                    timer = 0;
                    timerInterval = setInterval(() => {
                        if (gameOver || gameWon) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                            return;
                        }
                        timer++;
                        timerEl.textContent = timer;
                    }, 1000);
                }
                
                revealed[row][col] = true;
                
                if (minesweeperBoard[row][col] === -1) {
                    gameOver = true;
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    alert('Game Over!');
                    renderMinesweeper();
                    return;
                }
                
                if (minesweeperBoard[row][col] === 0) {
                    // Reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr;
                            const nc = col + dc;
                            if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && !revealed[nr][nc]) {
                                revealCell(nr, nc);
                            }
                        }
                    }
                }
                
                renderMinesweeper();
                checkWin();
            }
            
            function checkWin() {
                let revealedCount = 0;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (revealed[row][col]) revealedCount++;
                    }
                }
                if (revealedCount === GRID_SIZE * GRID_SIZE - NUM_MINES) {
                    gameOver = true;
                    gameWon = true;
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    const userId = getUserId() || 'Anonymous';
                    saveMinesweeperScore(timer, userId);
                    alert(`You Win! Time: ${timer}s`);
                }
            }
            
            // Save score to Firebase leaderboard
            function saveMinesweeperScore(time, userId) {
                if (database) {
                    const scoreData = {
                        userId: userId,
                        time: time,
                        timestamp: Date.now()
                    };
                    database.ref('minesweeperLeaderboard').push(scoreData);
                } else {
                    // localStorage fallback
                    const saved = localStorage.getItem('minesweeperLeaderboard');
                    const scores = saved ? JSON.parse(saved) : [];
                    scores.push({
                        id: 'score_' + Date.now(),
                        userId: userId,
                        time: time,
                        timestamp: Date.now()
                    });
                    // Keep only top 50
                    scores.sort((a, b) => a.time - b.time);
                    scores.splice(50);
                    localStorage.setItem('minesweeperLeaderboard', JSON.stringify(scores));
                }
            }
            
            // Show leaderboard
            function showMinesweeperLeaderboard() {
                globalWindowZIndex++;
                const leaderboardWindow = document.createElement('div');
                leaderboardWindow.className = 'win95-window';
                leaderboardWindow.style.left = '150px';
                leaderboardWindow.style.top = '100px';
                leaderboardWindow.style.width = '350px';
                leaderboardWindow.style.height = '400px';
                leaderboardWindow.style.zIndex = globalWindowZIndex;
                
                const header = document.createElement('div');
                header.className = 'win95-window-header';
                
                const title = document.createElement('div');
                title.className = 'win95-window-title';
                title.textContent = 'Minesweeper Leaderboard';
                
                const controls = document.createElement('div');
                controls.className = 'win95-window-controls';
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'win95-window-button';
                closeBtn.textContent = 'Ã—';
                closeBtn.onclick = () => {
                    leaderboardWindow.remove();
                };
                
                controls.appendChild(closeBtn);
                header.appendChild(title);
                header.appendChild(controls);
                
                const content = document.createElement('div');
                content.className = 'win95-window-content';
                content.style.padding = '10px';
                content.style.overflow = 'auto';
                
                content.innerHTML = '<p style="text-align: center; margin: 10px 0;">Loading leaderboard...</p>';
                
                leaderboardWindow.appendChild(header);
                leaderboardWindow.appendChild(content);
                document.getElementById('remoteDesktop').appendChild(leaderboardWindow);
                
                // Load leaderboard
                function loadLeaderboard() {
                    if (database) {
                        database.ref('minesweeperLeaderboard').orderByChild('time').limitToFirst(20).once('value', (snapshot) => {
                            const scores = [];
                            snapshot.forEach((child) => {
                                const data = child.val();
                                scores.push(data);
                            });
                            renderLeaderboard(scores);
                        });
                    } else {
                        const saved = localStorage.getItem('minesweeperLeaderboard');
                        const scores = saved ? JSON.parse(saved).slice(0, 20) : [];
                        renderLeaderboard(scores);
                    }
                }
                
                function renderLeaderboard(scores) {
                    if (scores.length === 0) {
                        content.innerHTML = '<p style="text-align: center; margin: 10px 0;">No scores yet!</p>';
                        return;
                    }
                    
                    let html = '<div style="font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #000; padding-bottom: 5px;">Rank | Player | Time</div>';
                    scores.forEach((score, index) => {
                        html += `<div style="margin: 3px 0; font-size: 11px;">${index + 1}. ${escapeHtml(score.userId || 'Anonymous')} - ${score.time}s</div>`;
                    });
                    content.innerHTML = html;
                }
                
                loadLeaderboard();
                
                // Make draggable
                let isDragging = false;
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    leaderboardWindow.style.zIndex = ++globalWindowZIndex;
                    const initialX = e.clientX - leaderboardWindow.offsetLeft;
                    const initialY = e.clientY - leaderboardWindow.offsetTop;
                    
                    const onMove = (e) => {
                        if (isDragging) {
                            leaderboardWindow.style.left = (e.clientX - initialX) + 'px';
                            leaderboardWindow.style.top = (e.clientY - initialY) + 'px';
                        }
                    };
                    
                    const onUp = () => {
                        isDragging = false;
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            }
            
            leaderboardBtn.onclick = showMinesweeperLeaderboard;
            
            function updateMinesCount() {
                let flagCount = 0;
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        if (flagged[row][col]) flagCount++;
                    }
                }
                minesCountEl.textContent = NUM_MINES - flagCount;
            }
            
            restartBtn.onclick = createMinesweeperBoard;
            createMinesweeperBoard();
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'minesweeper',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Make functions globally accessible
        window.powerOffDesktop = powerOffDesktop;
        window.openSelectedIcon = openSelectedIcon;
        window.openAppStore = openAppStore;
        
        function addDesktopApp(type) {
            hideContextMenus();
            const x = Math.random() * 200 + 50;
            const y = Math.random() * 200 + 50;
            const name = type === 'paper' ? `Paper ${iconCounter + 1}` : `Paint ${iconCounter + 1}`;
            addDesktopIcon(type, name, x, y);
        }
        
        function renameDesktopIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            
            const icon = desktopIcons.find(i => i.id === selectedIcon);
            if (!icon) return;
            
            const label = icon.element.querySelector('.desktop-icon-label');
            if (label) {
                const oldName = label.textContent;
                label.contentEditable = true;
                label.focus();
                
                const range = document.createRange();
                range.selectNodeContents(label);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                
                label.addEventListener('blur', function onBlur() {
                    label.contentEditable = false;
                    const newName = label.textContent.trim() || oldName;
                    label.textContent = newName;
                    icon.name = newName;
                    label.removeEventListener('blur', onBlur);
                    saveDesktopState(); // Save after renaming
                });
                
                label.addEventListener('keydown', function onKeyDown(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        label.blur();
                    }
                    if (e.key === 'Escape') {
                        label.textContent = oldName;
                        label.blur();
                    }
                });
            }
        }
        
        function deleteDesktopIcon() {
            hideContextMenus();
            if (!selectedIcon) return;
            deleteDesktopIconById(selectedIcon);
        }
        
        function deleteDesktopIconById(iconId) {
            const icon = desktopIcons.find(i => i.id === iconId);
            if (icon) {
                icon.element.remove();
                desktopIcons = desktopIcons.filter(i => i.id !== iconId);
                selectedIcon = null;
            }
        }
        
        function openDesktopApp(type, iconId, name) {
            if (type === 'minesweeper') {
                openMinesweeperApp(iconId, name);
                return;
            }
            if (type === 'snake') {
                openSnakeApp(iconId, name);
                return;
            }
            if (type === 'blockbreaker') {
                openBlockBreakerApp(iconId, name);
                return;
            }
            if (type === 'chatbot') {
                openChatbotApp(iconId, name);
                return;
            }
            if (type === 'passwordgame') {
                openPasswordGameApp(iconId, name);
                return;
            }
            if (type === 'paintv2') {
                openPaintV2App(iconId, name);
                return;
            }
            if (type === 'gifmaker') {
                openGifMakerApp(iconId, name);
                return;
            }
            if (type === 'clicker') {
                openClickerApp(iconId, name);
                return;
            }
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const minimizeBtn = document.createElement('button');
            minimizeBtn.className = 'win95-window-button';
            minimizeBtn.textContent = '_';
            minimizeBtn.onclick = () => {
                window.classList.toggle('minimized');
                updateTaskbar();
            };
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            
            // Set up close button to save before closing
            closeBtn.onclick = () => {
                // Save paint/paper before closing
                if (type === 'paint') {
                    const canvas = content.querySelector('canvas');
                    if (canvas) {
                        try {
                            const dataURL = canvas.toDataURL('image/png');
                            localStorage.setItem(`paint-${iconId}`, dataURL);
                        } catch (e) {
                            console.error('Error saving paint on close:', e);
                        }
                    }
                } else if (type === 'paper') {
                    const paperContent = content.querySelector('.paper-app-content');
                    if (paperContent && paperContent.textContent !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, paperContent.textContent);
                        const savedColor = paperContent.style.color || '#000000';
                        const savedFont = paperContent.style.fontFamily || 'Courier New, monospace';
                        localStorage.setItem(`paper-color-${iconId}`, savedColor);
                        localStorage.setItem(`paper-font-${iconId}`, savedFont);
                    }
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(minimizeBtn);
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            if (type === 'paper') {
                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.className = 'paint-app-toolbar';
                toolbar.style.marginBottom = '0';
                
                // Color picker
                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Color: ';
                colorLabel.style.fontSize = '11px';
                colorLabel.style.marginRight = '5px';
                
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'paint-app-color-picker';
                colorPicker.value = '#000000';
                colorPicker.style.marginRight = '10px';
                
                // Font selector
                const fontLabel = document.createElement('label');
                fontLabel.textContent = 'Font: ';
                fontLabel.style.fontSize = '11px';
                fontLabel.style.marginRight = '5px';
                
                const fontSelector = document.createElement('select');
                fontSelector.style.cssText = 'background: #c0c0c0; border: 1px inset #c0c0c0; padding: 2px 4px; font-size: 11px; margin-right: 10px;';
                fontSelector.innerHTML = `
                    <option value="Arial">Arial</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Impact">Impact</option>
                    <option value="Trebuchet MS">Trebuchet MS</option>
                `;
                
                toolbar.appendChild(colorLabel);
                toolbar.appendChild(colorPicker);
                toolbar.appendChild(fontLabel);
                toolbar.appendChild(fontSelector);
                
                const paperContent = document.createElement('div');
                paperContent.className = 'paper-app-content';
                paperContent.setAttribute('contenteditable', 'true');
                paperContent.style.outline = 'none';
                paperContent.style.minHeight = 'calc(100% - 30px)';
                paperContent.style.color = '#000000'; // Default black text
                paperContent.style.fontFamily = 'Courier New, monospace';
                paperContent.textContent = 'Start typing...';
                
                // Load saved content and preferences
                const savedContent = localStorage.getItem(`paper-${iconId}`);
                const savedColor = localStorage.getItem(`paper-color-${iconId}`) || '#000000';
                const savedFont = localStorage.getItem(`paper-font-${iconId}`) || 'Courier New';
                
                if (savedContent) {
                    paperContent.textContent = savedContent;
                }
                paperContent.style.color = savedColor;
                paperContent.style.fontFamily = savedFont;
                colorPicker.value = savedColor;
                fontSelector.value = savedFont;
                
                // Update color
                colorPicker.addEventListener('input', (e) => {
                    paperContent.style.color = e.target.value;
                    localStorage.setItem(`paper-color-${iconId}`, e.target.value);
                });
                
                // Update font
                fontSelector.addEventListener('change', (e) => {
                    paperContent.style.fontFamily = e.target.value;
                    localStorage.setItem(`paper-font-${iconId}`, e.target.value);
                });
                
                paperContent.onfocus = function() {
                    if (this.textContent === 'Start typing...') {
                        this.textContent = '';
                    }
                };
                
                paperContent.onblur = function() {
                    // Save content
                    if (this.textContent.trim() !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, this.textContent);
                    }
                    if (this.textContent.trim() === '') {
                        this.textContent = 'Start typing...';
                    }
                };
                
                // Auto-save on input
                paperContent.addEventListener('input', function() {
                    if (this.textContent !== 'Start typing...') {
                        localStorage.setItem(`paper-${iconId}`, this.textContent);
                    }
                });
                
                content.appendChild(toolbar);
                content.appendChild(paperContent);
            } else if (type === 'paint') {
                const paintId = `paint-${iconId}`;
                const toolbar = document.createElement('div');
                toolbar.className = 'paint-app-toolbar';
                
                const colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.className = 'paint-app-color-picker';
                colorPicker.value = '#000000';
                
                const brushSize = document.createElement('input');
                brushSize.type = 'range';
                brushSize.className = 'paint-app-brush-size';
                brushSize.min = '1';
                brushSize.max = '50';
                brushSize.value = '5';
                
                toolbar.appendChild(colorPicker);
                toolbar.appendChild(brushSize);
                
                const canvas = document.createElement('canvas');
                canvas.className = 'paint-app-canvas';
                canvas.id = paintId;
                canvas.width = 580;
                canvas.height = 340;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Load saved drawing if exists - use setTimeout to ensure canvas is ready
                setTimeout(() => {
                    const savedDrawing = localStorage.getItem(`paint-${iconId}`);
                    if (savedDrawing && savedDrawing.startsWith('data:image')) {
                        const img = new Image();
                        img.onload = () => {
                            // Clear and redraw white background first
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            // Then draw the saved image
                            ctx.drawImage(img, 0, 0);
                        };
                        img.onerror = () => {
                            // If image fails to load, keep white background
                            console.log('Failed to load saved paint drawing for', iconId);
                        };
                        img.src = savedDrawing;
                    } else {
                        // No saved drawing, ensure white background
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }, 100);
                
                let isDrawing = false;
                let lastX = 0;
                let lastY = 0;
                
                function savePaint() {
                    try {
                        const dataURL = canvas.toDataURL('image/png');
                        localStorage.setItem(`paint-${iconId}`, dataURL);
                    } catch (e) {
                        console.error('Error saving paint:', e);
                    }
                }
                
                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    lastX = e.clientX - rect.left;
                    lastY = e.clientY - rect.top;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    ctx.strokeStyle = colorPicker.value;
                    ctx.lineWidth = brushSize.value;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    lastX = x;
                    lastY = y;
                    
                    // Auto-save while drawing (debounced to avoid too frequent saves)
                    if (!savePaint.timeout) {
                        savePaint.timeout = setTimeout(() => {
                            savePaint();
                            savePaint.timeout = null;
                        }, 200); // Save every 200ms while drawing
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDrawing = false;
                    // Clear any pending save and save immediately
                    if (savePaint.timeout) {
                        clearTimeout(savePaint.timeout);
                        savePaint.timeout = null;
                    }
                    savePaint();
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDrawing = false;
                    // Clear any pending save and save immediately
                    if (savePaint.timeout) {
                        clearTimeout(savePaint.timeout);
                        savePaint.timeout = null;
                    }
                    savePaint();
                });
                
                // Make sure canvas is properly sized and visible
                canvas.style.display = 'block';
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                
                content.appendChild(toolbar);
                content.appendChild(canvas);
            }
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                initialX = e.clientX - window.offsetLeft;
                initialY = e.clientY - window.offsetTop;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    window.style.left = currentX + 'px';
                    window.style.top = currentY + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: type,
                element: window
            });
            
            updateTaskbar();
        }
        
        // Sandboxles app
        function openSandboxlesApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '700px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const minimizeBtn = document.createElement('button');
            minimizeBtn.className = 'win95-window-button';
            minimizeBtn.textContent = '_';
            minimizeBtn.onclick = () => {
                window.classList.toggle('minimized');
                updateTaskbar();
            };
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(minimizeBtn);
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content - sandbox playground
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            content.style.height = '100%';
            content.style.background = '#f0f0f0';
            
            // Create a simple interactive sandbox
            const sandboxDiv = document.createElement('div');
            sandboxDiv.style.cssText = 'width: 100%; height: 100%; min-height: 400px; background: #fff; border: 1px inset #c0c0c0; position: relative; overflow: hidden;';
            sandboxDiv.id = `sandbox-${iconId}`;
            
            // Add some interactive elements
            const info = document.createElement('div');
            info.style.cssText = 'padding: 10px; background: #e0e0e0; border-bottom: 1px inset #c0c0c0; font-size: 11px; margin-bottom: 5px;';
            info.innerHTML = '<strong>Sandbox Playground</strong><br>Click to create elements, drag to move them around! Double-click to remove.';
            
            // Make sandbox interactive - clicking creates colored boxes
            let elementCounter = 0;
            sandboxDiv.addEventListener('click', (e) => {
                if (e.target === sandboxDiv) {
                    const box = document.createElement('div');
                    box.style.cssText = `
                        position: absolute;
                        left: ${e.offsetX - 25}px;
                        top: ${e.offsetY - 25}px;
                        width: 50px;
                        height: 50px;
                        background: hsl(${Math.random() * 360}, 70%, 60%);
                        border: 2px outset #c0c0c0;
                        cursor: move;
                        user-select: none;
                    `;
                    box.textContent = ++elementCounter;
                    box.style.display = 'flex';
                    box.style.alignItems = 'center';
                    box.style.justifyContent = 'center';
                    box.style.fontSize = '20px';
                    box.style.fontWeight = 'bold';
                    box.style.color = '#000';
                    
                    // Make draggable
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    
                    box.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        const rect = box.getBoundingClientRect();
                        initialX = rect.left;
                        initialY = rect.top;
                        box.style.zIndex = '1000';
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        box.style.left = (initialX + dx) + 'px';
                        box.style.top = (initialY + dy) + 'px';
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            box.style.zIndex = '1';
                        }
                    });
                    
                    // Double-click to remove
                    box.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        box.remove();
                    });
                    
                    sandboxDiv.appendChild(box);
                }
            });
            
            content.appendChild(info);
            content.appendChild(sandboxDiv);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'sandboxles',
                element: window
            });
            
            updateTaskbar();
        }
        
        function updateTaskbar() {
            const taskbarApps = document.getElementById('taskbarApps');
            if (!taskbarApps) return;
            
            taskbarApps.innerHTML = '';
            desktopWindows.forEach((win, index) => {
                if (!win.element.classList.contains('minimized')) {
                    const btn = document.createElement('div');
                    btn.style.cssText = 'background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; margin: 2px; cursor: pointer; font-size: 11px; font-weight: bold; user-select: none;';
                    btn.textContent = win.name;
                    btn.onclick = () => {
                        win.element.style.zIndex = ++windowZIndex;
                        win.element.classList.remove('minimized');
                        updateTaskbar();
                    };
                    taskbarApps.appendChild(btn);
                }
            });
        }
        
        // Pong app
        function openPongApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content - embed pong iframe
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '0';
            content.style.overflow = 'hidden';
            content.style.height = '100%';
            
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.src = 'https://sethclydesdale.github.io/browser-pong/';
            
            content.appendChild(iframe);
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'pong',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Snake app
        function openSnakeApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'auto';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            
            // Game HTML
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="snake-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 10px;">Score: <span id="snake-score">0</span></div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 10px;">Use arrow keys to move</div>
                </div>
                <canvas id="snake-canvas" width="256" height="256" style="border: 2px inset #c0c0c0; background: #ffffff; display: block;"></canvas>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#snake-canvas');
            const ctx = canvas.getContext('2d');
            const restartBtn = content.querySelector('#snake-restart');
            const scoreEl = content.querySelector('#snake-score');
            
            // Game constants
            const GRID_SIZE = 16;
            const CELL_SIZE = 16;
            const NUM_APPLES = 3;
            
            // Game state
            let snake = [{x: 8, y: 8}];
            let direction = {x: 1, y: 0};
            let apples = [];
            let score = 0;
            let snakeGameInterval = null;
            let gameRunning = false;
            
            // Generate apples
            function generateApples() {
                apples = [];
                while (apples.length < NUM_APPLES) {
                    const x = Math.floor(Math.random() * GRID_SIZE);
                    const y = Math.floor(Math.random() * GRID_SIZE);
                    // Make sure apple doesn't spawn on snake
                    const onSnake = snake.some(segment => segment.x === x && segment.y === y);
                    const onExistingApple = apples.some(apple => apple.x === x && apple.y === y);
                    if (!onSnake && !onExistingApple) {
                        apples.push({x, y});
                    }
                }
            }
            
            // Draw game
            function draw() {
                // Clear canvas
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid lines
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE, 0);
                    ctx.lineTo(i * CELL_SIZE, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL_SIZE);
                    ctx.lineTo(canvas.width, i * CELL_SIZE);
                    ctx.stroke();
                }
                
                // Draw snake (black)
                ctx.fillStyle = '#000000';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * CELL_SIZE + 1, segment.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                });
                
                // Draw apples (red)
                ctx.fillStyle = '#ff0000';
                apples.forEach(apple => {
                    ctx.fillRect(apple.x * CELL_SIZE + 1, apple.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                });
            }
            
            // Game loop
            function gameLoop() {
                if (!gameRunning) return;
                
                // Move snake
                const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
                
                // Check wall collision
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    gameOver();
                    return;
                }
                
                // Check self collision
                if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameOver();
                    return;
                }
                
                snake.unshift(head);
                
                // Check apple collision
                let ateApple = false;
                for (let i = apples.length - 1; i >= 0; i--) {
                    if (head.x === apples[i].x && head.y === apples[i].y) {
                        apples.splice(i, 1);
                        score++;
                        scoreEl.textContent = score;
                        ateApple = true;
                    }
                }
                
                // If didn't eat apple, remove tail
                if (!ateApple) {
                    snake.pop();
                }
                
                // Regenerate apples if needed
                if (apples.length < NUM_APPLES) {
                    generateApples();
                }
                
                draw();
            }
            
            function startGame() {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                }
                
                // Reset game state
                snake = [{x: 8, y: 8}];
                direction = {x: 1, y: 0};
                score = 0;
                scoreEl.textContent = score;
                gameRunning = true;
                
                generateApples();
                draw();
                
                // Start game loop (update every 150ms)
                snakeGameInterval = setInterval(gameLoop, 150);
            }
            
            function gameOver() {
                gameRunning = false;
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                alert('Game Over! Score: ' + score);
                startGame();
            }
            
            // Keyboard controls
            const handleKeyPress = (e) => {
                if (!gameRunning) return;
                
                // Check if this window still exists and is visible
                if (!window.parentNode || !canvas.offsetParent) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (direction.y === 0) {
                            direction = {x: 0, y: -1};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowDown':
                        if (direction.y === 0) {
                            direction = {x: 0, y: 1};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowLeft':
                        if (direction.x === 0) {
                            direction = {x: -1, y: 0};
                            e.preventDefault();
                        }
                        break;
                    case 'ArrowRight':
                        if (direction.x === 0) {
                            direction = {x: 1, y: 0};
                            e.preventDefault();
                        }
                        break;
                }
            };
            
            // Add keyboard listener
            document.addEventListener('keydown', handleKeyPress);
            closeBtn.onclick = () => {
                document.removeEventListener('keydown', handleKeyPress);
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                    snakeGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            restartBtn.onclick = () => {
                if (snakeGameInterval) {
                    clearInterval(snakeGameInterval);
                }
                startGame();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'snake',
                element: window
            });
            
            updateTaskbar();
            
            // Start the game
            startGame();
        }
        
        // Block Breaker app
        function openBlockBreakerApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '450px';
            window.style.height = '550px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.overflow = 'hidden';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.alignItems = 'center';
            
            // Game HTML
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="blockbreaker-restart" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div style="font-size: 12px; margin-bottom: 5px;">Score: <span id="blockbreaker-score">0</span></div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 5px;">Lives: <span id="blockbreaker-lives">3</span></div>
                    <div style="font-size: 10px; color: #666;">Use mouse or arrow keys to move paddle</div>
                </div>
                <canvas id="blockbreaker-canvas" width="400" height="450" style="border: 2px inset #c0c0c0; background: #000; display: block;"></canvas>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#blockbreaker-canvas');
            const ctx = canvas.getContext('2d');
            const restartBtn = content.querySelector('#blockbreaker-restart');
            const scoreEl = content.querySelector('#blockbreaker-score');
            const livesEl = content.querySelector('#blockbreaker-lives');
            
            // Game constants
            const PADDLE_WIDTH = 80;
            const PADDLE_HEIGHT = 10;
            const BALL_RADIUS = 12;
            const BLOCK_ROWS = 5;
            const BLOCK_COLS = 8;
            const BLOCK_WIDTH = 45;
            const BLOCK_HEIGHT = 20;
            const BLOCK_PADDING = 5;
            const BLOCK_OFFSET_TOP = 30;
            const BLOCK_OFFSET_LEFT = 15;
            
            // Game state
            let paddleX = (canvas.width - PADDLE_WIDTH) / 2;
            let ballX = canvas.width / 2;
            let ballY = canvas.height - 50;
            let ballSpeedX = 2;
            let ballSpeedY = -2;
            let score = 0;
            let lives = 3;
            let blocks = [];
            let blockBreakerGameInterval = null;
            let gameRunning = false;
            
            // Create blocks
            function createBlocks() {
                blocks = [];
                const colors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff'];
                for (let row = 0; row < BLOCK_ROWS; row++) {
                    for (let col = 0; col < BLOCK_COLS; col++) {
                        blocks.push({
                            x: BLOCK_OFFSET_LEFT + col * (BLOCK_WIDTH + BLOCK_PADDING),
                            y: BLOCK_OFFSET_TOP + row * (BLOCK_HEIGHT + BLOCK_PADDING),
                            color: colors[row],
                            visible: true
                        });
                    }
                }
            }
            
            // Draw game
            function draw() {
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw blocks
                blocks.forEach(block => {
                    if (block.visible) {
                        ctx.fillStyle = block.color;
                        ctx.fillRect(block.x, block.y, BLOCK_WIDTH, BLOCK_HEIGHT);
                        ctx.strokeStyle = '#fff';
                        ctx.strokeRect(block.x, block.y, BLOCK_WIDTH, BLOCK_HEIGHT);
                    }
                });
                
                // Draw ball first (bigger and brighter) so it's always visible
                ctx.beginPath();
                ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
                
                // Draw paddle (more visible, higher up) - ensure it's always visible at bottom
                const paddleY = canvas.height - 35;
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(paddleX, paddleY, PADDLE_WIDTH, PADDLE_HEIGHT);
                // Add bright border to make it more visible
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(paddleX, paddleY, PADDLE_WIDTH, PADDLE_HEIGHT);
                // Add inner highlight
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(paddleX + 2, paddleY + 2, PADDLE_WIDTH - 4, PADDLE_HEIGHT - 4);
            }
            
            // Update game
            function update() {
                if (!gameRunning) return;
                
                // Move ball
                ballX += ballSpeedX;
                ballY += ballSpeedY;
                
                // Ball collision with walls
                if (ballX + BALL_RADIUS > canvas.width || ballX - BALL_RADIUS < 0) {
                    ballSpeedX = -ballSpeedX;
                }
                if (ballY - BALL_RADIUS < 0) {
                    ballSpeedY = -ballSpeedY;
                }
                
                // Ball collision with paddle (updated position)
                const paddleY = canvas.height - 35;
                if (ballY + BALL_RADIUS > paddleY && 
                    ballY + BALL_RADIUS < paddleY + PADDLE_HEIGHT &&
                    ballX > paddleX && 
                    ballX < paddleX + PADDLE_WIDTH) {
                    ballSpeedY = -Math.abs(ballSpeedY);
                    // Add spin based on where ball hits paddle
                    const hitPos = (ballX - paddleX) / PADDLE_WIDTH;
                    ballSpeedX = (hitPos - 0.5) * 4;
                }
                
                // Ball collision with blocks
                blocks.forEach(block => {
                    if (block.visible) {
                        if (ballX + BALL_RADIUS > block.x &&
                            ballX - BALL_RADIUS < block.x + BLOCK_WIDTH &&
                            ballY + BALL_RADIUS > block.y &&
                            ballY - BALL_RADIUS < block.y + BLOCK_HEIGHT) {
                            block.visible = false;
                            ballSpeedY = -ballSpeedY;
                            score += 10;
                            scoreEl.textContent = score;
                        }
                    }
                });
                
                // Check if ball fell off bottom
                if (ballY > canvas.height) {
                    lives--;
                    livesEl.textContent = lives;
                    if (lives <= 0) {
                        gameOver();
                        return;
                    }
                    resetBall();
                }
                
                // Check win condition
                const blocksLeft = blocks.filter(b => b.visible).length;
                if (blocksLeft === 0) {
                    gameRunning = false;
                    if (blockBreakerGameInterval) {
                        cancelAnimationFrame(blockBreakerGameInterval);
                    }
                    alert('You Win! Score: ' + score);
                    startGame();
                }
            }
            
            // Game loop
            function gameLoop() {
                update();
                draw();
                if (gameRunning) {
                    blockBreakerGameInterval = requestAnimationFrame(gameLoop);
                }
            }
            
            function resetBall() {
                ballX = canvas.width / 2;
                ballY = canvas.height - 50;
                ballSpeedX = 2 * (Math.random() > 0.5 ? 1 : -1);
                ballSpeedY = -2;
            }
            
            function startGame() {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                }
                
                gameRunning = true;
                score = 0;
                lives = 3;
                scoreEl.textContent = score;
                livesEl.textContent = lives;
                paddleX = (canvas.width - PADDLE_WIDTH) / 2;
                createBlocks();
                resetBall();
                draw();
                gameLoop();
            }
            
            function gameOver() {
                gameRunning = false;
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                alert('Game Over! Final Score: ' + score);
                startGame();
            }
            
            // Mouse controls
            const handleMouseMove = (e) => {
                if (!gameRunning || !window.parentNode) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, mouseX - PADDLE_WIDTH / 2));
            };
            
            // Keyboard controls
            const handleKeyPress = (e) => {
                if (!gameRunning || !window.parentNode) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        paddleX = Math.max(0, paddleX - 10);
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        paddleX = Math.min(canvas.width - PADDLE_WIDTH, paddleX + 10);
                        e.preventDefault();
                        break;
                }
            };
            
            // Add event listeners
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('keydown', handleKeyPress);
            
            closeBtn.onclick = () => {
                canvas.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('keydown', handleKeyPress);
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                    blockBreakerGameInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            restartBtn.onclick = () => {
                if (blockBreakerGameInterval) {
                    cancelAnimationFrame(blockBreakerGameInterval);
                }
                startGame();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'blockbreaker',
                element: window
            });
            
            updateTaskbar();
            
            // Start the game
            startGame();
        }
        
        // Chatbot AI response generator
        function generateBotResponse(message) {
            const msg = message.toLowerCase().trim();
            
            // Greetings
            if (msg.match(/^(hi|hello|hey|greetings|sup|what's up|howdy)/)) {
                const greetings = ['Hello! How can I help you?', 'Hi there! What can I do for you?', 'Hey! Nice to meet you!', 'Hello! How are you doing?'];
                return greetings[Math.floor(Math.random() * greetings.length)];
            }
            
            // How are you
            if (msg.match(/how are you|how's it going|how do you feel/)) {
                const responses = ['I\'m doing great, thanks for asking!', 'I\'m doing well! How about you?', 'I\'m good! Thanks!', 'Pretty good! What about you?'];
                return responses[Math.floor(Math.random() * responses.length)];
            }
            
            // What is / what are questions
            if (msg.match(/^what (is|are) (.+)\?*$/)) {
                const match = msg.match(/^what (is|are) (.+)\?*$/);
                const thing = match[2];
                if (thing.includes('your name') || thing.includes('you called')) {
                    return 'I\'m just a chatbot! You can call me Chatbot.';
                }
                if (thing.includes('time')) {
                    return `The current time is ${new Date().toLocaleTimeString()}.`;
                }
                if (thing.includes('date')) {
                    return `Today is ${new Date().toLocaleDateString()}.`;
                }
                if (thing.includes('weather')) {
                    return 'I don\'t have access to weather data, but I hope it\'s nice where you are!';
                }
                return `I\'m not entirely sure what "${thing}" is. Could you tell me more about it?`;
            }
            
            // Who questions
            if (msg.match(/^who (is|are) (.+)\?*$/)) {
                const match = msg.match(/^who (is|are) (.+)\?*$/);
                const person = match[2];
                if (person.includes('you') || person.includes('chatbot')) {
                    return 'I\'m a helpful chatbot! I try to answer questions and have conversations.';
                }
                return `I don\'t know much about "${person}". Could you tell me more?`;
            }
            
            // Why questions
            if (msg.match(/^why (.+)\?*$/)) {
                const match = msg.match(/^why (.+)\?*$/);
                const thing = match[1];
                if (thing.includes('sky') && thing.includes('blue')) {
                    return 'The sky appears blue because of how light scatters in the atmosphere!';
                }
                return `That\'s an interesting question about "${thing}". I\'m not entirely sure, but I\'d love to learn more!`;
            }
            
            // How questions
            if (msg.match(/^how (.+)\?*$/)) {
                const match = msg.match(/^how (.+)\?*$/);
                const thing = match[1];
                if (thing.includes('work') || thing.includes('do')) {
                    return 'I work by analyzing your messages and trying to provide helpful responses!';
                }
                if (thing.includes('old')) {
                    return 'I was just created, so I\'m very new!';
                }
                return `I\'m not sure how "${thing}" works exactly. Could you explain it to me?`;
            }
            
            // Yes/No questions
            if (msg.match(/\?$/) && (msg.includes('can you') || msg.includes('do you') || msg.includes('are you') || msg.includes('will you'))) {
                if (msg.includes('help')) {
                    return 'Yes, I\'d be happy to help! What do you need?';
                }
                if (msg.includes('understand')) {
                    return 'I try my best to understand! Sometimes I might not get everything, but I do my best.';
                }
                if (msg.includes('smart') || msg.includes('intelligent')) {
                    return 'I try to be helpful! I\'m still learning, but I do my best.';
                }
                const yesNo = Math.random() > 0.5;
                return yesNo ? 'Yes, I think so!' : 'Hmm, I\'m not entirely sure about that.';
            }
            
            // Commands/requests
            if (msg.match(/^(tell me|explain|describe|give me)/)) {
                const match = msg.match(/^(tell me|explain|describe|give me) (.+)/);
                if (match) {
                    const thing = match[2];
                    if (thing.includes('joke')) {
                        const jokes = [
                            'Why don\'t scientists trust atoms? Because they make up everything!',
                            'Why did the scarecrow win an award? He was outstanding in his field!',
                            'What do you call a fake noodle? An impasta!',
                            'Why don\'t eggs tell jokes? They\'d crack each other up!',
                            'Why did the math book look so sad? Because it had too many problems!',
                            'What do you call a bear with no teeth? A gummy bear!',
                            'Why don\'t programmers like nature? It has too many bugs!',
                            'What\'s a computer\'s favorite snack? Microchips!',
                            'Why did the coffee file a police report? It got mugged!',
                            'What do you call a sleeping bull? A bulldozer!',
                            'Why don\'t scientists trust stairs? Because they\'re always up to something!',
                            'What did one ocean say to the other? Nothing, they just waved!',
                            'Why did the bicycle fall over? Because it was two tired!',
                            'What\'s a ninja\'s favorite type of shoes? Sneakers!',
                            'Why do programmers prefer dark mode? Because light attracts bugs!',
                            'What do you call a can opener that doesn\'t work? A can\'t opener!',
                            'Why don\'t skeletons fight each other? They don\'t have the guts!',
                            'What do you call a factory that makes okay products? A satisfactory!',
                            'Why did the golfer bring two pairs of pants? In case he got a hole in one!',
                            'What\'s the best thing about Switzerland? I don\'t know, but the flag is a big plus!'
                        ];
                        return jokes[Math.floor(Math.random() * jokes.length)];
                    }
                    if (thing.includes('fact')) {
                        const facts = [
                            'Octopuses have three hearts!',
                            'A group of flamingos is called a flamboyance!',
                            'Honey never spoils - archaeologists have found 3000-year-old honey that\'s still edible!',
                            'Bananas are berries, but strawberries aren\'t!',
                            'A day on Venus is longer than its year! Venus rotates so slowly that it takes longer to rotate once than to orbit the sun.',
                            'Sharks have been around longer than trees! Sharks have existed for about 400 million years, while trees have only been around for 350 million years.',
                            'Wombat poop is cube-shaped! This helps prevent it from rolling away and marks territory better.',
                            'Dolphins have names for each other! They use unique whistles to identify themselves.',
                            'There are more possible games of chess than atoms in the observable universe!',
                            'A single cloud can weigh more than a million pounds!',
                            'You have about 37 trillion cells in your body!',
                            'Lightning strikes the Earth about 100 times per second!',
                            'The human brain can process images in as little as 13 milliseconds!',
                            'A group of owls is called a parliament!',
                            'Polar bears have black skin under their white fur!',
                            'Cows have best friends and get stressed when separated!',
                            'Bananas are naturally radioactive due to their potassium content!',
                            'A single strand of spaghetti is called a "spaghetto"!',
                            'Butterflies taste with their feet!',
                            'There\'s a species of jellyfish that is biologically immortal!',
                            'The longest word in English has 189,819 letters! It\'s the chemical name for titin protein.',
                            'A "jiffy" is an actual unit of time - 1/100th of a second!',
                            'Humans share 50% of their DNA with bananas!'
                        ];
                        return facts[Math.floor(Math.random() * facts.length)];
                    }
                    return `I\'d love to tell you about "${thing}", but I might not know everything about it. What specifically would you like to know?`;
                }
            }
            
            // Thank you
            if (msg.match(/^(thanks|thank you|ty|thx)/)) {
                const responses = ['You\'re welcome!', 'Happy to help!', 'No problem!', 'Anytime!'];
                return responses[Math.floor(Math.random() * responses.length)];
            }
            
            // Goodbye
            if (msg.match(/^(bye|goodbye|see you|later|cya|farewell)/)) {
                const responses = ['Goodbye! Have a great day!', 'See you later!', 'Bye! Take care!', 'Farewell!'];
                return responses[Math.floor(Math.random() * responses.length)];
            }
            
            // Compliments
            if (msg.match(/(you're|you are) (cool|awesome|great|amazing|smart|nice|good)/)) {
                return 'Aww, thank you! That\'s very kind of you to say!';
            }
            
            // Questions about the chatbot itself
            if (msg.includes('what can you do') || msg.includes('what do you do')) {
                return 'I can chat with you, answer questions, tell jokes, share facts, define words, and try to be helpful! What would you like to know?';
            }
            
            // Definitions - "what does X mean" or "define X"
            if (msg.match(/(what does|what is|define|definition of|meaning of)\s+(.+)/) || msg.match(/^define\s+(.+)$/)) {
                const defMatch = msg.match(/(what does|what is|define|definition of|meaning of)\s+(.+)/) || msg.match(/^define\s+(.+)$/);
                if (defMatch) {
                    const word = defMatch[2].trim().toLowerCase().replace(/\?/g, '');
                    
                    // Dictionary of common word definitions
                    const definitions = {
                        'computer': 'An electronic device that processes data according to instructions stored in its memory.',
                        'internet': 'A global network of interconnected computers that communicate using standardized protocols.',
                        'website': 'A collection of web pages accessible via the internet, identified by a domain name.',
                        'chatbot': 'A computer program designed to simulate conversation with human users, especially over the internet.',
                        'code': 'Instructions written in a programming language that tell a computer what to do.',
                        'programming': 'The process of creating instructions for computers to execute, usually written in code.',
                        'software': 'Programs and data that tell a computer what to do and how to do it.',
                        'hardware': 'The physical components of a computer system, such as the processor, memory, and storage.',
                        'algorithm': 'A step-by-step procedure or set of rules for solving a problem or completing a task.',
                        'data': 'Information, especially facts or numbers, collected for reference or analysis.',
                        'browser': 'A software application used to access and view websites on the internet.',
                        'email': 'Electronic mail - messages sent and received through the internet.',
                        'password': 'A secret word or phrase used to gain access to a computer, website, or application.',
                        'virus': 'Malicious software designed to damage or gain unauthorized access to computer systems.',
                        'firewall': 'A security system that monitors and controls incoming and outgoing network traffic.',
                        'cookie': 'A small piece of data stored on your computer by websites to remember your preferences.',
                        'cloud': 'Remote servers accessed over the internet for storing, managing, and processing data.',
                        'ai': 'Artificial Intelligence - the simulation of human intelligence in machines.',
                        'javascript': 'A programming language commonly used to create interactive effects within web browsers.',
                        'html': 'HyperText Markup Language - the standard language for creating web pages.',
                        'css': 'Cascading Style Sheets - used to style and format web pages.',
                        'api': 'Application Programming Interface - a set of rules allowing different software to communicate.',
                        'database': 'An organized collection of data stored and accessed electronically.',
                        'server': 'A computer or system that provides resources, data, or services to other computers over a network.',
                        'client': 'A computer or program that accesses services provided by a server.',
                        'protocol': 'A set of rules governing the exchange of data between devices.',
                        'encryption': 'The process of converting data into a coded form to prevent unauthorized access.',
                        'debugging': 'The process of finding and fixing errors or bugs in computer code.',
                        'function': 'A block of code designed to perform a specific task, which can be reused.',
                        'variable': 'A container that stores data values in programming.',
                        'array': 'A data structure that stores multiple values in a single variable.',
                        'loop': 'A programming construct that repeats a block of code until a condition is met.',
                        'boolean': 'A data type that can only be true or false.',
                        'string': 'A sequence of characters, such as text, in programming.',
                        'integer': 'A whole number without decimal points.',
                        'float': 'A number with decimal points in programming.',
                        'object': 'A data structure containing properties and methods in programming.',
                        'class': 'A blueprint for creating objects in object-oriented programming.',
                        'method': 'A function associated with an object in programming.',
                        'property': 'An attribute or characteristic of an object in programming.'
                    };
                    
                    if (definitions[word]) {
                        return `${word.charAt(0).toUpperCase() + word.slice(1)}: ${definitions[word]}`;
                    } else {
                        return `I don't have a definition for "${word}" in my dictionary. Could you try another word or ask me about something else?`;
                    }
                }
            }
            
            // Direct joke requests (even without "tell me")
            if (msg.includes('joke')) {
                const jokes = [
                    'Why don\'t scientists trust atoms? Because they make up everything!',
                    'Why did the scarecrow win an award? He was outstanding in his field!',
                    'What do you call a fake noodle? An impasta!',
                    'Why don\'t eggs tell jokes? They\'d crack each other up!',
                    'Why did the math book look so sad? Because it had too many problems!',
                    'What do you call a bear with no teeth? A gummy bear!',
                    'Why don\'t programmers like nature? It has too many bugs!',
                    'What\'s a computer\'s favorite snack? Microchips!',
                    'Why did the coffee file a police report? It got mugged!',
                    'What do you call a sleeping bull? A bulldozer!',
                    'Why don\'t scientists trust stairs? Because they\'re always up to something!',
                    'What did one ocean say to the other? Nothing, they just waved!',
                    'Why did the bicycle fall over? Because it was two tired!',
                    'What\'s a ninja\'s favorite type of shoes? Sneakers!',
                    'Why do programmers prefer dark mode? Because light attracts bugs!'
                ];
                return jokes[Math.floor(Math.random() * jokes.length)];
            }
            
            // Direct fact requests (even without "tell me")
            if (msg.includes('fact') || msg.includes('fun fact')) {
                const facts = [
                    'Octopuses have three hearts!',
                    'A group of flamingos is called a flamboyance!',
                    'Honey never spoils - archaeologists have found 3000-year-old honey that\'s still edible!',
                    'Bananas are berries, but strawberries aren\'t!',
                    'A day on Venus is longer than its year! Venus rotates so slowly that it takes longer to rotate once than to orbit the sun.',
                    'Sharks have been around longer than trees! Sharks have existed for about 400 million years, while trees have only been around for 350 million years.',
                    'Wombat poop is cube-shaped! This helps prevent it from rolling away and marks territory better.',
                    'Dolphins have names for each other! They use unique whistles to identify themselves.',
                    'There are more possible games of chess than atoms in the observable universe!',
                    'A single cloud can weigh more than a million pounds!',
                    'You have about 37 trillion cells in your body!',
                    'Lightning strikes the Earth about 100 times per second!',
                    'The human brain can process images in as little as 13 milliseconds!',
                    'A group of owls is called a parliament!',
                    'Polar bears have black skin under their white fur!',
                    'Cows have best friends and get stressed when separated!',
                    'Butterflies taste with their feet!',
                    'Humans share 50% of their DNA with bananas!'
                ];
                return facts[Math.floor(Math.random() * facts.length)];
            }
            
            // Math (simple)
            const mathMatch = msg.match(/(\d+)\s*([+\-*/])\s*(\d+)/);
            if (mathMatch) {
                const num1 = parseInt(mathMatch[1]);
                const op = mathMatch[2];
                const num2 = parseInt(mathMatch[3]);
                let result;
                if (op === '+') result = num1 + num2;
                else if (op === '-') result = num1 - num2;
                else if (op === '*') result = num1 * num2;
                else if (op === '/') result = num2 !== 0 ? num1 / num2 : 'undefined (division by zero)';
                return `That equals ${result}!`;
            }
            
            // Default responses for unknown queries
            const defaultResponses = [
                'That\'s interesting! Tell me more.',
                'I see. Can you elaborate on that?',
                'Hmm, I\'m not entirely sure about that. Could you rephrase?',
                'That\'s a good point! What else would you like to talk about?',
                'I understand. Is there anything specific you\'d like to know?',
                'Interesting! I\'d love to learn more about that.',
                'That\'s something to think about! What do you think?',
                'I\'m not completely sure, but I\'m here to help if you have other questions!'
            ];
            
            // If message is very short, use shorter responses
            if (msg.length < 10) {
                const shortResponses = ['Okay!', 'Got it!', 'I see!', 'Sure!', 'Alright!'];
                return shortResponses[Math.floor(Math.random() * shortResponses.length)];
            }
            
            return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
        }
        
        // Chatbot app
        function openChatbotApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '450px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.height = 'calc(100% - 20px)';
            content.style.overflow = 'hidden';
            
            // Chat messages area
            const messagesArea = document.createElement('div');
            messagesArea.id = `chatbot-messages-${iconId}`;
            messagesArea.style.cssText = 'flex: 1; overflow-y: auto; border: 1px inset #c0c0c0; padding: 10px; margin-bottom: 10px; background: #fff; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';
            
            // Welcome message
            const welcomeMsg = document.createElement('div');
            welcomeMsg.style.cssText = 'margin-bottom: 10px; color: #666; font-style: italic;';
            welcomeMsg.textContent = 'Chatbot: Hello! How can I help you today?';
            messagesArea.appendChild(welcomeMsg);
            
            // Input area
            const inputContainer = document.createElement('div');
            inputContainer.style.cssText = 'display: flex; gap: 5px;';
            
            const inputField = document.createElement('input');
            inputField.type = 'text';
            inputField.id = `chatbot-input-${iconId}`;
            inputField.style.cssText = 'flex: 1; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';
            inputField.placeholder = 'Type your message...';
            
            const sendBtn = document.createElement('button');
            sendBtn.textContent = 'Send';
            sendBtn.style.cssText = 'padding: 5px 15px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 11px; font-weight: bold; cursor: pointer; font-family: "MS Sans Serif", Arial, sans-serif;';
            
            // Send function
            const sendMessage = () => {
                const message = inputField.value.trim();
                if (!message) return;
                
                // Add user message
                const userMsg = document.createElement('div');
                userMsg.style.cssText = 'margin-bottom: 10px; text-align: right; color: #000;';
                userMsg.textContent = `You: ${message}`;
                messagesArea.appendChild(userMsg);
                
                // Clear input
                inputField.value = '';
                
                // Scroll to bottom
                messagesArea.scrollTop = messagesArea.scrollHeight;
                
                // Generate AI response
                const botResponse = generateBotResponse(message);
                
                // Add bot response after a short delay
                setTimeout(() => {
                    const botMsg = document.createElement('div');
                    botMsg.style.cssText = 'margin-bottom: 10px; color: #000;';
                    botMsg.textContent = `Chatbot: ${botResponse}`;
                    messagesArea.appendChild(botMsg);
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }, 300);
            };
            
            sendBtn.onclick = sendMessage;
            inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            inputContainer.appendChild(inputField);
            inputContainer.appendChild(sendBtn);
            
            content.appendChild(messagesArea);
            content.appendChild(inputContainer);
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'chatbot',
                element: window
            });
            
            updateTaskbar();
            
            // Focus input field
            setTimeout(() => inputField.focus(), 100);
        }
        
        // Password Game app
        function openPasswordGameApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                // Clean up lobby when closing window
                if (currentLobbyId && database) {
                    const userId = getUserId();
                    database.ref(`passwordGameLobbies/${currentLobbyId}`).once('value', (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            let players = Array.isArray(data.players) ? data.players : Object.keys(data.players || {});
                            players = players.filter(p => p !== userId);
                            
                            // If no players left, reset lobby but keep it (for fixed lobby system)
                            if (players.length === 0) {
                                database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                    host: null,
                                    hostName: null,
                                    players: [],
                                    password: '',
                                    gameStarted: false
                                });
                            } else {
                                // Remove player from lobby
                                database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                    players: players
                                });
                                
                                // If player was host, assign new host
                                if (data.host === userId && players.length > 0) {
                                    database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                        host: players[0],
                                        hostName: players[0]
                                    });
                                }
                            }
                            
                            // Remove listener
                            if (lobbyListener) {
                                database.ref(`passwordGameLobbies/${currentLobbyId}`).off('value', lobbyListener);
                            }
                        }
                    });
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.height = 'calc(100% - 20px)';
            content.style.overflow = 'hidden';
            
            // Word list for password game
            const words = ['APPLE', 'BRAVE', 'CLOUD', 'DREAM', 'EARTH', 'FLAME', 'GLASS', 'HEART', 'IMAGE', 'JOKER', 'KNIFE', 'LIGHT', 'MAGIC', 'NIGHT', 'OCEAN', 'PIANO', 'QUICK', 'RIVER', 'STORM', 'TIGER', 'UNITY', 'VOICE', 'WATER', 'YOUTH', 'ZEBRA'];
            
            let currentPassword = '';
            let attempts = 0;
            const maxAttempts = 6;
            let gameWon = false;
            
            // Game HTML
            const gameHTML = `
                <div style="text-align: center; margin-bottom: 10px;">
                    <button id="passwordgame-multiplayer" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">Multiplayer Mode</button>
                    <button id="passwordgame-new" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">New Game</button>
                    <div id="passwordgame-lobby-info" style="display: none; border: 1px inset #c0c0c0; background: #f0f0f0; padding: 8px; margin: 5px 0; font-size: 11px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">Lobby: <span id="passwordgame-lobby-id">-</span></div>
                        <div id="passwordgame-lobby-status" style="margin-bottom: 5px;">Status: Waiting for players...</div>
                        <div id="passwordgame-lobby-players" style="font-size: 10px; color: #666;">Players: Loading...</div>
                        <button id="passwordgame-start-game" style="display: none; background: #238636; color: white; border: 2px outset #238636; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-top: 5px;">Start Game</button>
                    </div>
                    <div style="font-size: 12px; margin-bottom: 5px;">Attempts: <span id="passwordgame-attempts">0</span>/${maxAttempts}</div>
                    <div id="passwordgame-mode" style="font-size: 11px; color: #666; margin-bottom: 10px;">Guess the 5-letter password!</div>
                </div>
                <div id="passwordgame-guesses" style="flex: 1; overflow-y: auto; border: 1px inset #c0c0c0; padding: 10px; margin-bottom: 10px; background: #fff; font-size: 11px; font-family: monospace; min-height: 200px;">
                    <!-- Guesses will appear here -->
                </div>
                <div id="passwordgame-input-section" style="display: flex; gap: 5px;">
                    <input type="text" id="passwordgame-input" maxlength="5" style="flex: 1; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px; font-family: monospace; text-transform: uppercase;" placeholder="Enter 5 letters...">
                    <button id="passwordgame-submit" style="padding: 5px 15px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 11px; font-weight: bold; cursor: pointer;">Guess</button>
                </div>
                <div id="passwordgame-result" style="margin-top: 10px; font-size: 11px; font-weight: bold; min-height: 20px; text-align: center;"></div>
            `;
            content.innerHTML = gameHTML;
            
            const guessesArea = content.querySelector('#passwordgame-guesses');
            const inputField = content.querySelector('#passwordgame-input');
            const submitBtn = content.querySelector('#passwordgame-submit');
            const newGameBtn = content.querySelector('#passwordgame-new');
            const attemptsEl = content.querySelector('#passwordgame-attempts');
            const resultEl = content.querySelector('#passwordgame-result');
            const modeEl = content.querySelector('#passwordgame-mode');
            const multiplayerBtn = content.querySelector('#passwordgame-multiplayer');
            const lobbyInfoEl = content.querySelector('#passwordgame-lobby-info');
            const lobbyIdEl = content.querySelector('#passwordgame-lobby-id');
            const lobbyStatusEl = content.querySelector('#passwordgame-lobby-status');
            const lobbyPlayersEl = content.querySelector('#passwordgame-lobby-players');
            const startGameBtn = content.querySelector('#passwordgame-start-game');
            
            let isMultiplayer = false;
            let currentLobbyId = null;
            let isHost = false;
            let lobbyListener = null;
            
            // Update lobby info function
            function updateLobbyInfo() {
                if (!currentLobbyId || !database) return;
                
                database.ref(`passwordGameLobbies/${currentLobbyId}`).once('value', (snapshot) => {
                    const data = snapshot.val();
                    if (!data) return;
                    
                    const players = Array.isArray(data.players) ? data.players : Object.keys(data.players || {});
                    const playerNames = players.map(p => escapeHtml(p || 'Unknown')).join(', ');
                    
                    if (lobbyPlayersEl) {
                        lobbyPlayersEl.textContent = `Players (${players.length}/2): ${playerNames}`;
                    }
                    
                    if (isHost) {
                        if (lobbyStatusEl) {
                            lobbyStatusEl.textContent = `Status: You are HOST - ${players.length >= 2 ? 'Ready to start!' : 'Waiting for player...'}`;
                        }
                        if (startGameBtn) {
                            startGameBtn.style.display = players.length >= 2 && currentPassword && !data.gameStarted ? 'block' : 'none';
                        }
                    } else {
                        if (lobbyStatusEl) {
                            lobbyStatusEl.textContent = data.gameStarted ? 'Status: Game started!' : 'Status: Waiting for host to start...';
                        }
                        if (startGameBtn) startGameBtn.style.display = 'none';
                    }
                });
            }
            
            function startNewGame() {
                currentPassword = words[Math.floor(Math.random() * words.length)];
                attempts = 0;
                gameWon = false;
                guessesArea.innerHTML = '';
                resultEl.textContent = '';
                attemptsEl.textContent = attempts;
                inputField.value = '';
                inputField.disabled = false;
                submitBtn.disabled = false;
                inputField.focus();
            }
            
            function checkGuess() {
                const guess = inputField.value.toUpperCase().trim();
                
                if (guess.length !== 5) {
                    resultEl.textContent = 'Please enter exactly 5 letters!';
                    resultEl.style.color = '#f85149';
                    return;
                }
                
                if (!/^[A-Z]+$/.test(guess)) {
                    resultEl.textContent = 'Only letters allowed!';
                    resultEl.style.color = '#f85149';
                    return;
                }
                
                attempts++;
                attemptsEl.textContent = attempts;
                
                // Create guess display
                const guessDiv = document.createElement('div');
                guessDiv.style.cssText = 'margin-bottom: 5px; padding: 5px; background: #f0f0f0; border: 1px solid #ccc;';
                
                let guessHTML = '';
                let correctCount = 0;
                
                for (let i = 0; i < 5; i++) {
                    const guessLetter = guess[i];
                    const passwordLetter = currentPassword[i];
                    let color = '#666';
                    let bgColor = '#ddd';
                    
                    if (guessLetter === passwordLetter) {
                        color = '#fff';
                        bgColor = '#238636';
                        correctCount++;
                    } else if (currentPassword.includes(guessLetter)) {
                        color = '#fff';
                        bgColor = '#f85149';
                    }
                    
                    guessHTML += `<span style="display: inline-block; width: 30px; height: 30px; line-height: 30px; text-align: center; margin: 2px; background: ${bgColor}; color: ${color}; font-weight: bold; border: 1px solid #999;">${guessLetter}</span>`;
                }
                
                guessDiv.innerHTML = guessHTML;
                guessesArea.appendChild(guessDiv);
                guessesArea.scrollTop = guessesArea.scrollHeight;
                
                // Check win/lose
                if (correctCount === 5) {
                    gameWon = true;
                    resultEl.textContent = 'ðŸŽ‰ You won! The password was ' + currentPassword;
                    resultEl.style.color = '#238636';
                    inputField.disabled = true;
                    submitBtn.disabled = true;
                } else if (attempts >= maxAttempts) {
                    resultEl.textContent = 'âŒ Game Over! The password was ' + currentPassword;
                    resultEl.style.color = '#f85149';
                    inputField.disabled = true;
                    submitBtn.disabled = true;
                } else {
                    resultEl.textContent = `${correctCount} correct letter(s) in right position`;
                    resultEl.style.color = '#58a6ff';
                }
                
                inputField.value = '';
                inputField.focus();
            }
            
            submitBtn.onclick = checkGuess;
            inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !inputField.disabled) {
                    checkGuess();
                }
            });
            
            newGameBtn.onclick = startNewGame;
            
            // Multiplayer mode handler
            function showMultiplayerLobbies() {
                windowZIndex++;
                const lobbyWindow = document.createElement('div');
                lobbyWindow.className = 'win95-window';
                lobbyWindow.style.left = '150px';
                lobbyWindow.style.top = '100px';
                lobbyWindow.style.width = '400px';
                lobbyWindow.style.height = '400px';
                lobbyWindow.style.zIndex = windowZIndex;
                
                const header = document.createElement('div');
                header.className = 'win95-window-header';
                const title = document.createElement('div');
                title.className = 'win95-window-title';
                title.textContent = 'Password Game - Multiplayer';
                const controls = document.createElement('div');
                controls.className = 'win95-window-controls';
                const closeBtn = document.createElement('button');
                closeBtn.className = 'win95-window-button';
                closeBtn.textContent = 'Ã—';
                closeBtn.onclick = () => lobbyWindow.remove();
                controls.appendChild(closeBtn);
                header.appendChild(title);
                header.appendChild(controls);
                
                const content = document.createElement('div');
                content.className = 'win95-window-content';
                content.style.padding = '10px';
                content.style.overflow = 'auto';
                content.innerHTML = '<div style="text-align: center; margin: 10px 0;"><button id="refresh-password-lobbies" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">Refresh</button><div style="font-size: 11px; margin-bottom: 10px;">Available Lobbies:</div><div id="lobby-list">Loading...</div></div>';
                
                lobbyWindow.appendChild(header);
                lobbyWindow.appendChild(content);
                document.getElementById('remoteDesktop').appendChild(lobbyWindow);
                
                let lobbyRefreshInterval = null;
                let lobbyListener = null;
                
                function renderLobbies(lobbiesData) {
                    const listEl = content.querySelector('#lobby-list');
                    if (!listEl) return;
                    
                    // Always show 5 fixed lobbies
                    const fixedLobbyIds = ['lobby1', 'lobby2', 'lobby3', 'lobby4', 'lobby5'];
                    let html = '';
                    
                    fixedLobbyIds.forEach((lobbyId, index) => {
                        const lobbyNum = index + 1;
                        const lobby = lobbiesData[lobbyId];
                        
                        if (lobby) {
                            const hasPassword = lobby.lobbyPassword && lobby.lobbyPassword.length > 0;
                            const hostName = lobby.hostName || lobby.host || 'None';
                            const players = Array.isArray(lobby.players) ? lobby.players : Object.keys(lobby.players || {});
                            const isFull = players.length >= 2;
                            const isGameStarted = lobby.gameStarted || false;
                            const statusText = isGameStarted ? ' (Game in progress)' : isFull ? ' (Full)' : ' (Open)';
                            
                            html += `<div style="border: 1px inset #c0c0c0; padding: 8px; margin: 5px 0; background: #fff;"><div style="font-size: 11px; font-weight: bold;">Lobby ${lobbyNum}</div><div style="font-size: 10px; color: #666;">Host: ${escapeHtml(hostName)}</div><div style="font-size: 10px; color: #666;">Players: ${players.length}/2${statusText} ${hasPassword ? 'ðŸ”’' : ''}</div><button data-lobby-id="${lobbyId}" class="join-lobby-btn" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; cursor: pointer; font-size: 10px; margin-top: 5px; ${isFull && !isGameStarted ? 'opacity: 0.5;' : ''}" ${isFull && !isGameStarted ? 'disabled' : ''}>Join</button></div>`;
                        } else {
                            // Lobby doesn't exist yet, show empty
                            html += `<div style="border: 1px inset #c0c0c0; padding: 8px; margin: 5px 0; background: #fff;"><div style="font-size: 11px; font-weight: bold;">Lobby ${lobbyNum}</div><div style="font-size: 10px; color: #666;">Host: None</div><div style="font-size: 10px; color: #666;">Players: 0/2 (Open)</div><button data-lobby-id="${lobbyId}" class="join-lobby-btn" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; cursor: pointer; font-size: 10px; margin-top: 5px;">Join</button></div>`;
                        }
                    });
                    
                    listEl.innerHTML = html;
                    
                    // Attach event listeners to all join buttons
                    listEl.querySelectorAll('.join-lobby-btn').forEach(btn => {
                        btn.onclick = () => {
                            const lobbyId = btn.getAttribute('data-lobby-id');
                            if (lobbyId) {
                                joinLobbyInternal(lobbyId, false);
                            }
                        };
                    });
                }
                
                function loadLobbies() {
                    const listEl = content.querySelector('#lobby-list');
                    if (database) {
                        // Initialize fixed lobbies if they don't exist
                        const fixedLobbyIds = ['lobby1', 'lobby2', 'lobby3', 'lobby4', 'lobby5'];
                        fixedLobbyIds.forEach(lobbyId => {
                            database.ref(`passwordGameLobbies/${lobbyId}`).once('value', (snapshot) => {
                                if (!snapshot.exists()) {
                                    database.ref(`passwordGameLobbies/${lobbyId}`).set({
                                        host: null,
                                        hostName: null,
                                        players: [],
                                        password: '',
                                        lobbyPassword: null,
                                        attempts: {},
                                        gameStarted: false,
                                        createdAt: Date.now()
                                    });
                                }
                            });
                        });
                        
                        // Remove old listener if exists
                        if (lobbyListener) {
                            database.ref('passwordGameLobbies').off('value', lobbyListener);
                        }
                        
                        // Set up listener for all lobbies
                        lobbyListener = (snapshot) => {
                            const allLobbies = snapshot.val() || {};
                            renderLobbies(allLobbies);
                        };
                        
                        database.ref('passwordGameLobbies').on('value', lobbyListener);
                        
                        // Also refresh every 2 seconds for better responsiveness
                        if (lobbyRefreshInterval) {
                            clearInterval(lobbyRefreshInterval);
                        }
                        lobbyRefreshInterval = setInterval(() => {
                            database.ref('passwordGameLobbies').once('value', lobbyListener);
                        }, 2000);
                    } else {
                        if (listEl) {
                            listEl.innerHTML = '<div style="font-size: 11px; color: #f85149; text-align: center; margin: 10px 0;">Firebase not available. Please check connection.</div>';
                        }
                    }
                }
                
                closeBtn.onclick = () => {
                    if (lobbyListener && database) {
                        database.ref('passwordGameLobbies').off('value', lobbyListener);
                    }
                    if (lobbyRefreshInterval) {
                        clearInterval(lobbyRefreshInterval);
                    }
                    lobbyWindow.remove();
                };
                
                function createLobby() {
                    windowZIndex++;
                    const settingsWindow = document.createElement('div');
                    settingsWindow.className = 'win95-window';
                    settingsWindow.style.left = '250px';
                    settingsWindow.style.top = '150px';
                    settingsWindow.style.width = '300px';
                    settingsWindow.style.height = '200px';
                    settingsWindow.style.zIndex = windowZIndex;
                    
                    const settingsHeader = document.createElement('div');
                    settingsHeader.className = 'win95-window-header';
                    const settingsTitle = document.createElement('div');
                    settingsTitle.className = 'win95-window-title';
                    settingsTitle.textContent = 'Lobby Settings';
                    const settingsControls = document.createElement('div');
                    settingsControls.className = 'win95-window-controls';
                    const settingsCloseBtn = document.createElement('button');
                    settingsCloseBtn.className = 'win95-window-button';
                    settingsCloseBtn.textContent = 'Ã—';
                    settingsCloseBtn.onclick = () => settingsWindow.remove();
                    settingsControls.appendChild(settingsCloseBtn);
                    settingsHeader.appendChild(settingsTitle);
                    settingsHeader.appendChild(settingsControls);
                    
                    const settingsContent = document.createElement('div');
                    settingsContent.className = 'win95-window-content';
                    settingsContent.style.padding = '15px';
                    settingsContent.innerHTML = `
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">Password (optional):</label>
                            <input type="password" id="password-lobby-password" placeholder="Leave empty for no password" style="width: 100%; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px;">
                        </div>
                        <button id="password-create-confirm" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; width: 100%; margin-top: 10px;">Create Lobby</button>
                    `;
                    
                    settingsWindow.appendChild(settingsHeader);
                    settingsWindow.appendChild(settingsContent);
                    document.getElementById('remoteDesktop').appendChild(settingsWindow);
                    
                    const confirmBtn = settingsContent.querySelector('#password-create-confirm');
                    confirmBtn.onclick = () => {
                        const password = settingsContent.querySelector('#password-lobby-password').value.trim();
                        const userId = getUserId() || 'user' + Date.now();
                        const hostName = userId;
                        const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        if (database) {
                            database.ref(`passwordGameLobbies/${lobbyId}`).set({
                                host: userId,
                                hostName: hostName,
                                players: [userId],
                                password: '',
                                lobbyPassword: password || null,
                                attempts: {},
                                gameStarted: false,
                                createdAt: Date.now()
                            });
                            settingsWindow.remove();
                            joinLobbyInternal(lobbyId, true, password);
                            lobbyWindow.remove();
                        }
                    };
                    
                    // Make draggable
                    let isDragging = false;
                    settingsHeader.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        settingsWindow.style.zIndex = ++windowZIndex;
                        const initialX = e.clientX - settingsWindow.offsetLeft;
                        const initialY = e.clientY - settingsWindow.offsetTop;
                        const onMove = (e) => {
                            if (isDragging) {
                                settingsWindow.style.left = (e.clientX - initialX) + 'px';
                                settingsWindow.style.top = (e.clientY - initialY) + 'px';
                            }
                        };
                        const onUp = () => {
                            isDragging = false;
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                        };
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });
                }
                
                function joinLobbyInternal(lobbyId, isHostPlayer, providedPassword = null) {
                    const userId = getUserId() || 'user' + Date.now();
                    
                    // Check if lobby has password
                    if (database && !isHostPlayer) {
                        database.ref(`passwordGameLobbies/${lobbyId}`).once('value', (snapshot) => {
                            const data = snapshot.val();
                            
                            // If lobby doesn't exist, create it with this user as host
                            if (!data) {
                                database.ref(`passwordGameLobbies/${lobbyId}`).set({
                                    host: userId,
                                    hostName: userId,
                                    players: [userId],
                                    password: '',
                                    lobbyPassword: null,
                                    attempts: {},
                                    gameStarted: false,
                                    createdAt: Date.now()
                                }).then(() => {
                                    currentLobbyId = lobbyId;
                                    isMultiplayer = true;
                                    isHost = true;
                                    modeEl.textContent = 'You are HOST. Set word to start...';
                                    
                                    if (lobbyInfoEl) lobbyInfoEl.style.display = 'block';
                                    if (lobbyIdEl) lobbyIdEl.textContent = lobbyId;
                                    setupGameMode();
                                    updateLobbyInfo();
                                    
                                    // Listen for lobby updates
                                    setupLobbyListener();
                                });
                                return;
                            }
                            
                            // Check if game already started
                            if (data.gameStarted) {
                                alert('This game has already started! Please join another lobby.');
                                return;
                            }
                            
                            const players = Array.isArray(data.players) ? data.players : Object.keys(data.players || {});
                            if (players.length >= 2) {
                                alert('Lobby is full!');
                                return;
                            }
                            
                            // Check if already in lobby
                            if (players.includes(userId)) {
                                alert('You are already in this lobby!');
                                currentLobbyId = lobbyId;
                                isMultiplayer = true;
                                isHost = data.host === userId;
                                if (lobbyInfoEl) lobbyInfoEl.style.display = 'block';
                                if (lobbyIdEl) lobbyIdEl.textContent = lobbyId;
                                setupGameMode();
                                updateLobbyInfo();
                                setupLobbyListener();
                                return;
                            }
                            
                            const lobbyPassword = data.lobbyPassword;
                            if (lobbyPassword && lobbyPassword.length > 0) {
                                if (providedPassword === null) {
                                    const passwordInput = prompt(`This lobby is password protected. Enter password:`);
                                    if (passwordInput !== lobbyPassword) {
                                        alert('Incorrect password!');
                                        return;
                                    }
                                } else if (providedPassword !== lobbyPassword) {
                                    alert('Incorrect password!');
                                    return;
                                }
                            }
                            
                            // Add player to lobby
                            const currentPlayers = Array.isArray(data.players) ? data.players : Object.keys(data.players || {});
                            if (!currentPlayers.includes(userId)) {
                                currentPlayers.push(userId);
                                
                                // Update lobby, set as host if first player
                                const updates = {
                                    players: currentPlayers
                                };
                                if (!data.host || currentPlayers.length === 1) {
                                    updates.host = userId;
                                    updates.hostName = userId;
                                }
                                
                                database.ref(`passwordGameLobbies/${lobbyId}`).update(updates).then(() => {
                                    currentLobbyId = lobbyId;
                                    isMultiplayer = true;
                                    isHost = updates.host === userId;
                                    modeEl.textContent = isHost ? 'You are HOST. Set word to start...' : 'You are GUESSING. Wait for host to set word...';
                                    
                                    if (lobbyInfoEl) lobbyInfoEl.style.display = 'block';
                                    if (lobbyIdEl) lobbyIdEl.textContent = lobbyId;
                                    setupGameMode();
                                    updateLobbyInfo();
                                    
                                    // Listen for lobby updates
                                    setupLobbyListener();
                                });
                            }
                        });
                        return;
                    }
                    
                    // Host or no password check needed
                    currentLobbyId = lobbyId;
                    isMultiplayer = true;
                    isHost = isHostPlayer;
                    
                    // Show lobby info
                    if (lobbyInfoEl) lobbyInfoEl.style.display = 'block';
                    if (lobbyIdEl) lobbyIdEl.textContent = lobbyId;
                    updateLobbyInfo();
                    setupGameMode();
                    
                    // Listen for lobby updates
                    setupLobbyListener();
                }
                
                function setupLobbyListener() {
                    if (database && currentLobbyId) {
                        if (lobbyListener) {
                            database.ref(`passwordGameLobbies/${currentLobbyId}`).off('value', lobbyListener);
                        }
                        lobbyListener = (snapshot) => {
                            const data = snapshot.val();
                            if (data) {
                                updateLobbyInfo();
                                if (data.gameStarted && data.password) {
                                    currentPassword = data.password;
                                    if (!isHost) {
                                        modeEl.textContent = 'Game started! Guess the word!';
                                    }
                                }
                            } else {
                                // Lobby was deleted, reset
                                currentLobbyId = null;
                                isMultiplayer = false;
                                if (lobbyInfoEl) lobbyInfoEl.style.display = 'none';
                            }
                        };
                        database.ref(`passwordGameLobbies/${currentLobbyId}`).on('value', lobbyListener);
                    }
                }
                
                function updateLobbyInfo() {
                    if (!currentLobbyId || !database) return;
                    
                    database.ref(`passwordGameLobbies/${currentLobbyId}`).once('value', (snapshot) => {
                        const data = snapshot.val();
                        if (!data) {
                            // Lobby was deleted, clean up
                            currentLobbyId = null;
                            isMultiplayer = false;
                            if (lobbyInfoEl) lobbyInfoEl.style.display = 'none';
                            return;
                        }
                        
                        // Clean up empty arrays/objects in players
                        let players = Array.isArray(data.players) ? data.players : Object.keys(data.players || {});
                        players = players.filter(p => p && p.trim() !== '');
                        
                        // Update players list if needed
                        if (players.length !== (Array.isArray(data.players) ? data.players.length : Object.keys(data.players || {}).length)) {
                            database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                players: players
                            });
                        }
                        
                        const playerNames = players.map(p => escapeHtml(p || 'Unknown')).join(', ');
                        
                        if (lobbyPlayersEl) {
                            lobbyPlayersEl.textContent = `Players (${players.length}/2): ${playerNames || 'None'}`;
                        }
                        
                        if (isHost) {
                            if (lobbyStatusEl) {
                                lobbyStatusEl.textContent = `Status: You are HOST - ${players.length >= 2 ? 'Ready to start!' : 'Waiting for player...'}`;
                            }
                            if (startGameBtn) {
                                startGameBtn.style.display = players.length >= 2 && currentPassword && !data.gameStarted ? 'block' : 'none';
                            }
                        } else {
                            if (lobbyStatusEl) {
                                lobbyStatusEl.textContent = data.gameStarted ? 'Status: Game started!' : 'Status: Waiting for host to start...';
                            }
                            if (startGameBtn) startGameBtn.style.display = 'none';
                        }
                    });
                }
                
                function setupGameMode() {
                    if (isHost) {
                        inputField.placeholder = 'Enter word to hide...';
                        const inputSection = content.querySelector('#passwordgame-input-section');
                        inputSection.innerHTML = '<input type="text" id="passwordgame-set-word" maxlength="5" style="flex: 1; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px; font-family: monospace; text-transform: uppercase;" placeholder="Enter 5-letter word..."><button id="passwordgame-set-word-btn" style="padding: 5px 15px; background: #c0c0c0; border: 2px outset #c0c0c0; font-size: 11px; font-weight: bold; cursor: pointer;">Set Word</button>';
                        const setWordInput = content.querySelector('#passwordgame-set-word');
                        const setWordBtn = content.querySelector('#passwordgame-set-word-btn');
                        setWordBtn.onclick = () => {
                            const word = setWordInput.value.toUpperCase().trim();
                            if (word.length === 5 && /^[A-Z]+$/.test(word)) {
                                if (database) {
                                    database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                        password: word,
                                        gameStarted: true
                                    });
                                    currentPassword = word;
                                    inputSection.innerHTML = '<div style="font-size: 11px; color: #238636; padding: 5px; text-align: center;">Word set! Click Start Game when ready.</div>';
                                    updateLobbyInfo();
                                }
                            }
                        };
                        
                        // Start game button handler
                        if (startGameBtn) {
                            startGameBtn.onclick = () => {
                                if (database && currentPassword) {
                                    database.ref(`passwordGameLobbies/${currentLobbyId}`).update({
                                        gameStarted: true
                                    });
                                    updateLobbyInfo();
                                } else {
                                    alert('Please set a word first!');
                                }
                            };
                        }
                    } else {
                        inputField.placeholder = 'Enter 5 letters...';
                        // Lobby updates are handled by the listener in joinLobbyInternal
                    }
                }
                
                const refreshBtn = content.querySelector('#refresh-password-lobbies');
                if (refreshBtn) {
                    refreshBtn.onclick = () => {
                        if (database) {
                            database.ref('passwordGameLobbies').once('value', (snapshot) => {
                                const allLobbies = snapshot.val() || {};
                                renderLobbies(allLobbies);
                            });
                        }
                    };
                }
                loadLobbies();
                
                // Make draggable
                let isDragging = false;
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lobbyWindow.style.zIndex = ++windowZIndex;
                    const initialX = e.clientX - lobbyWindow.offsetLeft;
                    const initialY = e.clientY - lobbyWindow.offsetTop;
                    const onMove = (e) => {
                        if (isDragging) {
                            lobbyWindow.style.left = (e.clientX - initialX) + 'px';
                            lobbyWindow.style.top = (e.clientY - initialY) + 'px';
                        }
                    };
                    const onUp = () => {
                        isDragging = false;
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            }
            
            multiplayerBtn.onclick = showMultiplayerLobbies;
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'passwordgame',
                element: window
            });
            
            updateTaskbar();
            
            // Start the game
            startNewGame();
        }
        
        // Paint v2 Multiplayer app
        function openPaintV2App(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '550px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                if (currentLobbyId && database) {
                    const userId = getUserId();
                    database.ref(`paintv2Lobbies/${currentLobbyId}/players/${userId}`).remove();
                    if (paintLobbyListener) {
                        database.ref(`paintv2Lobbies/${currentLobbyId}`).off('value', paintLobbyListener);
                    }
                }
                if (lobbyInfoEl) lobbyInfoEl.style.display = 'none';
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.height = 'calc(100% - 20px)';
            
            const gameHTML = `
                <div style="margin-bottom: 10px; text-align: center;">
                    <button id="paintv2-lobby" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 5px;">Multiplayer Lobbies</button>
                    <div id="paintv2-lobby-info" style="display: none; border: 1px inset #c0c0c0; background: #f0f0f0; padding: 8px; margin: 5px 0; font-size: 11px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">Lobby: <span id="paintv2-lobby-id">-</span></div>
                        <div id="paintv2-lobby-status" style="margin-bottom: 5px;">Status: In lobby</div>
                        <div id="paintv2-lobby-players" style="font-size: 10px; color: #666;">Players: Loading...</div>
                    </div>
                    <div id="paintv2-status" style="font-size: 11px; color: #666; margin: 5px 0;">Click to join/create a lobby</div>
                    <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-top: 5px;">
                        <input type="color" id="paintv2-color" value="#000000" style="width: 40px; height: 30px; border: 2px inset #c0c0c0; cursor: pointer;">
                        <button id="paintv2-clear" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Clear</button>
                    </div>
                </div>
                <canvas id="paintv2-canvas" width="560" height="400" style="border: 2px inset #c0c0c0; background: #fff; cursor: crosshair; display: block; margin: 0 auto;"></canvas>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#paintv2-canvas');
            const ctx = canvas.getContext('2d');
            const colorPicker = content.querySelector('#paintv2-color');
            const clearBtn = content.querySelector('#paintv2-clear');
            const lobbyBtn = content.querySelector('#paintv2-lobby');
            const statusEl = content.querySelector('#paintv2-status');
            const lobbyInfoEl = content.querySelector('#paintv2-lobby-info');
            const paintLobbyIdEl = content.querySelector('#paintv2-lobby-id');
            const paintLobbyStatusEl = content.querySelector('#paintv2-lobby-status');
            const paintLobbyPlayersEl = content.querySelector('#paintv2-lobby-players');
            
            let currentLobbyId = null;
            let userId = getUserId() || 'user' + Date.now();
            let isDrawing = false;
            let currentColor = '#000000';
            let paintLobbyListener = null;
            
            // Update Paint v2 lobby info function
            function updatePaintLobbyInfo() {
                if (!currentLobbyId || !database) return;
                
                database.ref(`paintv2Lobbies/${currentLobbyId}`).once('value', (snapshot) => {
                    const data = snapshot.val();
                    if (!data) return;
                    
                    const players = Object.keys(data.players || {});
                    const isHostPlayer = data.host === userId;
                    const playerNames = players.map(p => {
                        if (p === data.host) return escapeHtml(p) + ' (Host)';
                        return escapeHtml(p);
                    }).join(', ');
                    
                    if (paintLobbyPlayersEl) {
                        paintLobbyPlayersEl.textContent = `Players (${players.length}/${data.maxPlayers || 10}): ${playerNames}`;
                    }
                    
                    if (paintLobbyStatusEl) {
                        paintLobbyStatusEl.textContent = isHostPlayer ? 'Status: You are HOST - Drawing active!' : 'Status: Drawing active!';
                    }
                });
            }
            
            // Drawing functionality
            function drawOnCanvas(x, y, color, prevX, prevY) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                if (prevX !== undefined && prevY !== undefined) {
                    ctx.moveTo(prevX, prevY);
                }
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Sync to Firebase
                if (currentLobbyId && database) {
                    database.ref(`paintv2Lobbies/${currentLobbyId}/drawings`).push({
                        x: x / canvas.width,
                        y: y / canvas.height,
                        prevX: prevX !== undefined ? prevX / canvas.width : undefined,
                        prevY: prevY !== undefined ? prevY / canvas.height : undefined,
                        color: color,
                        userId: userId,
                        timestamp: Date.now()
                    });
                }
            }
            
            let lastX = null;
            let lastY = null;
            
            canvas.addEventListener('mousedown', (e) => {
                if (!currentLobbyId) {
                    statusEl.textContent = 'Please join/create a lobby first!';
                    statusEl.style.color = '#f85149';
                    return;
                }
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                lastX = x;
                lastY = y;
                drawOnCanvas(x, y, currentColor);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentLobbyId) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drawOnCanvas(x, y, currentColor, lastX, lastY);
                lastX = x;
                lastY = y;
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastX = null;
                lastY = null;
            });
            
            colorPicker.addEventListener('change', (e) => {
                currentColor = e.target.value;
            });
            
            clearBtn.onclick = () => {
                if (currentLobbyId && database) {
                    database.ref(`paintv2Lobbies/${currentLobbyId}`).update({ clearCanvas: Date.now() });
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };
            
            // Join lobby function - must be accessible globally
            function joinLobbyInternal(lobbyId, providedPassword = null) {
                // Check if lobby has password
                if (database) {
                    database.ref(`paintv2Lobbies/${lobbyId}`).once('value', (snapshot) => {
                        const data = snapshot.val();
                        if (!data) {
                            alert('Lobby not found!');
                            return;
                        }
                        
                        const players = data.players || {};
                        const playerCount = Object.keys(players).length;
                        const maxPlayers = data.maxPlayers || 10;
                        
                        if (playerCount >= maxPlayers) {
                            alert('Lobby is full!');
                            return;
                        }
                        
                        const lobbyPassword = data.password;
                        if (lobbyPassword && lobbyPassword.length > 0) {
                            if (providedPassword === null) {
                                // Ask for password
                                const passwordInput = prompt(`This lobby is password protected. Enter password:`);
                                if (passwordInput !== lobbyPassword) {
                                    alert('Incorrect password!');
                                    return;
                                }
                            } else if (providedPassword !== lobbyPassword) {
                                alert('Incorrect password!');
                                return;
                            }
                        }
                        
                        // Join the lobby
                        currentLobbyId = lobbyId;
                        database.ref(`paintv2Lobbies/${lobbyId}/players/${userId}`).set(true);
                        statusEl.textContent = `Joined lobby ${lobbyId.substring(0, 6)}`;
                        statusEl.style.color = '#238636';
                        
                        // Show lobby info
                        if (lobbyInfoEl) lobbyInfoEl.style.display = 'block';
                        if (paintLobbyIdEl) paintLobbyIdEl.textContent = lobbyId.substring(0, 8);
                        updatePaintLobbyInfo();
                        
                        // Listen for lobby updates
                        if (paintLobbyListener) {
                            database.ref(`paintv2Lobbies/${lobbyId}`).off('value', paintLobbyListener);
                        }
                        paintLobbyListener = (snapshot) => {
                            const data = snapshot.val();
                            if (data) {
                                updatePaintLobbyInfo();
                            }
                        };
                        database.ref(`paintv2Lobbies/${lobbyId}`).on('value', paintLobbyListener);
                        
                        // Listen for drawings
                        database.ref(`paintv2Lobbies/${lobbyId}/drawings`).on('child_added', (snapshot) => {
                            const drawing = snapshot.val();
                            if (drawing.userId !== userId) {
                                const x = drawing.x * canvas.width;
                                const y = drawing.y * canvas.height;
                                const prevX = drawing.prevX !== undefined ? drawing.prevX * canvas.width : undefined;
                                const prevY = drawing.prevY !== undefined ? drawing.prevY * canvas.height : undefined;
                                drawOnCanvas(x, y, drawing.color, prevX, prevY);
                            }
                        });
                        
                        // Listen for clear
                        database.ref(`paintv2Lobbies/${lobbyId}/clearCanvas`).on('value', (snapshot) => {
                            if (snapshot.val()) {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                            }
                        });
                    });
                }
            }
            
            // Make join function globally accessible - update each time showPaintV2Lobbies is called
            // Lobby system
            function showPaintV2Lobbies() {
                // Make sure the global join function is accessible when buttons are created
                window.paintV2JoinLobby = (lobbyId) => joinLobbyInternal(lobbyId);
                
                windowZIndex++;
                const lobbyWindow = document.createElement('div');
                lobbyWindow.className = 'win95-window';
                lobbyWindow.style.left = '200px';
                lobbyWindow.style.top = '100px';
                lobbyWindow.style.width = '350px';
                lobbyWindow.style.height = '400px';
                lobbyWindow.style.zIndex = windowZIndex;
                
                const header = document.createElement('div');
                header.className = 'win95-window-header';
                const title = document.createElement('div');
                title.className = 'win95-window-title';
                title.textContent = 'Paint v2 - Multiplayer';
                const controls = document.createElement('div');
                controls.className = 'win95-window-controls';
                const closeBtn = document.createElement('button');
                closeBtn.className = 'win95-window-button';
                closeBtn.textContent = 'Ã—';
                closeBtn.onclick = () => lobbyWindow.remove();
                controls.appendChild(closeBtn);
                header.appendChild(title);
                header.appendChild(controls);
                
                const content = document.createElement('div');
                content.className = 'win95-window-content';
                content.style.padding = '10px';
                content.style.overflow = 'auto';
                content.innerHTML = '<div style="text-align: center; margin: 10px 0;"><button id="create-paint-lobby" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px;">Create Lobby</button><button id="refresh-paint-lobbies" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-bottom: 10px; margin-left: 5px;">Refresh</button><div style="font-size: 11px; margin-bottom: 10px;">Available Lobbies:</div><div id="paint-lobby-list">Loading...</div></div>';
                
                lobbyWindow.appendChild(header);
                lobbyWindow.appendChild(content);
                document.getElementById('remoteDesktop').appendChild(lobbyWindow);
                
                let lobbyRefreshInterval = null;
                let lobbyListener = null;
                
                function renderLobbies(lobbies) {
                    const listEl = content.querySelector('#paint-lobby-list');
                    if (lobbies.length === 0) {
                        listEl.innerHTML = '<div style="font-size: 11px; color: #666; text-align: center; margin: 10px 0;">No available lobbies. Create one!</div>';
                    } else {
                        let html = '';
                        lobbies.forEach(lobby => {
                            const hasPassword = lobby.password && lobby.password.length > 0;
                            const hostName = lobby.hostName || lobby.host || 'Unknown';
                            const maxPlayers = lobby.maxPlayers || 10;
                            html += `<div style="border: 1px inset #c0c0c0; padding: 8px; margin: 5px 0; background: #fff;"><div style="font-size: 11px; font-weight: bold;">Lobby ${lobby.id.substring(0, 6)}</div><div style="font-size: 10px; color: #666;">Host: ${escapeHtml(hostName)}</div><div style="font-size: 10px; color: #666;">Players: ${lobby.playerCount}/${maxPlayers} ${hasPassword ? 'ðŸ”’' : ''}</div><button onclick="window.paintV2JoinLobby('${lobby.id}')" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; cursor: pointer; font-size: 10px; margin-top: 5px;">Join</button></div>`;
                        });
                        listEl.innerHTML = html;
                    }
                }
                
                function loadLobbies() {
                    const listEl = content.querySelector('#paint-lobby-list');
                    if (database) {
                        // Remove old listener if exists
                        if (lobbyListener) {
                            database.ref('paintv2Lobbies').off('value', lobbyListener);
                        }
                        
                        // Set up listener that updates every 5 seconds
                        lobbyListener = (snapshot) => {
                            const lobbies = [];
                            snapshot.forEach((child) => {
                                const data = child.val();
                                const players = data.players || {};
                                const playerCount = Object.keys(players).length;
                                const maxPlayers = data.maxPlayers || 10;
                                if (playerCount < maxPlayers) {
                                    lobbies.push({ id: child.key, ...data, playerCount });
                                }
                            });
                            renderLobbies(lobbies);
                        };
                        
                        database.ref('paintv2Lobbies').on('value', lobbyListener);
                        
                        // Also refresh every 5 seconds
                        if (lobbyRefreshInterval) {
                            clearInterval(lobbyRefreshInterval);
                        }
                        lobbyRefreshInterval = setInterval(() => {
                            database.ref('paintv2Lobbies').once('value', lobbyListener);
                        }, 5000);
                    } else {
                        listEl.innerHTML = '<div style="font-size: 11px; color: #f85149; text-align: center; margin: 10px 0;">Firebase not available. Please check connection.</div>';
                    }
                }
                
                closeBtn.onclick = () => {
                    if (lobbyListener && database) {
                        database.ref('paintv2Lobbies').off('value', lobbyListener);
                    }
                    if (lobbyRefreshInterval) {
                        clearInterval(lobbyRefreshInterval);
                    }
                    lobbyWindow.remove();
                };
                
                function createLobby() {
                    windowZIndex++;
                    const settingsWindow = document.createElement('div');
                    settingsWindow.className = 'win95-window';
                    settingsWindow.style.left = '250px';
                    settingsWindow.style.top = '150px';
                    settingsWindow.style.width = '300px';
                    settingsWindow.style.height = '250px';
                    settingsWindow.style.zIndex = windowZIndex;
                    
                    const settingsHeader = document.createElement('div');
                    settingsHeader.className = 'win95-window-header';
                    const settingsTitle = document.createElement('div');
                    settingsTitle.className = 'win95-window-title';
                    settingsTitle.textContent = 'Lobby Settings';
                    const settingsControls = document.createElement('div');
                    settingsControls.className = 'win95-window-controls';
                    const settingsCloseBtn = document.createElement('button');
                    settingsCloseBtn.className = 'win95-window-button';
                    settingsCloseBtn.textContent = 'Ã—';
                    settingsCloseBtn.onclick = () => settingsWindow.remove();
                    settingsControls.appendChild(settingsCloseBtn);
                    settingsHeader.appendChild(settingsTitle);
                    settingsHeader.appendChild(settingsControls);
                    
                    const settingsContent = document.createElement('div');
                    settingsContent.className = 'win95-window-content';
                    settingsContent.style.padding = '15px';
                    settingsContent.innerHTML = `
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">Max Players (2-20):</label>
                            <input type="number" id="paint-maxplayers" min="2" max="20" value="10" style="width: 100%; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px;">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 11px; display: block; margin-bottom: 5px;">Password (optional):</label>
                            <input type="password" id="paint-lobby-password" placeholder="Leave empty for no password" style="width: 100%; padding: 5px; border: 1px inset #c0c0c0; font-size: 11px;">
                        </div>
                        <button id="paint-create-confirm" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; width: 100%; margin-top: 10px;">Create Lobby</button>
                    `;
                    
                    settingsWindow.appendChild(settingsHeader);
                    settingsWindow.appendChild(settingsContent);
                    document.getElementById('remoteDesktop').appendChild(settingsWindow);
                    
                    const confirmBtn = settingsContent.querySelector('#paint-create-confirm');
                    confirmBtn.onclick = () => {
                        const maxPlayers = parseInt(settingsContent.querySelector('#paint-maxplayers').value) || 10;
                        const password = settingsContent.querySelector('#paint-lobby-password').value.trim();
                        const hostName = getUserId() || 'Anonymous';
                        
                        const lobbyId = 'lobby_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        if (database) {
                            database.ref(`paintv2Lobbies/${lobbyId}`).set({
                                host: userId,
                                hostName: hostName,
                                players: { [userId]: true },
                                drawings: {},
                                maxPlayers: Math.max(2, Math.min(20, maxPlayers)),
                                password: password || null,
                                createdAt: Date.now()
                            });
                            settingsWindow.remove();
                            joinLobbyInternal(lobbyId, password);
                            lobbyWindow.remove();
                        }
                    };
                    
                    // Make draggable
                    let isDragging = false;
                    settingsHeader.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        settingsWindow.style.zIndex = ++windowZIndex;
                        const initialX = e.clientX - settingsWindow.offsetLeft;
                        const initialY = e.clientY - settingsWindow.offsetTop;
                        const onMove = (e) => {
                            if (isDragging) {
                                settingsWindow.style.left = (e.clientX - initialX) + 'px';
                                settingsWindow.style.top = (e.clientY - initialY) + 'px';
                            }
                        };
                        const onUp = () => {
                            isDragging = false;
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                        };
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });
                }
                content.querySelector('#create-paint-lobby').onclick = createLobby;
                content.querySelector('#refresh-paint-lobbies').onclick = () => {
                    if (database) {
                        database.ref('paintv2Lobbies').once('value', lobbyListener);
                    }
                };
                loadLobbies();
                
                // Make draggable
                let isDragging = false;
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lobbyWindow.style.zIndex = ++windowZIndex;
                    const initialX = e.clientX - lobbyWindow.offsetLeft;
                    const initialY = e.clientY - lobbyWindow.offsetTop;
                    const onMove = (e) => {
                        if (isDragging) {
                            lobbyWindow.style.left = (e.clientX - initialX) + 'px';
                            lobbyWindow.style.top = (e.clientY - initialY) + 'px';
                        }
                    };
                    const onUp = () => {
                        isDragging = false;
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            }
            
            lobbyBtn.onclick = showPaintV2Lobbies;
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'paintv2',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Table Tennis app removed
        
        // GIF Maker app
        function openGifMakerApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '100px';
            window.style.top = '100px';
            window.style.width = '700px';
            window.style.height = '600px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.display = 'flex';
            content.style.flexDirection = 'column';
            content.style.height = 'calc(100% - 20px)';
            
            const gameHTML = `
                <div style="margin-bottom: 10px; text-align: center;">
                    <button id="gifmaker-new" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin: 5px;">New Frame</button>
                    <button id="gifmaker-play" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin: 5px;">Play</button>
                    <button id="gifmaker-download" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 6px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin: 5px;">Download GIF</button>
                    <div style="font-size: 11px; margin: 5px;">Frames: <span id="gifmaker-frames">0</span></div>
                    <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-top: 5px;">
                        <input type="color" id="gifmaker-color" value="#000000" style="width: 40px; height: 30px; border: 2px inset #c0c0c0; cursor: pointer;">
                        <button id="gifmaker-clear" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Clear Canvas</button>
                    </div>
                </div>
                <canvas id="gifmaker-canvas" width="600" height="400" style="border: 2px inset #c0c0c0; background: #fff; cursor: crosshair; display: block; margin: 0 auto;"></canvas>
                <div id="gifmaker-preview" style="margin-top: 10px; text-align: center;"></div>
            `;
            content.innerHTML = gameHTML;
            
            const canvas = content.querySelector('#gifmaker-canvas');
            const ctx = canvas.getContext('2d');
            const colorPicker = content.querySelector('#gifmaker-color');
            const clearBtn = content.querySelector('#gifmaker-clear');
            const newFrameBtn = content.querySelector('#gifmaker-new');
            const playBtn = content.querySelector('#gifmaker-play');
            const downloadBtn = content.querySelector('#gifmaker-download');
            const framesEl = content.querySelector('#gifmaker-frames');
            const previewEl = content.querySelector('#gifmaker-preview');
            
            let frames = [];
            let currentFrame = null;
            let isDrawing = false;
            let currentColor = '#000000';
            let animationInterval = null;
            let currentFrameIndex = 0;
            
            // Drawing functionality
            let lastX = null;
            let lastY = null;
            
            function startDrawing() {
                if (!currentFrame) {
                    currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
                isDrawing = true;
            }
            
            function drawOnCanvas(x, y, prevX, prevY) {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                if (prevX !== undefined && prevY !== undefined) {
                    ctx.moveTo(prevX, prevY);
                }
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            canvas.addEventListener('mousedown', (e) => {
                startDrawing();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                lastX = x;
                lastY = y;
                drawOnCanvas(x, y);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drawOnCanvas(x, y, lastX, lastY);
                lastX = x;
                lastY = y;
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastX = null;
                lastY = null;
            });
            
            colorPicker.addEventListener('change', (e) => {
                currentColor = e.target.value;
            });
            
            clearBtn.onclick = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                currentFrame = null;
            };
            
            newFrameBtn.onclick = () => {
                // Save current frame
                if (ctx.getImageData(0, 0, canvas.width, canvas.height).data.some(p => p !== 255)) {
                    const frameData = canvas.toDataURL('image/png');
                    frames.push(frameData);
                    framesEl.textContent = frames.length;
                }
                // Clear canvas for next frame
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                currentFrame = null;
            };
            
            playBtn.onclick = () => {
                if (frames.length === 0) {
                    alert('Add at least one frame first!');
                    return;
                }
                
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                    playBtn.textContent = 'Play';
                    currentFrameIndex = 0;
                    previewEl.innerHTML = '';
                    return;
                }
                
                playBtn.textContent = 'Stop';
                currentFrameIndex = 0;
                const previewImg = document.createElement('img');
                previewImg.style.maxWidth = '300px';
                previewImg.style.border = '2px solid #000';
                previewEl.innerHTML = '';
                previewEl.appendChild(previewImg);
                
                animationInterval = setInterval(() => {
                    previewImg.src = frames[currentFrameIndex];
                    currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                }, 200);
            };
            
            downloadBtn.onclick = () => {
                if (frames.length === 0) {
                    alert('Add at least one frame first!');
                    return;
                }
                
                // Simple GIF creation using canvas animation
                // Note: This creates an animated canvas, not a real GIF file
                // For real GIF creation, you'd need a library like gif.js
                alert('GIF download feature: Create frames, then use a GIF converter tool. For now, frames are saved as images. Real GIF export would require additional libraries.');
                
                // Optionally, download each frame
                frames.forEach((frame, index) => {
                    const link = document.createElement('a');
                    link.download = `frame_${index + 1}.png`;
                    link.href = frame;
                    link.click();
                });
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'gifmaker',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Clicker app
        function openClickerApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '450px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            // Header
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            // Content
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '20px';
            content.style.textAlign = 'center';
            content.style.overflow = 'auto';
            
            const userId = getUserId();
            
            // Get current click count
            function getClickCount() {
                const saved = localStorage.getItem(`clicker_${userId}`);
                return saved ? parseInt(saved) : 0;
            }
            
            // Save click count
            function saveClickCount(count) {
                localStorage.setItem(`clicker_${userId}`, count.toString());
                if (database) {
                    database.ref(`clickerScores/${userId}`).set({
                        userId: userId,
                        clicks: count,
                        lastUpdated: Date.now()
                    });
                }
            }
            
            let clickCount = getClickCount();
            
            const gameHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px; color: #000;">Your Clicks</div>
                    <div id="clicker-count" style="font-size: 48px; font-weight: bold; color: #008080; margin-bottom: 20px;">${clickCount}</div>
                    <button id="clicker-button" style="background: #008080; border: 3px outset #008080; padding: 30px 60px; cursor: pointer; font-size: 20px; font-weight: bold; color: #fff; width: 250px; height: 120px; margin-bottom: 20px;">CLICK ME!</button>
                    <div style="font-size: 11px; color: #666; margin-bottom: 15px;">Click as fast as you can!</div>
                    <button id="clicker-leaderboard-btn" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 8px 16px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 10px;">Leaderboard</button>
                    <button id="clicker-reset-btn" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 8px 16px; cursor: pointer; font-size: 11px; font-weight: bold;">Reset</button>
                </div>
            `;
            content.innerHTML = gameHTML;
            
            const clickCountEl = content.querySelector('#clicker-count');
            const clickerBtn = content.querySelector('#clicker-button');
            const leaderboardBtn = content.querySelector('#clicker-leaderboard-btn');
            const resetBtn = content.querySelector('#clicker-reset-btn');
            
            // Click handler
            let clickAnimation = null;
            clickerBtn.addEventListener('click', () => {
                clickCount++;
                clickCountEl.textContent = clickCount;
                saveClickCount(clickCount);
                
                // Button animation
                if (clickAnimation) {
                    clearTimeout(clickAnimation);
                }
                clickerBtn.style.transform = 'scale(0.95)';
                clickerBtn.style.background = '#006666';
                clickAnimation = setTimeout(() => {
                    clickerBtn.style.transform = 'scale(1)';
                    clickerBtn.style.background = '#008080';
                }, 100);
            });
            
            // Reset handler
            resetBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset your click count? This cannot be undone!')) {
                    clickCount = 0;
                    clickCountEl.textContent = '0';
                    saveClickCount(0);
                }
            });
            
            // Leaderboard handler
            function showClickerLeaderboard() {
                globalWindowZIndex++;
                const leaderboardWindow = document.createElement('div');
                leaderboardWindow.className = 'win95-window';
                leaderboardWindow.style.left = '200px';
                leaderboardWindow.style.top = '150px';
                leaderboardWindow.style.width = '400px';
                leaderboardWindow.style.height = '500px';
                leaderboardWindow.style.zIndex = globalWindowZIndex;
                
                const header = document.createElement('div');
                header.className = 'win95-window-header';
                
                const title = document.createElement('div');
                title.className = 'win95-window-title';
                title.textContent = 'Clicker Leaderboard';
                
                const controls = document.createElement('div');
                controls.className = 'win95-window-controls';
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'win95-window-button';
                closeBtn.textContent = 'Ã—';
                closeBtn.onclick = () => leaderboardWindow.remove();
                
                controls.appendChild(closeBtn);
                header.appendChild(title);
                header.appendChild(controls);
                
                const content = document.createElement('div');
                content.className = 'win95-window-content';
                content.style.padding = '10px';
                content.style.overflow = 'auto';
                content.innerHTML = '<div style="text-align: center; margin-bottom: 10px;"><div style="font-size: 14px; font-weight: bold; margin-bottom: 10px;">Top Clickers</div><div id="clicker-leaderboard-list">Loading...</div></div>';
                
                leaderboardWindow.appendChild(header);
                leaderboardWindow.appendChild(content);
                document.getElementById('remoteDesktop').appendChild(leaderboardWindow);
                
                function loadLeaderboard() {
                    const listEl = content.querySelector('#clicker-leaderboard-list');
                    
                    if (database) {
                        database.ref('clickerScores').orderByChild('clicks').limitToLast(10).once('value', (snapshot) => {
                            const scores = [];
                            snapshot.forEach((child) => {
                                const data = child.val();
                                if (data) {
                                    scores.push({
                                        id: child.key,
                                        ...data
                                    });
                                }
                            });
                            // Sort by clicks (descending - highest first)
                            scores.sort((a, b) => (b.clicks || 0) - (a.clicks || 0));
                            renderLeaderboard(scores);
                        }, (error) => {
                            console.error('Error loading leaderboard:', error);
                            loadFromLocalStorage();
                        });
                    } else {
                        loadFromLocalStorage();
                    }
                    
                    function loadFromLocalStorage() {
                        // Get all clicker scores from localStorage
                        const scores = [];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key && key.startsWith('clicker_')) {
                                const userId = key.replace('clicker_', '');
                                const clicks = parseInt(localStorage.getItem(key)) || 0;
                                scores.push({
                                    userId: userId,
                                    clicks: clicks
                                });
                            }
                        }
                        // Sort by clicks (descending)
                        scores.sort((a, b) => b.clicks - a.clicks);
                        renderLeaderboard(scores.slice(0, 10));
                    }
                    
                    function renderLeaderboard(scores) {
                        const listEl = content.querySelector('#clicker-leaderboard-list');
                        if (scores.length === 0) {
                            listEl.innerHTML = '<div style="font-size: 11px; color: #666; text-align: center; margin: 10px 0;">No scores yet. Start clicking!</div>';
                            return;
                        }
                        
                        let html = '<div style="font-size: 11px;">';
                        scores.forEach((score, index) => {
                            const rank = index + 1;
                            const clicks = score.clicks || 0;
                            const userId = escapeHtml(score.userId || 'Anonymous');
                            const medal = rank === 1 ? 'ðŸ¥‡' : rank === 2 ? 'ðŸ¥ˆ' : rank === 3 ? 'ðŸ¥‰' : `${rank}.`;
                            
                            html += `<div style="border: 1px inset #c0c0c0; padding: 8px; margin: 5px 0; background: #fff;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-weight: bold; font-size: 12px;">${medal} ${userId}</div>
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-weight: bold; font-size: 12px; color: #008080;">${clicks.toLocaleString()} clicks</div>
                                    </div>
                                </div>
                            </div>`;
                        });
                        html += '</div>';
                        listEl.innerHTML = html;
                    }
                }
                
                loadLeaderboard();
                
                // Make window draggable
                let isDragging = false;
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    leaderboardWindow.style.zIndex = ++globalWindowZIndex;
                    const initialX = e.clientX - leaderboardWindow.offsetLeft;
                    const initialY = e.clientY - leaderboardWindow.offsetTop;
                    
                    const onMove = (e) => {
                        if (isDragging) {
                            leaderboardWindow.style.left = (e.clientX - initialX) + 'px';
                            leaderboardWindow.style.top = (e.clientY - initialY) + 'px';
                        }
                    };
                    
                    const onUp = () => {
                        isDragging = false;
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            }
            
            leaderboardBtn.addEventListener('click', showClickerLeaderboard);
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            
            // Make window draggable
            let isDragging = false;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                window.style.zIndex = ++windowZIndex;
                const initialX = e.clientX - window.offsetLeft;
                const initialY = e.clientY - window.offsetTop;
                
                const onMove = (e) => {
                    if (isDragging) {
                        window.style.left = (e.clientX - initialX) + 'px';
                        window.style.top = (e.clientY - initialY) + 'px';
                    }
                };
                
                const onUp = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            closeBtn.onclick = () => {
                window.remove();
            };
            
            desktopWindows.push({
                iconId: iconId,
                name: name,
                type: 'clicker',
                element: window
            });
            
            updateTaskbar();
        }
        
        // Calculator app
        function openCalculatorApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '300px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            let display = '0';
            let previousValue = null;
            let operation = null;
            let shouldResetDisplay = false;
            
            const calcHTML = `
                <div style="background: #000; color: #0f0; padding: 10px; margin-bottom: 10px; font-family: 'Courier New', monospace; font-size: 24px; text-align: right; min-height: 30px; border: 2px inset #c0c0c0;" id="calc-display">0</div>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
                    <button class="calc-btn" data-op="clear" style="grid-column: span 2;">C</button>
                    <button class="calc-btn" data-op="backspace">âŒ«</button>
                    <button class="calc-btn" data-op="/">/</button>
                    <button class="calc-btn" data-num="7">7</button>
                    <button class="calc-btn" data-num="8">8</button>
                    <button class="calc-btn" data-num="9">9</button>
                    <button class="calc-btn" data-op="*">Ã—</button>
                    <button class="calc-btn" data-num="4">4</button>
                    <button class="calc-btn" data-num="5">5</button>
                    <button class="calc-btn" data-num="6">6</button>
                    <button class="calc-btn" data-op="-">-</button>
                    <button class="calc-btn" data-num="1">1</button>
                    <button class="calc-btn" data-num="2">2</button>
                    <button class="calc-btn" data-num="3">3</button>
                    <button class="calc-btn" data-op="+">+</button>
                    <button class="calc-btn" data-num="0" style="grid-column: span 2;">0</button>
                    <button class="calc-btn" data-num=".">.</button>
                    <button class="calc-btn" data-op="=">=</button>
                    <button class="calc-btn" data-op="sqrt" style="grid-column: span 2;">âˆš</button>
                    <button class="calc-btn" data-op="power">xÂ²</button>
                    <button class="calc-btn" data-op="sin">sin</button>
                    <button class="calc-btn" data-op="cos">cos</button>
                    <button class="calc-btn" data-op="tan">tan</button>
                    <button class="calc-btn" data-op="log">log</button>
                    <button class="calc-btn" data-op="ln">ln</button>
                    <button class="calc-btn" data-op="pi">Ï€</button>
                    <button class="calc-btn" data-op="e">e</button>
                </div>
            `;
            content.innerHTML = calcHTML;
            
            const displayEl = content.querySelector('#calc-display');
            const buttons = content.querySelectorAll('.calc-btn');
            
            function updateDisplay() {
                displayEl.textContent = display;
            }
            
            function calculate() {
                if (previousValue === null || operation === null) return;
                
                const current = parseFloat(display);
                let result;
                
                switch(operation) {
                    case '+': result = previousValue + current; break;
                    case '-': result = previousValue - current; break;
                    case '*': result = previousValue * current; break;
                    case '/': result = previousValue / current; break;
                    default: return;
                }
                
                display = result.toString();
                previousValue = null;
                operation = null;
                shouldResetDisplay = true;
                updateDisplay();
            }
            
            buttons.forEach(btn => {
                btn.style.cssText = 'background: #c0c0c0; border: 2px outset #c0c0c0; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold;';
                btn.addEventListener('click', () => {
                    const num = btn.getAttribute('data-num');
                    const op = btn.getAttribute('data-op');
                    
                    if (num !== null) {
                        if (shouldResetDisplay) {
                            display = '0';
                            shouldResetDisplay = false;
                        }
                        if (display === '0') {
                            display = num;
                        } else {
                            display += num;
                        }
                        updateDisplay();
                    } else if (op) {
                        if (op === 'clear') {
                            display = '0';
                            previousValue = null;
                            operation = null;
                            updateDisplay();
                        } else if (op === 'backspace') {
                            display = display.slice(0, -1) || '0';
                            updateDisplay();
                        } else if (op === '=') {
                            calculate();
                        } else if (['+', '-', '*', '/'].includes(op)) {
                            if (previousValue !== null && operation !== null) {
                                calculate();
                            }
                            previousValue = parseFloat(display);
                            operation = op;
                            shouldResetDisplay = true;
                        } else if (op === 'sqrt') {
                            display = Math.sqrt(parseFloat(display) || 0).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'power') {
                            display = Math.pow(parseFloat(display) || 0, 2).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'sin') {
                            display = Math.sin(parseFloat(display) || 0).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'cos') {
                            display = Math.cos(parseFloat(display) || 0).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'tan') {
                            display = Math.tan(parseFloat(display) || 0).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'log') {
                            display = Math.log10(parseFloat(display) || 1).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'ln') {
                            display = Math.log(parseFloat(display) || 1).toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'pi') {
                            display = Math.PI.toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        } else if (op === 'e') {
                            display = Math.E.toString();
                            shouldResetDisplay = true;
                            updateDisplay();
                        }
                    }
                });
            });
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Notes app
        function openNotesApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '500px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const userId = getUserId();
            const notesKey = `notes_${userId}`;
            
            const notesHTML = `
                <div style="margin-bottom: 10px;">
                    <button id="notes-save" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Save</button>
                    <button id="notes-clear" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Clear</button>
                </div>
                <textarea id="notes-textarea" style="width: 100%; height: 300px; border: 2px inset #c0c0c0; padding: 5px; font-family: 'MS Sans Serif', sans-serif; font-size: 11px; resize: none;">${localStorage.getItem(notesKey) || ''}</textarea>
            `;
            content.innerHTML = notesHTML;
            
            const textarea = content.querySelector('#notes-textarea');
            const saveBtn = content.querySelector('#notes-save');
            const clearBtn = content.querySelector('#notes-clear');
            
            saveBtn.addEventListener('click', () => {
                localStorage.setItem(notesKey, textarea.value);
                alert('Notes saved!');
            });
            
            clearBtn.addEventListener('click', () => {
                if (confirm('Clear all notes?')) {
                    textarea.value = '';
                    localStorage.removeItem(notesKey);
                }
            });
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Calendar app
        function openCalendarApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '450px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const userId = getUserId();
            const eventsKey = `calendar_events_${userId}`;
            
            let events = JSON.parse(localStorage.getItem(eventsKey) || '[]');
            let currentDate = new Date();
            
            function renderCalendar() {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                
                let html = `
                    <div style="text-align: center; margin-bottom: 10px;">
                        <button id="cal-prev" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 10px;">â—€</button>
                        <span style="font-size: 14px; font-weight: bold;">${monthNames[month]} ${year}</span>
                        <button id="cal-next" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 8px; cursor: pointer; font-size: 11px; font-weight: bold; margin-left: 10px;">â–¶</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 10px;">
                `;
                
                dayNames.forEach(day => {
                    html += `<div style="text-align: center; font-size: 10px; font-weight: bold; padding: 5px; background: #c0c0c0;">${day}</div>`;
                });
                
                for (let i = 0; i < firstDay; i++) {
                    html += '<div></div>';
                }
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const dayEvents = events.filter(e => e.date === dateStr);
                    const hasEvents = dayEvents.length > 0;
                    html += `<div class="cal-day" data-date="${dateStr}" style="text-align: center; padding: 8px; border: 1px solid #c0c0c0; cursor: pointer; background: ${hasEvents ? '#ffffcc' : '#fff'}; font-size: 11px;">${day}${hasEvents ? ' ðŸ“…' : ''}</div>`;
                }
                
                html += '</div>';
                html += `<div style="margin-top: 10px;"><button id="cal-add-event" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Add Event</button></div>`;
                html += `<div id="cal-events-list" style="margin-top: 10px; max-height: 150px; overflow-y: auto;"></div>`;
                
                content.innerHTML = html;
                
                content.querySelector('#cal-prev').addEventListener('click', () => {
                    currentDate.setMonth(currentDate.getMonth() - 1);
                    renderCalendar();
                });
                
                content.querySelector('#cal-next').addEventListener('click', () => {
                    currentDate.setMonth(currentDate.getMonth() + 1);
                    renderCalendar();
                });
                
                content.querySelector('#cal-add-event').addEventListener('click', () => {
                    const date = prompt('Enter date (YYYY-MM-DD):');
                    if (date) {
                        const title = prompt('Enter event title:');
                        if (title) {
                            events.push({ date, title, id: Date.now() });
                            localStorage.setItem(eventsKey, JSON.stringify(events));
                            renderCalendar();
                        }
                    }
                });
                
                content.querySelectorAll('.cal-day').forEach(dayEl => {
                    dayEl.addEventListener('click', () => {
                        const date = dayEl.getAttribute('data-date');
                        const dayEvents = events.filter(e => e.date === date);
                        const eventsList = content.querySelector('#cal-events-list');
                        if (dayEvents.length > 0) {
                            eventsList.innerHTML = `<div style="font-size: 11px; font-weight: bold; margin-bottom: 5px;">Events for ${date}:</div>` +
                                dayEvents.map(e => `<div style="font-size: 11px; margin-bottom: 5px; padding: 5px; background: #f0f0f0; border: 1px solid #c0c0c0;">${escapeHtml(e.title)} <button class="cal-delete-event" data-id="${e.id}" style="float: right; background: #c0c0c0; border: 1px outset #c0c0c0; padding: 2px 6px; cursor: pointer; font-size: 9px;">Delete</button></div>`).join('');
                            
                            eventsList.querySelectorAll('.cal-delete-event').forEach(btn => {
                                btn.addEventListener('click', () => {
                                    const id = parseInt(btn.getAttribute('data-id'));
                                    events = events.filter(e => e.id !== id);
                                    localStorage.setItem(eventsKey, JSON.stringify(events));
                                    renderCalendar();
                                });
                            });
                        } else {
                            eventsList.innerHTML = `<div style="font-size: 11px; color: #666;">No events for ${date}</div>`;
                        }
                    });
                });
            }
            
            renderCalendar();
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Weather app
        function openWeatherApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '350px';
            window.style.height = '300px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '20px';
            content.style.textAlign = 'center';
            
            content.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">Cooper City, FL</div>
                <div id="weather-loading" style="font-size: 12px; color: #666;">Loading weather...</div>
                <div id="weather-content" style="display: none;">
                    <div id="weather-temp" style="font-size: 48px; font-weight: bold; margin: 20px 0;">--Â°F</div>
                    <div id="weather-desc" style="font-size: 14px; margin-bottom: 10px;">--</div>
                    <div id="weather-details" style="font-size: 11px; color: #666; margin-top: 20px;">
                        <div>Feels like: <span id="weather-feels">--</span></div>
                        <div>Humidity: <span id="weather-humidity">--</span></div>
                        <div>Wind: <span id="weather-wind">--</span></div>
                    </div>
                    <button id="weather-refresh" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-top: 15px;">Refresh</button>
                </div>
            `;
            
            function loadWeather() {
                const loadingEl = content.querySelector('#weather-loading');
                const contentEl = content.querySelector('#weather-content');
                const tempEl = content.querySelector('#weather-temp');
                const descEl = content.querySelector('#weather-desc');
                const feelsEl = content.querySelector('#weather-feels');
                const humidityEl = content.querySelector('#weather-humidity');
                const windEl = content.querySelector('#weather-wind');
                
                // Using OpenWeatherMap API (free tier)
                // Note: In production, you'd want to use your own API key
                const apiKey = 'demo'; // Replace with actual API key
                const city = 'Cooper City,FL,US';
                const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&units=imperial&appid=${apiKey}`;
                
                // Fallback to mock data if API fails
                setTimeout(() => {
                    loadingEl.style.display = 'none';
                    contentEl.style.display = 'block';
                    
                    // Mock data for Cooper City, FL (typical Florida weather)
                    const mockData = {
                        temp: Math.floor(Math.random() * 10) + 75, // 75-85Â°F
                        feels: Math.floor(Math.random() * 10) + 78,
                        desc: ['Sunny', 'Partly Cloudy', 'Mostly Sunny'][Math.floor(Math.random() * 3)],
                        humidity: Math.floor(Math.random() * 20) + 60, // 60-80%
                        wind: Math.floor(Math.random() * 5) + 5 // 5-10 mph
                    };
                    
                    tempEl.textContent = `${mockData.temp}Â°F`;
                    descEl.textContent = mockData.desc;
                    feelsEl.textContent = `${mockData.feels}Â°F`;
                    humidityEl.textContent = `${mockData.humidity}%`;
                    windEl.textContent = `${mockData.wind} mph`;
                    
                    // Try to fetch real data (will fail silently if no API key)
                    fetch(url).then(r => r.json()).then(data => {
                        if (data.main) {
                            tempEl.textContent = `${Math.round(data.main.temp)}Â°F`;
                            descEl.textContent = data.weather[0].main;
                            feelsEl.textContent = `${Math.round(data.main.feels_like)}Â°F`;
                            humidityEl.textContent = `${data.main.humidity}%`;
                            windEl.textContent = `${Math.round(data.wind.speed)} mph`;
                        }
                    }).catch(() => {
                        // Use mock data if API fails
                    });
                }, 500);
            }
            
            content.querySelector('#weather-refresh').addEventListener('click', () => {
                content.querySelector('#weather-loading').style.display = 'block';
                content.querySelector('#weather-content').style.display = 'none';
                loadWeather();
            });
            
            loadWeather();
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Music Player app
        function openMusicApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '400px';
            window.style.height = '350px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            let currentAudio = null;
            let currentTrack = null;
            
            const musicHTML = `
                <div style="margin-bottom: 10px;">
                    <input type="file" id="music-file-input" accept="audio/*" style="display: none;">
                    <button id="music-load" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Load File</button>
                    <button id="music-stop" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Stop</button>
                </div>
                <div id="music-info" style="font-size: 11px; color: #666; margin-bottom: 10px; min-height: 20px;">No file loaded</div>
                <audio id="music-audio" controls style="width: 100%; margin-bottom: 10px;"></audio>
                <div style="font-size: 10px; color: #666; margin-top: 10px;">
                    <div>Supported formats: MP3, WAV, OGG</div>
                    <div style="margin-top: 5px;">Use the file input to load music files from your computer.</div>
                </div>
            `;
            content.innerHTML = musicHTML;
            
            const fileInput = content.querySelector('#music-file-input');
            const loadBtn = content.querySelector('#music-load');
            const stopBtn = content.querySelector('#music-stop');
            const audioEl = content.querySelector('#music-audio');
            const infoEl = content.querySelector('#music-info');
            
            loadBtn.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio = null;
                    }
                    
                    const url = URL.createObjectURL(file);
                    audioEl.src = url;
                    currentAudio = audioEl;
                    currentTrack = file.name;
                    infoEl.textContent = `Now playing: ${file.name}`;
                }
            });
            
            stopBtn.addEventListener('click', () => {
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                }
            });
            
            closeBtn.onclick = () => {
                if (currentAudio) {
                    currentAudio.pause();
                }
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // File Manager app
        function openFilesApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '500px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const userId = getUserId();
            const filesKey = `files_${userId}`;
            
            let files = JSON.parse(localStorage.getItem(filesKey) || '[]');
            let currentFolder = 'root';
            
            function renderFiles() {
                const folderFiles = files.filter(f => f.folder === currentFolder);
                
                let html = `
                    <div style="margin-bottom: 10px;">
                        <button id="files-new-folder" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">New Folder</button>
                        <button id="files-upload" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Upload File</button>
                        <input type="file" id="files-file-input" style="display: none;" multiple>
                    </div>
                    <div style="font-size: 11px; margin-bottom: 5px; font-weight: bold;">Current: ${currentFolder === 'root' ? 'Root' : currentFolder}</div>
                    <div id="files-list" style="border: 2px inset #c0c0c0; padding: 5px; min-height: 250px; max-height: 250px; overflow-y: auto; background: #fff;">
                `;
                
                if (currentFolder !== 'root') {
                    html += `<div class="file-item" data-type="folder" data-name=".." style="padding: 5px; cursor: pointer; font-size: 11px; border-bottom: 1px solid #c0c0c0;">ðŸ“ ..</div>`;
                }
                
                folderFiles.forEach(file => {
                    const icon = file.type === 'folder' ? 'ðŸ“' : 'ðŸ“„';
                    html += `<div class="file-item" data-type="${file.type}" data-name="${file.name}" data-id="${file.id}" style="padding: 5px; cursor: pointer; font-size: 11px; border-bottom: 1px solid #c0c0c0;">${icon} ${escapeHtml(file.name)}</div>`;
                });
                
                html += '</div>';
                content.innerHTML = html;
                
                content.querySelector('#files-new-folder').addEventListener('click', () => {
                    const name = prompt('Folder name:');
                    if (name) {
                        files.push({ id: Date.now(), name, type: 'folder', folder: currentFolder });
                        localStorage.setItem(filesKey, JSON.stringify(files));
                        renderFiles();
                    }
                });
                
                content.querySelector('#files-upload').addEventListener('click', () => {
                    content.querySelector('#files-file-input').click();
                });
                
                content.querySelector('#files-file-input').addEventListener('change', (e) => {
                    Array.from(e.target.files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            files.push({ id: Date.now(), name: file.name, type: 'file', folder: currentFolder, data: e.target.result, size: file.size });
                            localStorage.setItem(filesKey, JSON.stringify(files));
                            renderFiles();
                        };
                        reader.readAsDataURL(file);
                    });
                });
                
                content.querySelectorAll('.file-item').forEach(item => {
                    item.addEventListener('dblclick', () => {
                        const type = item.getAttribute('data-type');
                        const name = item.getAttribute('data-name');
                        
                        if (type === 'folder') {
                            if (name === '..') {
                                currentFolder = 'root';
                            } else {
                                currentFolder = name;
                            }
                            renderFiles();
                        } else {
                            const file = files.find(f => f.id === parseInt(item.getAttribute('data-id')));
                            if (file && file.data) {
                                const link = document.createElement('a');
                                link.href = file.data;
                                link.download = file.name;
                                link.click();
                            }
                        }
                    });
                    
                    item.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        const id = parseInt(item.getAttribute('data-id'));
                        if (confirm('Delete this item?')) {
                            files = files.filter(f => f.id !== id);
                            localStorage.setItem(filesKey, JSON.stringify(files));
                            renderFiles();
                        }
                    });
                });
            }
            
            renderFiles();
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Terminal app
        function openTerminalApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '400px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            content.style.background = '#000';
            content.style.color = '#0f0';
            content.style.fontFamily = 'Courier New, monospace';
            content.style.fontSize = '12px';
            
            const terminalHTML = `
                <div id="terminal-output" style="min-height: 300px; max-height: 300px; overflow-y: auto; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"></div>
                <div style="display: flex; align-items: center;">
                    <span style="color: #0f0;">$</span>
                    <input type="text" id="terminal-input" style="flex: 1; background: #000; color: #0f0; border: none; outline: none; font-family: 'Courier New', monospace; font-size: 12px; margin-left: 5px;" autocomplete="off">
                </div>
            `;
            content.innerHTML = terminalHTML;
            
            const outputEl = content.querySelector('#terminal-output');
            const inputEl = content.querySelector('#terminal-input');
            
            function addOutput(text) {
                outputEl.textContent += text + '\n';
                outputEl.scrollTop = outputEl.scrollHeight;
            }
            
            function executeCommand(cmd) {
                const parts = cmd.trim().split(' ');
                const command = parts[0].toLowerCase();
                const args = parts.slice(1);
                
                addOutput(`$ ${cmd}`);
                
                switch(command) {
                    case 'help':
                        addOutput('Available commands:');
                        addOutput('  help - Show this help');
                        addOutput('  clear - Clear terminal');
                        addOutput('  echo [text] - Echo text');
                        addOutput('  date - Show current date/time');
                        addOutput('  whoami - Show user ID');
                        addOutput('  ls - List files (demo)');
                        addOutput('  calc [expression] - Calculate expression');
                        break;
                    case 'clear':
                        outputEl.textContent = '';
                        break;
                    case 'echo':
                        addOutput(args.join(' '));
                        break;
                    case 'date':
                        addOutput(new Date().toString());
                        break;
                    case 'whoami':
                        addOutput(getUserId());
                        break;
                    case 'ls':
                        addOutput('file1.txt');
                        addOutput('file2.txt');
                        addOutput('folder1/');
                        break;
                    case 'calc':
                        try {
                            const expr = args.join(' ');
                            const result = Function(`"use strict"; return (${expr})`)();
                            addOutput(result.toString());
                        } catch (e) {
                            addOutput('Error: Invalid expression');
                        }
                        break;
                    case '':
                        break;
                    default:
                        addOutput(`Command not found: ${command}. Type 'help' for available commands.`);
                }
            }
            
            addOutput('Terminal v1.0');
            addOutput('Type "help" for available commands.');
            
            inputEl.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    executeCommand(inputEl.value);
                    inputEl.value = '';
                }
            });
            
            inputEl.focus();
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Code Editor app
        function openCodeApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const userId = getUserId();
            const codeKey = `code_${userId}`;
            
            const codeHTML = `
                <div style="margin-bottom: 10px;">
                    <select id="code-language" style="background: #c0c0c0; border: 2px inset #c0c0c0; padding: 4px; font-size: 11px; margin-right: 5px;">
                        <option value="javascript">JavaScript</option>
                        <option value="html">HTML</option>
                        <option value="css">CSS</option>
                        <option value="python">Python</option>
                        <option value="plain">Plain Text</option>
                    </select>
                    <button id="code-save" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Save</button>
                    <button id="code-load" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Load</button>
                </div>
                <textarea id="code-editor" style="width: 100%; height: 380px; border: 2px inset #c0c0c0; padding: 5px; font-family: 'Courier New', monospace; font-size: 12px; resize: none; background: #1e1e1e; color: #d4d4d4;">${localStorage.getItem(codeKey) || '// Start coding here...\n'}</textarea>
            `;
            content.innerHTML = codeHTML;
            
            const editor = content.querySelector('#code-editor');
            const langSelect = content.querySelector('#code-language');
            const saveBtn = content.querySelector('#code-save');
            const loadBtn = content.querySelector('#code-load');
            
            saveBtn.addEventListener('click', () => {
                localStorage.setItem(codeKey, editor.value);
                alert('Code saved!');
            });
            
            loadBtn.addEventListener('click', () => {
                const saved = localStorage.getItem(codeKey);
                if (saved) {
                    editor.value = saved;
                } else {
                    alert('No saved code found.');
                }
            });
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Image Editor app
        function openImageApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '500px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const imageHTML = `
                <div style="margin-bottom: 10px;">
                    <input type="file" id="image-file-input" accept="image/*" style="display: none;">
                    <button id="image-load" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Load Image</button>
                    <button id="image-download" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Download</button>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 11px; margin-right: 10px;">Brightness: <input type="range" id="image-brightness" min="0" max="200" value="100" style="width: 100px;"></label>
                    <label style="font-size: 11px; margin-right: 10px;">Contrast: <input type="range" id="image-contrast" min="0" max="200" value="100" style="width: 100px;"></label>
                    <label style="font-size: 11px;">Saturation: <input type="range" id="image-saturation" min="0" max="200" value="100" style="width: 100px;"></label>
                </div>
                <canvas id="image-canvas" style="border: 2px inset #c0c0c0; max-width: 100%; max-height: 350px; display: block; margin: 0 auto;"></canvas>
            `;
            content.innerHTML = imageHTML;
            
            const fileInput = content.querySelector('#image-file-input');
            const loadBtn = content.querySelector('#image-load');
            const downloadBtn = content.querySelector('#image-download');
            const canvas = content.querySelector('#image-canvas');
            const ctx = canvas.getContext('2d');
            const brightnessSlider = content.querySelector('#image-brightness');
            const contrastSlider = content.querySelector('#image-contrast');
            const saturationSlider = content.querySelector('#image-saturation');
            
            let currentImage = null;
            
            function applyFilters() {
                if (!currentImage) return;
                
                const brightness = brightnessSlider.value / 100;
                const contrast = contrastSlider.value / 100;
                const saturation = saturationSlider.value / 100;
                
                canvas.width = currentImage.width;
                canvas.height = currentImage.height;
                
                ctx.drawImage(currentImage, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Brightness
                    data[i] = Math.min(255, data[i] * brightness);
                    data[i + 1] = Math.min(255, data[i + 1] * brightness);
                    data[i + 2] = Math.min(255, data[i + 2] * brightness);
                    
                    // Contrast
                    const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));
                    data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                    data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128));
                    data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128));
                    
                    // Saturation (simplified)
                    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = gray + (data[i] - gray) * saturation;
                    data[i + 1] = gray + (data[i + 1] - gray) * saturation;
                    data[i + 2] = gray + (data[i + 2] - gray) * saturation;
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            loadBtn.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            currentImage = img;
                            applyFilters();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            brightnessSlider.addEventListener('input', applyFilters);
            contrastSlider.addEventListener('input', applyFilters);
            saturationSlider.addEventListener('input', applyFilters);
            
            downloadBtn.addEventListener('click', () => {
                if (canvas.width > 0) {
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'edited-image.png';
                        link.click();
                    });
                }
            });
            
            closeBtn.onclick = () => {
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
        
        // Video Player app
        function openVideoApp(iconId, name) {
            windowZIndex++;
            const window = document.createElement('div');
            window.className = 'win95-window';
            window.style.left = '150px';
            window.style.top = '100px';
            window.style.width = '600px';
            window.style.height = '450px';
            window.style.zIndex = windowZIndex;
            
            const header = document.createElement('div');
            header.className = 'win95-window-header';
            
            const title = document.createElement('div');
            title.className = 'win95-window-title';
            title.textContent = name;
            
            const controls = document.createElement('div');
            controls.className = 'win95-window-controls';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'win95-window-button';
            closeBtn.textContent = 'Ã—';
            controls.appendChild(closeBtn);
            header.appendChild(title);
            header.appendChild(controls);
            
            const content = document.createElement('div');
            content.className = 'win95-window-content';
            content.style.padding = '10px';
            
            const videoHTML = `
                <div style="margin-bottom: 10px;">
                    <input type="file" id="video-file-input" accept="video/*" style="display: none;">
                    <button id="video-load" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold; margin-right: 5px;">Load File</button>
                    <button id="video-stop" style="background: #c0c0c0; border: 2px outset #c0c0c0; padding: 4px 12px; cursor: pointer; font-size: 11px; font-weight: bold;">Stop</button>
                </div>
                <div id="video-info" style="font-size: 11px; color: #666; margin-bottom: 10px; min-height: 20px;">No file loaded</div>
                <video id="video-player" controls style="width: 100%; max-height: 350px; border: 2px inset #c0c0c0;"></video>
                <div style="font-size: 10px; color: #666; margin-top: 10px;">
                    <div>Supported formats: MP4, WebM, OGG</div>
                    <div style="margin-top: 5px;">Use the file input to load video files from your computer.</div>
                </div>
            `;
            content.innerHTML = videoHTML;
            
            const fileInput = content.querySelector('#video-file-input');
            const loadBtn = content.querySelector('#video-load');
            const stopBtn = content.querySelector('#video-stop');
            const videoEl = content.querySelector('#video-player');
            const infoEl = content.querySelector('#video-info');
            
            loadBtn.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    videoEl.src = url;
                    infoEl.textContent = `Now playing: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                }
            });
            
            stopBtn.addEventListener('click', () => {
                videoEl.pause();
                videoEl.currentTime = 0;
            });
            
            closeBtn.onclick = () => {
                videoEl.pause();
                window.remove();
                desktopWindows = desktopWindows.filter(w => w.element !== window);
                updateTaskbar();
            };
            
            window.appendChild(header);
            window.appendChild(content);
            document.getElementById('remoteDesktop').appendChild(window);
            makeWindowDraggable(window, header);
            desktopWindows.push({ element: window, iconId: iconId });
            updateTaskbar();
        }
            
        // Make functions globally accessible
        window.addDesktopApp = addDesktopApp;
        window.renameDesktopIcon = renameDesktopIcon;
        window.deleteDesktopIcon = deleteDesktopIcon;
        
        // Update applyTheme to handle ocean and paper themes (consolidating all wrappers)
        const originalApplyTheme4 = applyTheme;
        applyTheme = function(themeName, save = true) {
            // Cleanup if switching away from matrix
            if (document.body.classList.contains('theme-matrix') && themeName !== 'matrix') {
                cleanupMatrixColumns();
            }
            
            // Cleanup if switching away from space
            if (document.body.classList.contains('theme-space') && themeName !== 'space') {
                cleanupSpaceStars();
            }
            
            // Cleanup if switching away from ocean
            if (document.body.classList.contains('theme-ocean') && themeName !== 'ocean') {
                cleanupOceanFish();
            }
            
            // Cleanup if switching away from paper
            if (document.body.classList.contains('theme-paper') && themeName !== 'paper') {
                cleanupPaperDrawing();
            }
            
            // Cleanup if switching away from clouds
            if (document.body.classList.contains('theme-clouds') && themeName !== 'clouds') {
                cleanupClouds();
            }
            
            // Cleanup if switching away from flashcard
            if (document.body.classList.contains('theme-flashcard') && themeName !== 'flashcard') {
                cleanupFlashcards();
            }
            
            originalApplyTheme4(themeName, save);
            
            // Setup matrix handler if switching to matrix
            setupMatrixKeyHandler();
            
            // Setup space theme if switching to it
            setupSpaceTheme();
            
            // Setup ocean theme if switching to it
            setupOceanTheme();
            
            // Setup paper theme if switching to it
            setupPaperTheme();
            
            // Setup clouds theme if switching to it
            setupCloudsTheme();
            
            // Setup flashcard theme if switching to it
            setupFlashcardTheme();
        };
        
        // Update window.applyTheme to use the consolidated version
        window.applyTheme = applyTheme;
        
        // Setup ocean and paper themes on page load if active
        setTimeout(() => {
            setupOceanTheme();
            setupPaperTheme();
            setupCloudsTheme();
            setupFlashcardTheme();
        }, 150);
        
        // Handle window resize for paper canvas
        window.addEventListener('resize', () => {
            if (paperCanvas && document.body.classList.contains('theme-paper')) {
                const imageData = paperCtx.getImageData(0, 0, paperCanvas.width, paperCanvas.height);
                paperCanvas.width = window.innerWidth;
                paperCanvas.height = window.innerHeight;
                paperCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Wooperbird goose on main page
        let wooperbirdCanvas, wooperbirdCtx;
        let wooperbirdGoose = null;
        let wooperbirdDragged = false;
        let wooperbirdMousePos = { x: 0, y: 0 };
        let wooperbirdLastMousePos = { x: 0, y: 0 };
        let wooperbirdAnimationId = null;
        
        function initWooperbirdCanvas() {
            wooperbirdCanvas = document.getElementById('wooperbirdCanvas');
            if (!wooperbirdCanvas) return;
            
            wooperbirdCanvas.width = window.innerWidth;
            wooperbirdCanvas.height = window.innerHeight;
            wooperbirdCtx = wooperbirdCanvas.getContext('2d');
            wooperbirdCanvas.style.pointerEvents = wooperbirdGoose ? 'auto' : 'none';
            
            // Mouse/touch events for dragging
            wooperbirdCanvas.addEventListener('mousedown', handleWooperbirdMouseDown);
            wooperbirdCanvas.addEventListener('mousemove', handleWooperbirdMouseMove);
            wooperbirdCanvas.addEventListener('mouseup', handleWooperbirdMouseUp);
            wooperbirdCanvas.addEventListener('touchstart', handleWooperbirdTouchStart, { passive: false });
            wooperbirdCanvas.addEventListener('touchmove', handleWooperbirdTouchMove, { passive: false });
            wooperbirdCanvas.addEventListener('touchend', handleWooperbirdTouchEnd);
            
            if (wooperbirdGoose) {
                animateWooperbird();
            }
        }
        
        function spawnWooperbirdGoose() {
            if (!wooperbirdCanvas) {
                initWooperbirdCanvas();
            }
            
            wooperbirdGoose = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2,
                size: 30,
                rotation: 0,
                rotationSpeed: 0.02
            };
            
            wooperbirdCanvas.style.pointerEvents = 'auto';
            
            if (!wooperbirdAnimationId) {
                animateWooperbird();
            }
        }
        
        function drawWooperbirdGoose(goose) {
            if (!wooperbirdCtx || !goose) return;
            
            wooperbirdCtx.save();
            wooperbirdCtx.translate(goose.x, goose.y);
            wooperbirdCtx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            wooperbirdCtx.fillStyle = '#FFFFFF';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#000000';
            wooperbirdCtx.lineWidth = 2;
            wooperbirdCtx.stroke();
            
            // Draw goose head
            wooperbirdCtx.fillStyle = '#FFFFFF';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            wooperbirdCtx.stroke();
            
            // Draw beak
            wooperbirdCtx.fillStyle = '#FFA500';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            wooperbirdCtx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            wooperbirdCtx.lineTo(goose.size * 0.7, -goose.size * 0.1);
            wooperbirdCtx.closePath();
            wooperbirdCtx.fill();
            wooperbirdCtx.strokeStyle = '#000000';
            wooperbirdCtx.stroke();
            
            // Draw eye
            wooperbirdCtx.fillStyle = '#000000';
            wooperbirdCtx.beginPath();
            wooperbirdCtx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
            wooperbirdCtx.fill();
            
            wooperbirdCtx.restore();
        }
        
        function handleWooperbirdMouseDown(e) {
            if (!wooperbirdGoose) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdMouseMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = e.clientX - rect.left;
            wooperbirdMousePos.y = e.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdMouseUp() {
            wooperbirdDragged = false;
        }
        
        function handleWooperbirdTouchStart(e) {
            if (!wooperbirdGoose) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            
            const dist = Math.sqrt(Math.pow(wooperbirdMousePos.x - wooperbirdGoose.x, 2) + Math.pow(wooperbirdMousePos.y - wooperbirdGoose.y, 2));
            if (dist < wooperbirdGoose.size) {
                wooperbirdDragged = true;
            }
        }
        
        function handleWooperbirdTouchMove(e) {
            if (!wooperbirdGoose || !wooperbirdDragged) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = wooperbirdCanvas.getBoundingClientRect();
            wooperbirdLastMousePos.x = wooperbirdMousePos.x;
            wooperbirdLastMousePos.y = wooperbirdMousePos.y;
            wooperbirdMousePos.x = touch.clientX - rect.left;
            wooperbirdMousePos.y = touch.clientY - rect.top;
            
            wooperbirdGoose.x = wooperbirdMousePos.x;
            wooperbirdGoose.y = wooperbirdMousePos.y;
        }
        
        function handleWooperbirdTouchEnd() {
            wooperbirdDragged = false;
        }
        
        function animateWooperbird() {
            if (!wooperbirdCtx || !wooperbirdGoose) {
                wooperbirdAnimationId = null;
                return;
            }
            
            wooperbirdCtx.clearRect(0, 0, wooperbirdCanvas.width, wooperbirdCanvas.height);
            
            if (!wooperbirdDragged) {
                wooperbirdGoose.rotation += wooperbirdGoose.rotationSpeed;
            }
            
            drawWooperbirdGoose(wooperbirdGoose);
            
            wooperbirdAnimationId = requestAnimationFrame(animateWooperbird);
        }
        
        // Initialize wooperbird canvas on page load
        initWooperbirdCanvas();
        
        // Handle window resize for wooperbird canvas
        window.addEventListener('resize', () => {
            if (wooperbirdCanvas) {
                wooperbirdCanvas.width = window.innerWidth;
                wooperbirdCanvas.height = window.innerHeight;
            }
        });
        
        // Panic Menu system
        let panicHotkey = null;
        let panicUrl = '';
        
        function loadPanicSettings() {
            const saved = localStorage.getItem('panicSettings');
            if (saved) {
                const data = JSON.parse(saved);
                panicHotkey = data.hotkey || null;
                panicUrl = data.url || '';
            }
            setupPanicHotkey();
        }
        
        function savePanicSettings() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            if (!hotkeyInput || !urlInput) return;
            
            const url = urlInput.value.trim();
            
            if (!panicHotkey || !url) {
                if (statusEl) statusEl.textContent = 'Please set both hotkey and URL!';
                return;
            }
            
            localStorage.setItem('panicSettings', JSON.stringify({
                hotkey: panicHotkey,
                url: url
            }));
            panicUrl = url;
            setupPanicHotkey();
            
            if (statusEl) statusEl.textContent = 'Settings saved! Press your hotkey to swap tabs.';
            setTimeout(() => {
                if (statusEl) statusEl.textContent = '';
            }, 3000);
        }
        
        function setupPanicHotkey() {
            // Remove existing listener if any
            document.removeEventListener('keydown', handlePanicHotkey);
            
            if (panicHotkey && panicUrl) {
                document.addEventListener('keydown', handlePanicHotkey);
            }
        }
        
        function handlePanicHotkey(e) {
            // Check if the pressed key matches the panic hotkey
            if (e.key.toLowerCase() === panicHotkey.toLowerCase() || e.code.toLowerCase() === panicHotkey.toLowerCase()) {
                // Swap to the panic URL
                window.location.href = panicUrl;
            }
        }
        
        function initPanicMenu() {
            const hotkeyInput = document.getElementById('panicHotkeyInput');
            const urlInput = document.getElementById('panicUrlInput');
            const statusEl = document.getElementById('panicStatus');
            
            loadPanicSettings();
            
            if (hotkeyInput) {
                hotkeyInput.value = panicHotkey || '';
                
                hotkeyInput.addEventListener('focus', () => {
                    hotkeyInput.value = '';
                    hotkeyInput.placeholder = 'Press a key...';
                });
                
                hotkeyInput.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    // Get the key code or key name
                    const key = e.key.length === 1 ? e.key.toLowerCase() : e.code;
                    panicHotkey = key;
                    hotkeyInput.value = e.key.length === 1 ? e.key.toUpperCase() : e.code;
                    hotkeyInput.placeholder = 'Hotkey';
                });
            }
            
            if (urlInput) {
                urlInput.value = panicUrl;
            }
            
            if (statusEl) {
                statusEl.textContent = '';
            }
        }
        
        // Make savePanicSettings globally accessible
        window.savePanicSettings = savePanicSettings;
        
        // Load panic settings on page load
        loadPanicSettings();
        
        // Goose Rain game with physics
        let geese = [];
        let animationId = null;
        let canvas, ctx;
        let draggedGoose = null;
        let mousePos = { x: 0, y: 0 };
        let lastGooseMousePos = { x: 0, y: 0 };
        let gooseDragStartPos = { x: 0, y: 0 };
        
        // Stones game with physics
        let stones = [];
        let stonesAnimationId = null;
        let stonesCanvas, stonesCtx;
        let draggedStone = null;
        let stonesMousePos = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };
        
        function initGooseRain() {
            canvas = document.getElementById('gooseCanvas');
            if (!canvas) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx = canvas.getContext('2d');
            
            geese = [];
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = 0;
            
            // Stop previous animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Mouse/touch events for dragging
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Spawn geese
            spawnGoose();
            const spawnInterval = setInterval(() => {
                if (document.getElementById('gooserainPage').classList.contains('hidden')) {
                    clearInterval(spawnInterval);
                    return;
                }
                spawnGoose();
            }, 500);
            
            // Start animation loop
            animate();
        }
        
        function spawnGoose() {
            geese.push({
                x: Math.random() * canvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: Math.random() * 30 + 20,
                rotation: (Math.random() - 0.5) * 0.2,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                dragged: false,
                targetX: 0,
                targetY: 0,
                mass: Math.random() * 30 + 20 // Weight based on size
            });
            
            const gooseCount = document.getElementById('goose-count');
            if (gooseCount) gooseCount.textContent = geese.length;
        }
        
        function drawGoose(goose) {
                    ctx.save();
            ctx.translate(goose.x, goose.y);
            ctx.rotate(goose.rotation);
            
            // Draw goose body (simple oval)
            ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
            ctx.ellipse(0, 0, goose.size * 0.6, goose.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw goose head
            ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
            ctx.arc(goose.size * 0.5, -goose.size * 0.2, goose.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
                        ctx.stroke();
            
            // Draw beak
            ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
            ctx.moveTo(goose.size * 0.7, -goose.size * 0.2);
            ctx.lineTo(goose.size * 0.9, -goose.size * 0.15);
            ctx.lineTo(goose.size * 0.7, -goose.size * 0.1);
                    ctx.closePath();
                    ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.stroke();
            
            // Draw eye
            ctx.fillStyle = '#000000';
                    ctx.beginPath();
            ctx.arc(goose.size * 0.55, -goose.size * 0.25, 3, 0, Math.PI * 2);
                    ctx.fill();
            
                    ctx.restore();
        }
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            // Check if clicking on a goose
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleMouseUp() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            gooseDragStartPos.x = mousePos.x;
            gooseDragStartPos.y = mousePos.y;
            
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                const dist = Math.sqrt(Math.pow(mousePos.x - goose.x, 2) + Math.pow(mousePos.y - goose.y, 2));
                if (dist < goose.size) {
                    draggedGoose = goose;
                    goose.dragged = true;
                    goose.vx = 0;
                    goose.vy = 0;
                    break;
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastGooseMousePos.x = mousePos.x;
            lastGooseMousePos.y = mousePos.y;
            mousePos.x = touch.clientX - rect.left;
            mousePos.y = touch.clientY - rect.top;
            
            if (draggedGoose) {
                // Update position directly while dragging
                draggedGoose.x = mousePos.x;
                draggedGoose.y = mousePos.y;
            }
        }
        
        function handleTouchEnd() {
            if (draggedGoose) {
                // Set velocity based on movement while dragging (throwing)
                draggedGoose.vx = (mousePos.x - lastGooseMousePos.x) * 8;
                draggedGoose.vy = (mousePos.y - lastGooseMousePos.y) * 8;
                
                draggedGoose.dragged = false;
                draggedGoose = null;
            }
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw geese
            for (let i = geese.length - 1; i >= 0; i--) {
                const goose = geese[i];
                
                if (goose.dragged) {
                    // Position is updated directly in mouse/touch handlers
                    // Keep rotation while dragging
                    goose.rotation += goose.rotationSpeed * 0.5;
                } else {
                    // Physics
                    goose.vy += 0.1; // Gravity
                    goose.vx *= 0.99; // Air resistance
                    goose.vy *= 0.99;
                    
                    goose.x += goose.vx;
                    goose.y += goose.vy;
                    goose.rotation += goose.rotationSpeed;
                    
                    // Collision with ground
                    if (goose.y > canvas.height - goose.size) {
                        goose.y = canvas.height - goose.size;
                        goose.vy *= -0.6; // Bounce
                        goose.vx *= 0.8; // Friction
                        if (Math.abs(goose.vy) < 0.5) {
                            goose.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (goose.x < goose.size || goose.x > canvas.width - goose.size) {
                        goose.vx *= -0.8;
                        goose.x = Math.max(goose.size, Math.min(canvas.width - goose.size, goose.x));
                    }
                }
                
                // Collision with other geese (works for both dragged and non-dragged)
                for (let j = 0; j < geese.length; j++) {
                    if (i !== j) {
                        const other = geese[j];
                        const dx = goose.x - other.x;
                        const dy = goose.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = goose.size + other.size;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass (heavier geese push more)
                            const totalMass = goose.mass + other.mass;
                            const goosePush = (other.mass / totalMass) * overlap;
                            const otherPush = (goose.mass / totalMass) * overlap;
                            
                            // Only move non-dragged geese, or both if both are dragged
                            if (!goose.dragged) {
                                goose.x += Math.cos(angle) * goosePush;
                                goose.y += Math.sin(angle) * goosePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                        } else {
                                // If other is dragged, push the dragged goose back a bit
                                goose.x += Math.cos(angle) * goosePush * 0.3;
                                goose.y += Math.sin(angle) * goosePush * 0.3;
                            }
                            
                            // Bounce for non-dragged geese
                            if (!goose.dragged && !other.dragged) {
                                const relativeVx = goose.vx - other.vx;
                                const relativeVy = goose.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                goose.vx -= Math.cos(angle) * dot * 0.5;
                                goose.vy -= Math.sin(angle) * dot * 0.5;
                                other.vx += Math.cos(angle) * dot * 0.5;
                                other.vy += Math.sin(angle) * dot * 0.5;
                            }
                        }
                    }
                }
                
                drawGoose(goose);
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Handle window resize for goose rain
        window.addEventListener('resize', () => {
            if (canvas && !document.getElementById('gooserainPage').classList.contains('hidden')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            if (stonesCanvas && !document.getElementById('stonesPage').classList.contains('hidden')) {
                stonesCanvas.width = window.innerWidth;
                stonesCanvas.height = window.innerHeight;
            }
        });
        
        // Paint game with canvas
        let paintCanvas, paintCtx;
        let isPainting = false;
        let paintBrushSize = 5;
        let paintColor = '#000000';
        let lastPaintX = 0;
        let lastPaintY = 0;
        
        function initPaint() {
            paintCanvas = document.getElementById('paintCanvas');
            if (!paintCanvas) return;
            
            paintCanvas.width = window.innerWidth;
            paintCanvas.height = window.innerHeight;
            paintCtx = paintCanvas.getContext('2d');
            paintCtx.fillStyle = '#ffffff';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            
            // Color picker event listener
            const colorPicker = document.getElementById('paint-color-picker');
            const colorDisplay = document.getElementById('paint-color-display');
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    paintColor = e.target.value;
                    if (colorDisplay) colorDisplay.textContent = paintColor;
                });
            }
            
            // Mouse/touch events for drawing
            paintCanvas.addEventListener('mousedown', handlePaintMouseDown);
            paintCanvas.addEventListener('mousemove', handlePaintMouseMove);
            paintCanvas.addEventListener('mouseup', handlePaintMouseUp);
            paintCanvas.addEventListener('mouseleave', handlePaintMouseUp);
            paintCanvas.addEventListener('touchstart', handlePaintTouchStart, { passive: false });
            paintCanvas.addEventListener('touchmove', handlePaintTouchMove, { passive: false });
            paintCanvas.addEventListener('touchend', handlePaintTouchEnd);
        }
        
        function handlePaintMouseDown(e) {
            isPainting = true;
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = e.clientX - rect.left;
            lastPaintY = e.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintMouseMove(e) {
            if (!isPainting) return;
            const rect = paintCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintMouseUp() {
            isPainting = false;
        }
        
        function handlePaintTouchStart(e) {
            e.preventDefault();
            isPainting = true;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            lastPaintX = touch.clientX - rect.left;
            lastPaintY = touch.clientY - rect.top;
            drawPaintPoint(lastPaintX, lastPaintY);
        }
        
        function handlePaintTouchMove(e) {
            e.preventDefault();
            if (!isPainting) return;
            const touch = e.touches[0];
            const rect = paintCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawPaintLine(lastPaintX, lastPaintY, x, y);
            lastPaintX = x;
            lastPaintY = y;
        }
        
        function handlePaintTouchEnd(e) {
            e.preventDefault();
            isPainting = false;
        }
        
        function drawPaintPoint(x, y) {
            paintCtx.fillStyle = paintColor;
            paintCtx.beginPath();
            paintCtx.arc(x, y, paintBrushSize / 2, 0, Math.PI * 2);
            paintCtx.fill();
        }
        
        function drawPaintLine(x1, y1, x2, y2) {
            paintCtx.strokeStyle = paintColor;
            paintCtx.lineWidth = paintBrushSize;
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            paintCtx.beginPath();
            paintCtx.moveTo(x1, y1);
            paintCtx.lineTo(x2, y2);
            paintCtx.stroke();
        }
        
        // Handle window resize for paint canvas
        window.addEventListener('resize', () => {
            if (paintCanvas && !document.getElementById('paintPage').classList.contains('hidden')) {
                // Save current canvas content
                const imageData = paintCtx.getImageData(0, 0, paintCanvas.width, paintCanvas.height);
                paintCanvas.width = window.innerWidth;
                paintCanvas.height = window.innerHeight;
                paintCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Collaborative Drawing Board
        let drawingBoardCanvas = null;
        let drawingBoardCtx = null;
        let isDrawing = false;
        let lastDrawingX = 0;
        let lastDrawingY = 0;
        let drawingColor = '#000000';
        let drawingBrushSize = 5;
        let drawingUserId = 'user_' + Math.random().toString(36).substr(2, 9);
        let drawingSyncInterval = null;
        let drawingLastSync = 0;
        
        function initDrawingBoard() {
            drawingBoardCanvas = document.getElementById('drawingBoardCanvas');
            if (!drawingBoardCanvas) return;
            
            drawingBoardCanvas.width = window.innerWidth;
            drawingBoardCanvas.height = window.innerHeight;
            drawingBoardCtx = drawingBoardCanvas.getContext('2d');
            drawingBoardCtx.fillStyle = '#ffffff';
            drawingBoardCtx.fillRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
            
            // Load existing drawing from localStorage
            loadDrawingBoard();
            
            // Brush size slider
            const brushSizeSlider = document.getElementById('drawing-brush-size-slider');
            const brushSizeDisplay = document.getElementById('drawing-brush-size');
            if (brushSizeSlider) {
                brushSizeSlider.addEventListener('input', (e) => {
                    drawingBrushSize = parseInt(e.target.value);
                    if (brushSizeDisplay) brushSizeDisplay.textContent = drawingBrushSize;
                });
            }
            
            // Color picker
            const colorPicker = document.getElementById('drawing-color-picker');
            const colorDisplay = document.getElementById('drawing-color-display');
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    drawingColor = e.target.value;
                    if (colorDisplay) colorDisplay.textContent = drawingColor;
                });
            }
            
            // Drawing events
            drawingBoardCanvas.addEventListener('mousedown', handleDrawingMouseDown);
            drawingBoardCanvas.addEventListener('mousemove', handleDrawingMouseMove);
            drawingBoardCanvas.addEventListener('mouseup', handleDrawingMouseUp);
            drawingBoardCanvas.addEventListener('mouseleave', handleDrawingMouseUp);
            drawingBoardCanvas.addEventListener('touchstart', handleDrawingTouchStart, { passive: false });
            drawingBoardCanvas.addEventListener('touchmove', handleDrawingTouchMove, { passive: false });
            drawingBoardCanvas.addEventListener('touchend', handleDrawingTouchEnd);
            
            // Start syncing with other users (polling localStorage)
            startDrawingSync();
        }
        
        function handleDrawingMouseDown(e) {
            isDrawing = true;
            const rect = drawingBoardCanvas.getBoundingClientRect();
            lastDrawingX = e.clientX - rect.left;
            lastDrawingY = e.clientY - rect.top;
            drawDrawingPoint(lastDrawingX, lastDrawingY);
        }
        
        function handleDrawingMouseMove(e) {
            if (!isDrawing) return;
            const rect = drawingBoardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawDrawingLine(lastDrawingX, lastDrawingY, x, y);
            lastDrawingX = x;
            lastDrawingY = y;
        }
        
        function handleDrawingMouseUp() {
            isDrawing = false;
        }
        
        function handleDrawingTouchStart(e) {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const rect = drawingBoardCanvas.getBoundingClientRect();
            lastDrawingX = touch.clientX - rect.left;
            lastDrawingY = touch.clientY - rect.top;
            drawDrawingPoint(lastDrawingX, lastDrawingY);
        }
        
        function handleDrawingTouchMove(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const touch = e.touches[0];
            const rect = drawingBoardCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drawDrawingLine(lastDrawingX, lastDrawingY, x, y);
            lastDrawingX = x;
            lastDrawingY = y;
        }
        
        function handleDrawingTouchEnd(e) {
            e.preventDefault();
            isDrawing = false;
        }
        
        function drawDrawingPoint(x, y) {
            if (!drawingBoardCtx) return;
            drawingBoardCtx.fillStyle = drawingColor;
            drawingBoardCtx.beginPath();
            drawingBoardCtx.arc(x, y, drawingBrushSize / 2, 0, Math.PI * 2);
            drawingBoardCtx.fill();
            saveDrawingBoard();
        }
        
        function drawDrawingLine(x1, y1, x2, y2) {
            if (!drawingBoardCtx) return;
            drawingBoardCtx.strokeStyle = drawingColor;
            drawingBoardCtx.lineWidth = drawingBrushSize;
            drawingBoardCtx.lineCap = 'round';
            drawingBoardCtx.lineJoin = 'round';
            drawingBoardCtx.beginPath();
            drawingBoardCtx.moveTo(x1, y1);
            drawingBoardCtx.lineTo(x2, y2);
            drawingBoardCtx.stroke();
            saveDrawingBoard();
        }
        
        function saveDrawingBoard() {
            if (!drawingBoardCanvas) return;
            const imageData = drawingBoardCanvas.toDataURL();
            localStorage.setItem('drawingBoard_data', imageData);
            localStorage.setItem('drawingBoard_timestamp', Date.now().toString());
            localStorage.setItem('drawingBoard_user', drawingUserId);
        }
        
        function loadDrawingBoard() {
            if (!drawingBoardCanvas || !drawingBoardCtx) return;
            const savedData = localStorage.getItem('drawingBoard_data');
            if (savedData) {
                const img = new Image();
                img.onload = () => {
                    drawingBoardCtx.clearRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                    drawingBoardCtx.drawImage(img, 0, 0);
                };
                img.src = savedData;
            }
        }
        
        function startDrawingSync() {
            // Poll for updates from other users (localStorage-based collaboration)
            drawingSyncInterval = setInterval(() => {
                if (!drawingBoardCanvas || document.getElementById('drawingBoardPage').classList.contains('hidden')) return;
                
                const lastTimestamp = localStorage.getItem('drawingBoard_timestamp');
                const lastUser = localStorage.getItem('drawingBoard_user');
                
                if (lastTimestamp && lastUser && lastUser !== drawingUserId) {
                    const timestamp = parseInt(lastTimestamp);
                    if (timestamp > drawingLastSync) {
                        loadDrawingBoard();
                        drawingLastSync = timestamp;
                    }
                }
                
                // Update user count (simplified - in real Firebase this would be accurate)
                const userCountEl = document.getElementById('drawing-user-count');
                if (userCountEl) {
                    // For now, just show 1+ if there's recent activity
                    const recentActivity = lastTimestamp && (Date.now() - parseInt(lastTimestamp) < 5000);
                    userCountEl.textContent = recentActivity ? '1+' : '1';
                }
            }, 500); // Check every 500ms
        }
        
        function stopDrawingSync() {
            if (drawingSyncInterval) {
                clearInterval(drawingSyncInterval);
                drawingSyncInterval = null;
            }
        }
        
        function clearDrawingBoard() {
            if (!drawingBoardCanvas || !drawingBoardCtx) return;
            if (confirm('Clear the entire canvas? This will affect all users.')) {
                drawingBoardCtx.fillStyle = '#ffffff';
                drawingBoardCtx.fillRect(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                saveDrawingBoard();
            }
        }
        
        // Initialize drawing board when page is shown
        const originalShowPageForDrawing = showPage;
        showPage = function(pageId) {
            originalShowPageForDrawing(pageId);
            if (pageId === 'drawingBoardPage') {
                setTimeout(() => {
                    if (!drawingBoardCanvas) {
                        initDrawingBoard();
                    } else {
                        // Resize if needed
                        const currentWidth = drawingBoardCanvas.width;
                        const currentHeight = drawingBoardCanvas.height;
                        if (currentWidth !== window.innerWidth || currentHeight !== window.innerHeight) {
                            const imageData = drawingBoardCtx.getImageData(0, 0, currentWidth, currentHeight);
                            drawingBoardCanvas.width = window.innerWidth;
                            drawingBoardCanvas.height = window.innerHeight;
                            drawingBoardCtx.putImageData(imageData, 0, 0);
                        }
                    }
                }, 100);
            } else {
                stopDrawingSync();
            }
        };
        
        // Handle window resize for drawing board canvas
        window.addEventListener('resize', () => {
            if (drawingBoardCanvas && !document.getElementById('drawingBoardPage').classList.contains('hidden')) {
                const imageData = drawingBoardCtx.getImageData(0, 0, drawingBoardCanvas.width, drawingBoardCanvas.height);
                drawingBoardCanvas.width = window.innerWidth;
                drawingBoardCanvas.height = window.innerHeight;
                drawingBoardCtx.putImageData(imageData, 0, 0);
            }
        });
        
        // Stones game initialization
        function initStones() {
            stonesCanvas = document.getElementById('stonesCanvas');
            if (!stonesCanvas) return;
            
            stonesCanvas.width = window.innerWidth;
            stonesCanvas.height = window.innerHeight;
            stonesCtx = stonesCanvas.getContext('2d');
            
            stones = [];
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = 0;
            
            // Stop previous animation
            if (stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
            }
            
            // Mouse/touch events for dragging and throwing
            stonesCanvas.addEventListener('mousedown', handleStonesMouseDown);
            stonesCanvas.addEventListener('mousemove', handleStonesMouseMove);
            stonesCanvas.addEventListener('mouseup', handleStonesMouseUp);
            stonesCanvas.addEventListener('touchstart', handleStonesTouchStart, { passive: false });
            stonesCanvas.addEventListener('touchmove', handleStonesTouchMove, { passive: false });
            stonesCanvas.addEventListener('touchend', handleStonesTouchEnd);
            
            // Key event for spawning stones with 'e'
            stonesKeyHandler = handleStonesKeyDown;
            document.addEventListener('keydown', stonesKeyHandler);
            
            // Start animation loop
            animateStones();
        }
        
        // Handle 'e' key to spawn stones (only when on stones page)
        let stonesKeyHandler = null;
        
        function handleStonesKeyDown(e) {
            if (document.getElementById('stonesPage').classList.contains('hidden')) return;
            
            if (e.key === 'e' || e.key === 'E') {
                spawnStone();
            }
        }
        
        // Stone shape types
        const STONE_SHAPES = ['circle', 'square', 'triangle', 'irregular'];
        
        function spawnStone() {
            const size = Math.random() * 40 + 40; // Increased from 15-40 to 40-80 (bigger)
            const shape = STONE_SHAPES[Math.floor(Math.random() * STONE_SHAPES.length)];
            const stoneColor = `rgb(${Math.floor(Math.random() * 60 + 80)}, ${Math.floor(Math.random() * 40 + 60)}, ${Math.floor(Math.random() * 40 + 60)})`;
            
            // Add random scaling for stretched shapes
            const scaleX = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            const scaleY = Math.random() * 0.8 + 0.6; // 0.6 to 1.4
            
            stones.push({
                x: Math.random() * stonesCanvas.width,
                y: -50,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                size: size,
                scaleX: scaleX,
                scaleY: scaleY,
                dragged: false,
                shape: shape,
                color: stoneColor,
                mass: size * scaleX * scaleY * 3, // Increased mass (3x heavier)
                lastX: 0,
                lastY: 0,
                collisionRadius: size * Math.max(scaleX, scaleY) // Collision radius based on max scaled dimension
            });
            
            const stonesCount = document.getElementById('stones-count');
            if (stonesCount) stonesCount.textContent = stones.length;
        }
        
        function drawStone(stone) {
            stonesCtx.save();
            stonesCtx.translate(stone.x, stone.y);
            stonesCtx.scale(stone.scaleX || 1, stone.scaleY || 1); // Apply scaling for stretched shapes (no rotation)
            
            stonesCtx.fillStyle = stone.color;
            stonesCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            stonesCtx.lineWidth = 2;
            
            stonesCtx.beginPath();
            
            if (stone.shape === 'circle') {
                stonesCtx.arc(0, 0, stone.size, 0, Math.PI * 2);
            } else if (stone.shape === 'square') {
                stonesCtx.rect(-stone.size, -stone.size, stone.size * 2, stone.size * 2);
            } else if (stone.shape === 'triangle') {
                stonesCtx.moveTo(0, -stone.size);
                stonesCtx.lineTo(-stone.size * 0.866, stone.size * 0.5);
                stonesCtx.lineTo(stone.size * 0.866, stone.size * 0.5);
                stonesCtx.closePath();
            } else if (stone.shape === 'irregular') {
                // Draw irregular polygon with random variations
                const sides = 5 + Math.floor(Math.random() * 6); // 5-10 sides
                const seed = stone.x * 1000 + stone.y; // Use position as seed for consistency
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const radiusVariation = 0.5 + ((seed + i * 137) % 50) / 100; // 0.5 to 1.0
                    const radius = stone.size * radiusVariation;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) {
                        stonesCtx.moveTo(x, y);
                } else {
                        stonesCtx.lineTo(x, y);
                    }
                }
                stonesCtx.closePath();
            }
            
            stonesCtx.fill();
            stonesCtx.stroke();
            stonesCtx.restore();
        }
        
        function handleStonesMouseDown(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            // Check if clicking on a stone
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesMouseMove(e) {
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = e.clientX - rect.left;
            stonesMousePos.y = e.clientY - rect.top;
            
            if (draggedStone) {
                // Update position directly while dragging
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesMouseUp() {
            if (draggedStone) {
                // Calculate velocity based on movement while dragging
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                const dt = 0.016; // Approximate frame time
                
                // Set velocity based on drag distance and direction (throwing) - reduced power
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function handleStonesTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                const dist = Math.sqrt(Math.pow(stonesMousePos.x - stone.x, 2) + Math.pow(stonesMousePos.y - stone.y, 2));
                const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                if (dist < collisionRadius * 1.5) {
                    draggedStone = stone;
                    stone.dragged = true;
                    stone.vx = 0;
                    stone.vy = 0;
                    dragStartPos.x = stonesMousePos.x;
                    dragStartPos.y = stonesMousePos.y;
                    stone.lastX = stone.x;
                    stone.lastY = stone.y;
                    break;
                }
            }
        }
        
        function handleStonesTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = stonesCanvas.getBoundingClientRect();
            lastMousePos.x = stonesMousePos.x;
            lastMousePos.y = stonesMousePos.y;
            stonesMousePos.x = touch.clientX - rect.left;
            stonesMousePos.y = touch.clientY - rect.top;
            
            if (draggedStone) {
                draggedStone.x = stonesMousePos.x;
                draggedStone.y = stonesMousePos.y;
            }
        }
        
        function handleStonesTouchEnd() {
            if (draggedStone) {
                const dx = stonesMousePos.x - dragStartPos.x;
                const dy = stonesMousePos.y - dragStartPos.y;
                
                draggedStone.vx = (stonesMousePos.x - lastMousePos.x) * 8; // Reduced from 20 to 8
                draggedStone.vy = (stonesMousePos.y - lastMousePos.y) * 8;
                
                draggedStone.dragged = false;
                draggedStone = null;
            }
        }
        
        function animateStones() {
            // Clear canvas with water/shore background
            const gradient = stonesCtx.createLinearGradient(0, 0, 0, stonesCanvas.height);
            gradient.addColorStop(0, '#4682B4'); // Sky blue (water)
            gradient.addColorStop(0.6, '#5F9EA0'); // Cadet blue (shallow water)
            gradient.addColorStop(0.6, '#D2B48C'); // Tan (shore)
            gradient.addColorStop(1, '#CD853F'); // Peru (sand)
            stonesCtx.fillStyle = gradient;
            stonesCtx.fillRect(0, 0, stonesCanvas.width, stonesCanvas.height);
            
            // Update and draw stones
            for (let i = stones.length - 1; i >= 0; i--) {
                const stone = stones[i];
                
                if (!stone.dragged) {
                    // Physics
                    stone.vy += 0.2; // Gravity
                    stone.vx *= 0.98; // Air resistance
                    stone.vy *= 0.98;
                    
                    stone.x += stone.vx;
                    stone.y += stone.vy;
                    
                    // Collision with ground (shore)
                    const shoreLevel = stonesCanvas.height * 0.6;
                    const collisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                    if (stone.y > shoreLevel - collisionRadius) {
                        stone.y = shoreLevel - collisionRadius;
                        stone.vy *= -0.5; // Bounce
                        stone.vx *= 0.7; // Friction
                        if (Math.abs(stone.vy) < 0.5) {
                            stone.vy = 0;
                        }
                    }
                    
                    // Collision with walls
                    if (stone.x < collisionRadius || stone.x > stonesCanvas.width - collisionRadius) {
                        stone.vx *= -0.7;
                        stone.x = Math.max(collisionRadius, Math.min(stonesCanvas.width - collisionRadius, stone.x));
                    }
                }
                
                // Collision with other stones
                for (let j = 0; j < stones.length; j++) {
                    if (i !== j) {
                        const other = stones[j];
                        const dx = stone.x - other.x;
                        const dy = stone.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const stoneCollisionRadius = stone.collisionRadius || (stone.size * Math.max(stone.scaleX || 1, stone.scaleY || 1));
                        const otherCollisionRadius = other.collisionRadius || (other.size * Math.max(other.scaleX || 1, other.scaleY || 1));
                        const minDist = stoneCollisionRadius + otherCollisionRadius;
                        
                        if (dist < minDist && dist > 0) {
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDist - dist;
                            
                            // Push apart based on mass
                            const totalMass = stone.mass + other.mass;
                            const stonePush = (other.mass / totalMass) * overlap;
                            const otherPush = (stone.mass / totalMass) * overlap;
                            
                            // Only move non-dragged stones
                            if (!stone.dragged) {
                                stone.x += Math.cos(angle) * stonePush;
                                stone.y += Math.sin(angle) * stonePush;
                            }
                            if (!other.dragged) {
                                other.x -= Math.cos(angle) * otherPush;
                                other.y -= Math.sin(angle) * otherPush;
                    } else {
                                // If other is dragged, push the dragged stone back a bit
                                stone.x += Math.cos(angle) * stonePush * 0.3;
                                stone.y += Math.sin(angle) * stonePush * 0.3;
                            }
                            
                            // Bounce for non-dragged stones
                            if (!stone.dragged && !other.dragged) {
                                const relativeVx = stone.vx - other.vx;
                                const relativeVy = stone.vy - other.vy;
                                const dot = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                                
                                stone.vx -= Math.cos(angle) * dot * 0.6;
                                stone.vy -= Math.sin(angle) * dot * 0.6;
                                other.vx += Math.cos(angle) * dot * 0.6;
                                other.vy += Math.sin(angle) * dot * 0.6;
                            }
                        }
                    }
                }
                
                drawStone(stone);
            }
            
            stonesAnimationId = requestAnimationFrame(animateStones);
        }
        
        // Clicker game
        function clickMoney() {
            addMoney(clickerPerClick);
            // Button animation
            const btn = document.getElementById('clicker-button');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                }, 100);
            }
        }
        
        // Coinflip game
        let coinflipStreak = 0;
        let isCoinFlipping = false;
        let winChanceUpgrades = 0; // Number of upgrades purchased
        const BASE_WIN_CHANCE = 50; // Base 50% chance
        
        // Load saved data
        function loadCoinflipData() {
            const saved = localStorage.getItem('coinflipData');
            if (saved) {
                const data = JSON.parse(saved);
                winChanceUpgrades = data.upgrades || 0;
                coinflipStreak = data.streak || 0;
            }
            updateAllMoneyDisplays();
            updateWinChanceDisplay();
        }
        
        // Save data
        function saveCoinflipData() {
            localStorage.setItem('coinflipData', JSON.stringify({
                upgrades: winChanceUpgrades,
                streak: coinflipStreak
            }));
        }
        
        // Calculate win chance
        function getWinChance() {
            return Math.min(BASE_WIN_CHANCE + winChanceUpgrades, 99); // Cap at 99%
        }
        
        // Update win chance display
        function updateWinChanceDisplay() {
            const winChancePercent = document.getElementById('win-chance-percent');
            const chance = getWinChance();
            if (winChancePercent) winChancePercent.textContent = chance;
            if (shopWinChance) shopWinChance.textContent = chance;
        }
        
        function resetCoinFlip() {
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            
            loadCoinflipData(); // Reload data when page is shown
            
            if (coin) {
                coin.style.transform = 'rotateY(0deg)';
                coin.classList.remove('coin-flipping');
            }
            if (result) {
                result.textContent = '';
            }
            if (streakCount) {
                streakCount.textContent = coinflipStreak;
            }
            
            // Enable buttons
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            if (headsBtn) headsBtn.disabled = false;
            if (tailsBtn) tailsBtn.disabled = false;
        }
        
        function guessCoin(guess) {
            if (isCoinFlipping) return;
            
            isCoinFlipping = true;
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinflip-result');
            const streakCount = document.getElementById('streak-count');
            const headsBtn = document.getElementById('heads-btn');
            const tailsBtn = document.getElementById('tails-btn');
            
            // Disable buttons
            if (headsBtn) headsBtn.disabled = true;
            if (tailsBtn) tailsBtn.disabled = true;
            
            // Add flipping animation
            coin.classList.add('coin-flipping');
            
            // Calculate win chance
            const winChance = getWinChance() / 100;
            const isCorrect = Math.random() < winChance;
            
            // Determine result (if we win, the coin lands on our guess, otherwise opposite)
            const isHeads = isCorrect ? (guess === 'heads') : (guess === 'tails');
            const resultText = isHeads ? 'Heads' : 'Tails';
            
            // Set final rotation
            setTimeout(() => {
                coin.classList.remove('coin-flipping');
                coin.style.transform = isHeads ? 'rotateY(0deg)' : 'rotateY(180deg)';
                
                if (isCorrect) {
                    coinflipStreak++;
                    // Calculate reward: base 2x multiplier, +0.5x per streak
                    // Base reward is $10, multiplied by (2 + streak * 0.5)
                    const multiplier = 2 + (coinflipStreak * 0.5);
                    const baseReward = 10;
                    const reward = Math.floor(baseReward * multiplier);
                    
                    addMoney(reward);
                    
                    if (result) {
                        result.textContent = `âœ… Correct! It's ${resultText}! +$${reward} (${multiplier.toFixed(1)}x)`;
                        result.style.color = '#3fb950';
                        }
                } else {
                    coinflipStreak = 0;
                    if (result) {
                        result.textContent = `âŒ Wrong! It was ${resultText}`;
                        result.style.color = '#f85149';
                    }
                }
                
                if (streakCount) {
                    streakCount.textContent = coinflipStreak;
                }
                
                saveCoinflipData();
                
                // Re-enable buttons after a delay
                setTimeout(() => {
                    isCoinFlipping = false;
                    if (headsBtn) headsBtn.disabled = false;
                    if (tailsBtn) tailsBtn.disabled = false;
                }, 500);
            }, 1000);
        }
        
        // Shop functions
        function getUpgradeCost(upgradeLevel) {
            return 20 * Math.pow(2, upgradeLevel);
        }
        
        function showShop() {
            showPage('shopPage');
            loadCoinflipData();
            renderShop();
        }
        
        function closeShop() {
            showPage('mainPage');
        }
        
        function buyUpgrade() {
            const cost = getUpgradeCost(winChanceUpgrades);
            if (spendMoney(cost)) {
                winChanceUpgrades++;
                updateWinChanceDisplay();
                saveCoinflipData();
                renderShop();
            }
        }
        
        function buyColor(colorName) {
            const cost = colorCosts[colorName];
            if (cost && spendMoney(cost)) {
                unlockedColors.add(colorName);
                saveGlobalData();
                renderShop();
            }
        }
        
        function buyClickerUpgrade() {
            const cost = clickerPerClick * 10;
            if (spendMoney(cost)) {
                clickerPerClick++;
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
                saveGlobalData();
                renderShop();
            }
        }
        
        function renderShop() {
            const container = document.getElementById('upgrade-container');
            if (!container) return;
            
            let html = '';
            
            // Win Chance Upgrade
            const winChanceCost = getUpgradeCost(winChanceUpgrades);
            const canAffordWinChance = globalMoney >= winChanceCost;
            const nextChance = Math.min(getWinChance() + 1, 99);
            html += `
                <div class="upgrade-item">
                    <h3>Win Chance Upgrade</h3>
                    <p>Increase your win chance by +1%</p>
                    <p>Current: ${getWinChance()}% â†’ Next: ${nextChance}%</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${winChanceCost}</p>
                    <button class="upgrade-btn" onclick="buyUpgrade()" ${!canAffordWinChance ? 'disabled' : ''}>
                        ${canAffordWinChance ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Clicker Upgrade
            const clickerCost = clickerPerClick * 10;
            const canAffordClicker = globalMoney >= clickerCost;
            html += `
                <div class="upgrade-item">
                    <h3>Clicker Upgrade</h3>
                    <p>Increase money per click by +$1</p>
                    <p>Current: $${clickerPerClick} â†’ Next: $${clickerPerClick + 1}</p>
                    <p style="color: #ffd700; font-weight: bold;">Cost: $${clickerCost}</p>
                    <button class="upgrade-btn" onclick="buyClickerUpgrade()" ${!canAffordClicker ? 'disabled' : ''}>
                        ${canAffordClicker ? 'Buy Upgrade' : 'Not Enough Money'}
                    </button>
                </div>
            `;
            
            // Colors section
            html += `<div class="upgrade-item" style="margin-top: 30px;"><h3>Colors</h3>`;
            Object.keys(colorPalettes).forEach(colorName => {
                const cost = colorCosts[colorName];
                const isUnlocked = unlockedColors.has(colorName);
                const canAfford = globalMoney >= cost;
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: ${isUnlocked ? '#3fb950' : '#8b949e'}; text-transform: capitalize;">${colorName}</strong>
                            ${isUnlocked ? '<span style="color: #3fb950; margin-left: 10px;">âœ“ Unlocked</span>' : ''}
                        </div>
                        ${!isUnlocked ? `
                            <button class="upgrade-btn" onclick="buyColor('${colorName}')" ${!canAfford ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                                ${canAfford ? `Buy ($${cost})` : `$${cost}`}
                            </button>
                        ` : ''}
                    </div>
                `;
            });
            // Rainbow color
            const rainbowCost = colorCosts['rainbow'];
            const rainbowUnlocked = unlockedColors.has('rainbow');
            const canAffordRainbow = globalMoney >= rainbowCost;
            html += `
                <div style="margin: 10px 0; padding: 10px; background: #21262d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: ${rainbowUnlocked ? '#3fb950' : '#8b949e'};">Rainbow</strong>
                        ${rainbowUnlocked ? '<span style="color: #3fb950; margin-left: 10px;">âœ“ Unlocked</span>' : ''}
                    </div>
                    ${!rainbowUnlocked ? `
                        <button class="upgrade-btn" onclick="buyColor('rainbow')" ${!canAffordRainbow ? 'disabled' : ''} style="padding: 6px 12px; font-size: 14px;">
                            ${canAffordRainbow ? `Buy ($${rainbowCost})` : `$${rainbowCost}`}
                        </button>
                    ` : ''}
                </div>
            `;
            html += `</div>`;
            
            container.innerHTML = html;
        }
        
        // Blocking system
        function checkBlocked() {
            if (localStorage.getItem('isBlocked') === 'true') {
                showPage('limboPage');
                const commandBar = document.querySelector('.command-bar');
                if (commandBar) commandBar.style.display = 'none';
                return true;
            }
            return false;
        }
        
        function unblock() {
            localStorage.removeItem('isBlocked');
            localStorage.removeItem('count67');
            showPage('mainPage');
            const commandBar = document.querySelector('.command-bar');
            if (commandBar) commandBar.style.display = 'flex';
        }
        
        // Password check function for limbo page
        function checkLimboPassword() {
            const passwordInput = document.getElementById('limboPasswordInput');
            const errorEl = document.getElementById('limboError');
            
            if (!passwordInput) return;
            
            const password = passwordInput.value.trim();
            
            if (password === 'OG') {
                // Correct password - unblock
                unblock();
                if (passwordInput) passwordInput.value = '';
                if (errorEl) errorEl.textContent = '';
                } else {
                // Wrong password
                if (errorEl) errorEl.textContent = 'Incorrect password!';
                if (passwordInput) passwordInput.value = '';
                setTimeout(() => {
                    if (errorEl) errorEl.textContent = '';
                }, 2000);
            }
        }
        
        // Allow Enter key to submit password
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('limboPasswordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        checkLimboPassword();
                    }
                });
            }
        });
        
        // Initialize everything on page load - ensure proper order
        function initializeOnLoad() {
            // Clean up any existing handlers first to prevent duplicates
            try {
                if (typeof matrixKeyHandler !== 'undefined' && matrixKeyHandler) {
                    document.removeEventListener('keydown', matrixKeyHandler);
                    matrixKeyHandler = null;
                }
                if (typeof fireworkKeyHandler !== 'undefined' && fireworkKeyHandler) {
                    document.removeEventListener('keydown', fireworkKeyHandler);
                    fireworkKeyHandler = null;
                }
                if (typeof pirateClickHandler !== 'undefined' && pirateClickHandler) {
                    document.removeEventListener('click', pirateClickHandler);
                    pirateClickHandler = null;
                }
                if (typeof minecraftKeyHandler !== 'undefined' && minecraftKeyHandler) {
                    document.removeEventListener('keydown', minecraftKeyHandler);
                    minecraftKeyHandler = null;
                }
            } catch (e) {
                console.error('Error cleaning up handlers:', e);
            }
            
            // Clean up any existing theme elements
            try {
                if (typeof cleanupMatrixColumns === 'function') cleanupMatrixColumns();
                if (typeof cleanupFireworks === 'function') cleanupFireworks();
                if (typeof cleanupPirateCannonballs === 'function') cleanupPirateCannonballs();
                if (typeof cleanupPaperDrawing === 'function') cleanupPaperDrawing();
                if (typeof cleanupSpaceStars === 'function') cleanupSpaceStars();
                if (typeof cleanupOceanFish === 'function') cleanupOceanFish();
            } catch (e) {
                console.error('Error cleaning up theme elements:', e);
            }
            
            // Load data
            try {
                if (typeof loadGlobalData === 'function') loadGlobalData();
                if (typeof loadCoinflipData === 'function') loadCoinflipData();
            } catch (e) {
                console.error('Error loading data:', e);
            }
            
            // Load and apply theme (this will set up handlers properly)
            try {
                if (typeof loadTheme === 'function') {
                    loadTheme();
                    
                    // Load background preferences after theme is loaded
                    setTimeout(() => {
                        if (typeof loadBackgroundPreferences === 'function') {
                            loadBackgroundPreferences();
                        }
                    }, 50);
                }
            } catch (e) {
                console.error('Error loading theme:', e);
            }
            
            // Initialize remote desktop if needed
            try {
                if (typeof initRemoteDesktop === 'function' && document.getElementById('remoteDesktop')) {
                    initRemoteDesktop();
                }
            } catch (e) {
                console.error('Error initializing remote desktop:', e);
            }
            
            // Ensure command bar is visible (unless on remote desktop or blocked)
            try {
                const commandBar = document.querySelector('.command-bar');
                if (commandBar) {
                    const currentPage = document.querySelector('.page:not(.hidden)');
                    const isRemoteDesktop = currentPage && currentPage.id === 'remoteDesktopPage';
                    const isBlocked = localStorage.getItem('isBlocked') === 'true';
                    if (!isRemoteDesktop && !isBlocked) {
                        commandBar.style.display = 'flex';
                    }
                }
            } catch (e) {
                console.error('Error showing command bar:', e);
            }
        }
        
        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeOnLoad);
        } else {
            // DOM already loaded
            initializeOnLoad();
        }
        
        // Check if blocked on page load
        if (checkBlocked()) {
            // Already showing limbo page
        }
        
        // Update clicker display
        const clickerAmount = document.getElementById('clicker-amount');
        if (clickerAmount) clickerAmount.textContent = clickerPerClick;
        
        // Achievements system
        const TOTAL_ACHIEVEMENTS = 256;
        let foundAchievements = new Set();
        
        // Achievement data - only name, emoji, and description
        const achievementData = [
            { id: 0, name: "Welcome", emoji: "ðŸ‘‹", desc: "Visit the site for the first time" },
            { id: 1, name: "Explorer", emoji: "ðŸ—ºï¸", desc: "Visit the home page" },
            { id: 2, name: "Color Master", emoji: "ðŸŽ¨", desc: "Change colors 10 times" },
            { id: 3, name: "Rainbow", emoji: "ðŸŒˆ", desc: "Apply rainbow colors" },
            { id: 4, name: "Sweeper Pro", emoji: "ðŸ’£", desc: "Win a game of Minesweeper" },
            { id: 5, name: "Pong Champion", emoji: "ðŸ“", desc: "Play Pong" },
            { id: 6, name: "Coinflip Streak", emoji: "ðŸª™", desc: "Get a 5 streak in coinflip" },
            { id: 7, name: "Rich", emoji: "ðŸ’°", desc: "Earn $100 in coinflip" },
            { id: 8, name: "Lucky", emoji: "ðŸ€", desc: "Win 10 coinflips in a row" },
            { id: 9, name: "Upgrade Master", emoji: "â¬†ï¸", desc: "Buy 5 upgrades in the shop" },
            { id: 10, name: "Sandbox", emoji: "ðŸ—ï¸", desc: "Open Sandboxels" },
            { id: 11, name: "Commander", emoji: "ðŸŽ®", desc: "Use 10 different commands" },
            // Add more achievements with placeholders...
        ];
        
        // Generate placeholder achievements for the remaining slots
        for (let i = achievementData.length; i < TOTAL_ACHIEVEMENTS; i++) {
            const emojis = ["â­", "ðŸŽ¯", "ðŸ†", "ðŸ”¥", "ðŸ’Ž", "ðŸš€", "ðŸŽª", "ðŸŽ­", "ðŸŽ¸", "ðŸŽ¬", "ðŸŽ²", "ðŸŽ´", "ðŸŽ¨", "ðŸŽ­", "ðŸŽª", "ðŸŽ¯"];
            achievementData.push({
                id: i,
                name: `Achievement ${i + 1}`,
                emoji: emojis[i % emojis.length],
                desc: `Mystery achievement #${i + 1} - discover to find out more!`
            });
        }
        
        // Load found achievements from localStorage
        function loadAchievements() {
            const saved = localStorage.getItem('achievements');
            if (saved) {
                foundAchievements = new Set(JSON.parse(saved));
                    } else {
                // First visit - unlock welcome achievement
                unlockAchievement(0);
            }
            updateAchievementStats();
        }
        
        // Save achievements to localStorage
        function saveAchievements() {
            localStorage.setItem('achievements', JSON.stringify(Array.from(foundAchievements)));
            updateAchievementStats();
        }
        
        // Unlock an achievement
        function unlockAchievement(id) {
            if (!foundAchievements.has(id)) {
                foundAchievements.add(id);
                saveAchievements();
                renderAchievements();
            }
        }
        
        // Update achievement statistics
        function updateAchievementStats() {
            const foundCount = document.getElementById('found-count');
            const totalCount = document.getElementById('total-count');
            if (foundCount) foundCount.textContent = foundAchievements.size;
            if (totalCount) totalCount.textContent = TOTAL_ACHIEVEMENTS;
        }
        
        // Generate 16x16 pixel art patterns for achievements
        function generatePixelPattern(achievementId) {
            const patterns = {
                0: (() => {
                    // Welcome - smiley face
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 3 && x <= 12 && y >= 3 && y <= 10) p[i] = '#FFA500'; // Face
                            if ((x === 5 || x === 10) && (y === 5 || y === 6)) p[i] = '#000000'; // Eyes
                            if (x >= 6 && x <= 9 && y === 9) p[i] = '#000000'; // Mouth
                        }
                    }
                    return p;
                })(),
                1: (() => {
                    // Explorer - compass
                    const p = Array(256).fill('#000000');
                    const center = 8;
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - center;
                            const dy = y - center;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= 6) p[i] = '#C0C0C0';
                            if (dist <= 5) p[i] = '#808080';
                            if ((x === center || y === center) && dist <= 7) p[i] = '#FFD700';
                        }
                    }
                    return p;
                })(),
                2: (() => {
                    // Color Master - palette
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 2 && x <= 13 && y >= 2 && y <= 13) {
                                const section = Math.floor((x - 2) / 3);
                                const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                                p[i] = colors[section % 4];
                            }
                        }
                    }
                    return p;
                })(),
                4: (() => {
                    // Sweeper Pro - bomb
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 36) p[i] = '#333333';
                            if (dx*dx + dy*dy <= 25) p[i] = '#000000';
                            if (x >= 7 && x <= 9 && y >= 2 && y <= 5) p[i] = '#FF0000';
                        }
                    }
                    return p;
                })(),
                5: (() => {
                    // Pong Champion - paddle
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 13) p[i] = '#FFFFFF';
                            if (x === 7 || x === 8) {
                                if (y >= 4 && y <= 6) p[i] = '#000000';
                                if (y >= 9 && y <= 11) p[i] = '#000000';
                            }
                        }
                    }
                    return p;
                })(),
                6: (() => {
                    // Coinflip Streak - coin
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            const dx = x - 8;
                            const dy = y - 8;
                            if (dx*dx + dy*dy <= 49) p[i] = '#FFD700';
                            if (dx*dx + dy*dy <= 42) p[i] = '#FFA500';
                            if (x === 8 && y >= 3 && y <= 12) p[i] = '#000000';
                        }
                    }
                    return p;
                })(),
                7: (() => {
                    // Rich - money bag
                    const p = Array(256).fill('#000000');
                    for (let y = 0; y < 16; y++) {
                        for (let x = 0; x < 16; x++) {
                            const i = y * 16 + x;
                            if (x >= 4 && x <= 11 && y >= 4 && y <= 12) p[i] = '#00AA00';
                            if (x >= 5 && x <= 10 && y >= 5 && y <= 11) p[i] = '#008800';
                            if (x >= 6 && x <= 9 && y >= 2 && y <= 4) p[i] = '#888888';
                            if (x === 7 || x === 8) {
                                if (y === 6 || y === 8 || y === 10) p[i] = '#FFD700';
                            }
                        }
                    }
                    return p;
                })(),
            };
            
            // Use specific pattern or generate unique one
            if (patterns[achievementId]) {
                return patterns[achievementId];
            }
            
            // Generate unique pattern for each achievement
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#FF69B4', '#00FF7F'];
            const seed = achievementId * 137; // Unique seed per achievement
            return Array(256).fill(0).map((_, i) => {
                const x = i % 16;
                const y = Math.floor(i / 16);
                const hash = ((x * seed + y) * 17) % 100;
                if (hash < 30) return colors[achievementId % colors.length];
                if (hash < 50) return colors[(achievementId * 3) % colors.length];
                if (hash < 60) return colors[(achievementId * 7) % colors.length];
                return '#202020';
            });
        }
        
        // Render achievements grid
        function renderAchievements() {
            const grid = document.getElementById('achievements-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            for (let i = 0; i < TOTAL_ACHIEVEMENTS; i++) {
                const achievement = achievementData[i];
                const isFound = foundAchievements.has(i);
                
                const sprite = document.createElement('div');
                sprite.className = `achievement-sprite ${isFound ? 'found' : ''}`;
                sprite.dataset.id = i;
                
                // Create pixel sprite
                const pixelPattern = generatePixelPattern(i);
                for (let j = 0; j < 256; j++) {
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.backgroundColor = pixelPattern[j];
                    sprite.appendChild(pixel);
                }
                
                // Tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'tooltip-name';
                nameSpan.textContent = achievement.name;
                tooltip.appendChild(nameSpan);
                
                if (isFound) {
                    const descSpan = document.createElement('span');
                    descSpan.className = 'tooltip-desc';
                    descSpan.textContent = achievement.desc;
                    tooltip.appendChild(descSpan);
                }
                
                sprite.appendChild(tooltip);
                grid.appendChild(sprite);
            }
            
            updateAchievementStats();
        }
        
        // Initialize achievements on page load
        loadAchievements();
        
        // Achievement triggers
        let colorChangeCount = 0;
        let commandsUsed = new Set();
        
        // Override changeAllColors to track achievements
        const originalChangeAllColors = changeAllColors;
        changeAllColors = function(colorName) {
            originalChangeAllColors(colorName);
            colorChangeCount++;
            if (colorChangeCount >= 10) unlockAchievement(2);
            
            if (colorName === 'rainbow') {
                unlockAchievement(3);
            }
        };
        
        // Track navigation for achievements - override showPage
        const originalShowPageForAchievements = showPage;
        showPage = function(pageId) {
            originalShowPageForAchievements(pageId);
            
            // Stop goose rain animation if leaving
            if (pageId !== 'gooserainPage' && animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Stop stones animation if leaving
            if (pageId !== 'stonesPage' && stonesAnimationId) {
                cancelAnimationFrame(stonesAnimationId);
                stonesAnimationId = null;
                // Remove key handler when leaving
                if (stonesKeyHandler) {
                    document.removeEventListener('keydown', stonesKeyHandler);
                    stonesKeyHandler = null;
                }
            }
            
            // Update money displays on page change
            updateAllMoneyDisplays();
            
            if (pageId === 'homePage') {
                unlockAchievement(1);
            } else if (pageId === 'minesweeperPage') {
                commandsUsed.add('sweeper');
            } else if (pageId === 'pongPage') {
                unlockAchievement(5);
                commandsUsed.add('pong');
            } else if (pageId === 'sandboxelsPage') {
                unlockAchievement(10);
                commandsUsed.add('sandboxles');
            } else if (pageId === 'coinflipPage') {
                commandsUsed.add('coinflip');
            } else if (pageId === 'clickerPage') {
                commandsUsed.add('clicker');
                const clickerAmount = document.getElementById('clicker-amount');
                if (clickerAmount) clickerAmount.textContent = clickerPerClick;
            } else if (pageId === 'stonesPage') {
                commandsUsed.add('stones');
            }
            
            if (commandsUsed.size >= 10) {
                unlockAchievement(11);
            }
        };
        
        // Track Minesweeper win
        const originalGameOver = gameOver;
        gameOver = function(win) {
            originalGameOver(win);
            if (win) {
                unlockAchievement(4);
            }
        };
        
        // Track coinflip achievements - hook into guessCoin function
        let coinflipWins = 0;
        const originalGuessCoinFunc = guessCoin;
        guessCoin = function(guess) {
            const oldStreak = coinflipStreak;
            originalGuessCoinFunc(guess);
            
            // Check achievements after the coin flip completes
            setTimeout(() => {
                if (coinflipStreak > oldStreak) {
                    coinflipWins++;
                    if (coinflipStreak >= 5) unlockAchievement(6);
                    if (coinflipWins >= 10 && coinflipStreak >= 10) unlockAchievement(8);
                }
                
                if (globalMoney >= 100) unlockAchievement(7);
            }, 1500);
        };
        
        // Track shop upgrades - hook into buyUpgrade function
        const originalBuyUpgradeFunc = buyUpgrade;
        buyUpgrade = function() {
            originalBuyUpgradeFunc();
            setTimeout(() => {
                if (winChanceUpgrades >= 5) {
                    unlockAchievement(9);
                }
            }, 100);
        };
        
        // Changelog system
        function loadChangelog() {
            const changelogContent = document.getElementById('changelog-content');
            if (!changelogContent) return;
            
            const changelog = getChangelogEntries();
            let html = '';
            
            // Sort by date (newest first)
            const sortedChangelog = changelog.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            sortedChangelog.forEach(entry => {
                html += `
                    <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #30363d;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h3 style="color: #58a6ff; font-size: 18px; margin: 0;">${entry.title}</h3>
                            <span style="color: #8b949e; font-size: 12px;">${entry.date}</span>
                        </div>
                        <p style="color: #c9d1d9; font-size: 14px; margin: 5px 0;">${entry.description}</p>
                        ${entry.userRequest ? `<p style="color: #8b949e; font-size: 12px; font-style: italic; margin-top: 5px;">User Request: "${entry.userRequest}"</p>` : ''}
                    </div>
                `;
            });
            
            changelogContent.innerHTML = html || '<p style="color: #8b949e;">No changelog entries yet.</p>';
        }
        
        function getChangelogEntries() {
            const saved = localStorage.getItem('changelog');
            if (saved) {
                const entries = JSON.parse(saved);
                // Check if Block Breaker entry already exists
                const hasBlockBreaker = entries.some(e => e.title && e.title.includes('Block Breaker'));
                if (!hasBlockBreaker) {
                    // Add Block Breaker entry
                    entries.push({
                        date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                        title: 'ðŸ§± Added Block Breaker Game to Desktop',
                        description: 'Added a classic Block Breaker (Breakout) game to the Remote Desktop App Store. Break all the blocks using the paddle to bounce the ball. Features 5 rows of colored blocks, 3 lives, and score tracking. Install it from the App Store in Remote Desktop, then double-click the Block Breaker icon to play. Use mouse or arrow keys to control the paddle.',
                        userRequest: 'add block breaker as a app'
                    });
                    localStorage.setItem('changelog', JSON.stringify(entries));
                }
                // Check if Chatbot entry already exists
                const hasChatbot = entries.some(e => e.title && e.title.includes('Chatbot'));
                const hasBlockBreakerUpdate = entries.some(e => e.title && e.title.includes('Block Breaker improvements'));
                const hasPasswordGame = entries.some(e => e.title && e.title.includes('Password Game'));
                const hasSuggestions = entries.some(e => e.title && e.title.includes('Suggestions'));
                if (!hasChatbot || !hasBlockBreakerUpdate || !hasPasswordGame || !hasSuggestions) {
                    // Add Block Breaker improvements
                    if (!hasBlockBreakerUpdate) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ”§ Block Breaker Game Improvements',
                            description: 'Made the ball slower (speed reduced from 4 to 2) and more visible (increased size from 8 to 12 pixels, changed color to bright yellow with white border). The ball is now easier to track and control.',
                            userRequest: 'make the ball slower and I cant see the ball mover'
                        });
                    }
                    // Add Chatbot entry
                    if (!hasChatbot) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ¤– Added Chatbot App to Desktop',
                            description: 'Added a Chatbot app to the Remote Desktop App Store. The chatbot responds to every message with "sorry i dont understand mabey try again later". Install it from the App Store in Remote Desktop, then double-click the Chatbot icon to chat.',
                            userRequest: 'make another one thats called chatbot and every time it responds by saying sorry i dont understand mabey try again later'
                        });
                    }
                    // Check for Chatbot AI update
                    const hasChatbotAI = entries.some(e => e.title && e.title.includes('Chatbot AI'));
                    const hasChatbotEnhancement = entries.some(e => e.title && e.title.includes('Enhanced Chatbot') && e.title.includes('Jokes'));
                    if (!hasChatbotAI) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ§  Improved Chatbot with AI Responses',
                            description: 'Enhanced the Chatbot with intelligent responses! The chatbot can now handle greetings, questions (what, who, why, how), simple math, jokes, facts, and general conversation. It provides contextually appropriate responses while staying simple and helpful.',
                            userRequest: 'make the chatbot a bit ai but you dont need it to be smart like pretty good though'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    if (!hasChatbotEnhancement) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸŽ­ Enhanced Chatbot with More Jokes, Facts & Definitions',
                            description: 'Significantly expanded the chatbot\'s knowledge! Added 20+ jokes (programming, science, and general humor), 23+ fun facts (science, nature, technology), and a dictionary with 40+ definitions for common computer and technology terms. The chatbot now responds to "tell me a joke", "fun fact", "what does X mean", and "define X".',
                            userRequest: 'make chatbot smarter like if you ask a joke or a fun fact and definitions'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    // Check for Block Breaker paddle fix
                    const hasPaddleFix = entries.some(e => e.title && e.title.includes('Block Breaker') && e.title.includes('Paddle'));
                    if (!hasPaddleFix) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ§± Block Breaker Paddle Visibility Fix',
                            description: 'Fixed Block Breaker paddle visibility! The paddle is now bright green with white borders and inner highlights, positioned higher up on the canvas for better visibility. The ball is also brighter yellow with a white border for better visibility.',
                            userRequest: 'expain block breakers view and remove table tennis'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for Table Tennis removal
                    const hasTableTennisRemoval = entries.some(e => e.title && e.title.includes('Table Tennis') && e.title.includes('Removed'));
                    if (!hasTableTennisRemoval) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ—‘ï¸ Table Tennis Game Removed',
                            description: 'Removed Table Tennis game from the App Store and desktop. The game has been completely removed as requested.',
                            userRequest: 'remove table tennis'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for Minesweeper timer & leaderboard
                    const hasMinesweeperTimer = entries.some(e => e.title && e.title.includes('Minesweeper') && e.title.includes('Timer'));
                    if (!hasMinesweeperTimer) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'â±ï¸ Minesweeper Timer & Leaderboard',
                            description: 'Added timer to Minesweeper! The timer starts on your first click and stops when you win or lose. Completed games are saved to a Firebase leaderboard showing the best times. View the leaderboard by clicking the "Leaderboard" button in Minesweeper.',
                            userRequest: 'add a timer in minesweeper with a leaderboard'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for Password Game multiplayer
                    const hasPasswordMultiplayer = entries.some(e => e.title && e.title.includes('Password Game') && e.title.includes('Multiplayer'));
                    if (!hasPasswordMultiplayer) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ” Password Game Multiplayer Mode',
                            description: 'Added multiplayer mode to Password Game! Click "Multiplayer Mode" to create or join lobbies. In multiplayer: one player (host) picks a 5-letter word, and another player (guesser) tries to guess it. Uses Firebase for real-time synchronization between players.',
                            userRequest: 'add a multiplayermode in password game where 1 person picks the word and another person guesses where you can join lobbies'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for Paint v2 multiplayer
                    const hasPaintV2 = entries.some(e => e.title && e.title.includes('Paint v2'));
                    if (!hasPaintV2) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸŽ¨ Paint v2 Multiplayer Drawing',
                            description: 'Added Paint v2 multiplayer to the App Store! Draw with others in real-time by joining or creating lobbies. All players can see each other\'s drawings instantly. Features color picker, clear button, and Firebase real-time synchronization. Install it from the App Store in Remote Desktop!',
                            userRequest: 'add paint v2 in the shop were you can draw with others if you join there lobby'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for GIF Maker
                    const hasGifMaker = entries.some(e => e.title && e.title.includes('GIF Maker'));
                    if (!hasGifMaker) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸŽ¬ GIF Maker - Simple Animation Tool',
                            description: 'Added GIF Maker to the App Store! Create simple animations by drawing frames. Features include: draw on canvas, add frames, preview animation, and download frames as images. Perfect for creating simple animated GIFs frame by frame. Install it from the App Store in Remote Desktop!',
                            userRequest: 'do the GIF maker â€” simple animation tool'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    
                    // Check for Party command and minigames
                    const hasParty = entries.some(e => e.title && e.title.includes('Party') && e.title.includes('Minigames'));
                    if (!hasParty) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸŽ‰ Party Command with Minigames',
                            description: 'Added "party" command that opens a GUI with minigames! Currently includes "Draw Together" - a collaborative drawing minigame where friends can draw together in real-time using Firebase. Create or join lobbies to play with friends. More minigames coming soon! Use the "party" command to open the party GUI.',
                            userRequest: 'try to add the command party where you can open a gui to make a party and there is many minigames for now only have the minigame draw together'
                        });
                        localStorage.setItem('changelog', JSON.stringify(entries));
                    }
                    // Add Password Game entry
                    if (!hasPasswordGame) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ” Added Password Game to Desktop',
                            description: 'Added a Password Game (word guessing game) to the Remote Desktop App Store. Guess the 5-letter password with color-coded feedback. Green means correct letter in correct position, red means letter exists but wrong position. Install it from the App Store in Remote Desktop, then double-click the Password Game icon to play.',
                            userRequest: 'add the password game to remote desktop'
                        });
                    }
                    // Add Suggestions entry
                    if (!hasSuggestions) {
                        entries.push({
                            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                            title: 'ðŸ’¡ Added Suggestions System',
                            description: 'Added a Suggestions area where users can view and create suggestions for the website. Features include: viewing all suggestions sorted by likes, liking suggestions, creating new suggestions, and real-time updates via Firebase. Access it using the "suggest" command.',
                            userRequest: 'a Suggestion area where you can like and see other peoples suggestions and suggest stuff by doing the suggest command to open a gui with everyones sugestions and to make your own'
                        });
                    }
                    localStorage.setItem('changelog', JSON.stringify(entries));
                }
                return entries;
            }
            // Initialize with Snake game entry
            const initialEntries = [{
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                title: 'ðŸ Added Snake Game to Desktop',
                description: 'Added a classic Snake game to the Remote Desktop App Store. The game features a 16x16 grid with a black snake and 3 red apples. Install it from the App Store in Remote Desktop, then double-click the Snake icon to play. Use arrow keys to control the snake.',
                userRequest: 'Add a classic snake game for the desktop section where it\'s a 16x16 and there is 3 red boxes (apples) and you black'
            }];
            localStorage.setItem('changelog', JSON.stringify(initialEntries));
            return initialEntries;
        }
        
        function addChangelogEntry(title, description, userRequest = '') {
            const entries = getChangelogEntries();
            entries.push({
                date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
                title: title,
                description: description,
                userRequest: userRequest
            });
            localStorage.setItem('changelog', JSON.stringify(entries));
            
            // Reload changelog if the page is currently open
            const changelogPage = document.getElementById('changelogPage');
            if (changelogPage && !changelogPage.classList.contains('hidden')) {
                loadChangelog();
            }
        }
        
        // Initialize changelog on page load if it doesn't exist
        getChangelogEntries();
        
        // Suggestion system
        let likedSuggestions = new Set();
        
        // Load liked suggestions from localStorage
        function loadLikedSuggestions() {
            const saved = localStorage.getItem('likedSuggestions');
            if (saved) {
                likedSuggestions = new Set(JSON.parse(saved));
            }
        }
        
        // Save liked suggestions to localStorage
        function saveLikedSuggestions() {
            localStorage.setItem('likedSuggestions', JSON.stringify(Array.from(likedSuggestions)));
        }
        
        // Load suggestions from Firebase or localStorage
        function loadSuggestions() {
            const suggestionsContent = document.getElementById('suggestions-content');
            if (!suggestionsContent) return;
            
            suggestionsContent.innerHTML = '<p style="color: #8b949e; text-align: center; padding: 20px;">Loading suggestions...</p>';
            
            // Update character count
            const input = document.getElementById('suggestion-input');
            const charCount = document.getElementById('suggestion-char-count');
            if (input && charCount) {
                input.addEventListener('input', () => {
                    charCount.textContent = input.value.length + '/500 characters';
                });
            }
            
            loadLikedSuggestions();
            
            if (database) {
                // Load from Firebase with real-time updates
                try {
                    database.ref('suggestions').once('value', (snapshot) => {
                        const suggestions = [];
                        snapshot.forEach((child) => {
                            const data = child.val();
                            if (data) {
                                suggestions.push({
                                    id: child.key,
                                    ...data
                                });
                            }
                        });
                        // Sort by likes (descending), then by timestamp (descending)
                        suggestions.sort((a, b) => {
                            const likesA = a.likes || 0;
                            const likesB = b.likes || 0;
                            if (likesB !== likesA) return likesB - likesA;
                            return (b.timestamp || 0) - (a.timestamp || 0);
                        });
                        renderSuggestions(suggestions);
                    }, (error) => {
                        console.error('Error loading suggestions from Firebase:', error);
                        // Fallback to localStorage
                        const saved = localStorage.getItem('suggestions');
                        const suggestions = saved ? JSON.parse(saved) : [];
                        renderSuggestions(suggestions);
                    });
                    
                    // Also set up real-time listener
                    database.ref('suggestions').on('value', (snapshot) => {
                        const suggestions = [];
                        snapshot.forEach((child) => {
                            const data = child.val();
                            if (data) {
                                suggestions.push({
                                    id: child.key,
                                    ...data
                                });
                            }
                        });
                        // Sort by likes (descending), then by timestamp (descending)
                        suggestions.sort((a, b) => {
                            const likesA = a.likes || 0;
                            const likesB = b.likes || 0;
                            if (likesB !== likesA) return likesB - likesA;
                            return (b.timestamp || 0) - (a.timestamp || 0);
                        });
                        renderSuggestions(suggestions);
                    });
                } catch (error) {
                    console.error('Error loading suggestions:', error);
                    // Fallback to localStorage
                    const saved = localStorage.getItem('suggestions');
                    const suggestions = saved ? JSON.parse(saved) : [];
                    renderSuggestions(suggestions);
                }
            } else {
                // Load from localStorage fallback
                const saved = localStorage.getItem('suggestions');
                const suggestions = saved ? JSON.parse(saved) : [];
                renderSuggestions(suggestions);
            }
        }
        
        // Render suggestions
        function renderSuggestions(suggestions) {
            const suggestionsContent = document.getElementById('suggestions-content');
            if (!suggestionsContent) return;
            
            if (suggestions.length === 0) {
                suggestionsContent.innerHTML = '<p style="color: #8b949e; text-align: center; padding: 20px;">No suggestions yet. Be the first to suggest something!</p>';
                return;
            }
            
            let html = '';
            suggestions.forEach(suggestion => {
                const isLiked = likedSuggestions.has(suggestion.id);
                const likes = suggestion.likes || 0;
                const author = suggestion.author || 'Anonymous';
                const timestamp = suggestion.timestamp ? new Date(suggestion.timestamp).toLocaleString() : 'Unknown';
                
                html += `
                    <div style="background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <p style="color: #c9d1d9; font-size: 14px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">${escapeHtml(suggestion.text)}</p>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid #30363d;">
                            <div style="color: #8b949e; font-size: 12px;">
                                <span>By: ${escapeHtml(author)}</span>
                                <span style="margin-left: 15px;">${timestamp}</span>
                            </div>
                            <button onclick="toggleLikeSuggestion('${suggestion.id}')" style="background: ${isLiked ? '#238636' : '#21262d'}; color: white; border: 1px solid #30363d; border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px;">
                                <span>${isLiked ? 'â¤ï¸' : 'ðŸ¤'}</span>
                                <span>${likes}</span>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            suggestionsContent.innerHTML = html;
        }
        
        // Submit suggestion
        function submitSuggestion() {
            const input = document.getElementById('suggestion-input');
            if (!input) return;
            
            const text = input.value.trim();
            if (!text) {
                alert('Please enter a suggestion!');
                return;
            }
            
            if (text.length > 500) {
                alert('Suggestion is too long! Maximum 500 characters.');
                return;
            }
            
            const userId = getUserId();
            const author = userId || 'Anonymous';
            const timestamp = Date.now();
            const suggestion = {
                text: text,
                author: author,
                timestamp: timestamp,
                likes: 0
            };
            
            if (database) {
                // Save to Firebase
                const newSuggestionRef = database.ref('suggestions').push();
                newSuggestionRef.set(suggestion).then(() => {
                    input.value = '';
                    const charCount = document.getElementById('suggestion-char-count');
                    if (charCount) charCount.textContent = '0/500 characters';
                    loadSuggestions();
                }).catch((error) => {
                    console.error('Error saving suggestion:', error);
                    alert('Failed to save suggestion. Please try again.');
                });
            } else {
                // Save to localStorage fallback
                const saved = localStorage.getItem('suggestions');
                const suggestions = saved ? JSON.parse(saved) : [];
                const id = 'suggestion_' + timestamp;
                suggestions.push({
                    id: id,
                    ...suggestion
                });
                localStorage.setItem('suggestions', JSON.stringify(suggestions));
                input.value = '';
                const charCount = document.getElementById('suggestion-char-count');
                if (charCount) charCount.textContent = '0/500 characters';
                loadSuggestions();
            }
        }
        
        // Toggle like on suggestion
        function toggleLikeSuggestion(suggestionId) {
            loadLikedSuggestions();
            
            if (likedSuggestions.has(suggestionId)) {
                // Unlike
                likedSuggestions.delete(suggestionId);
                updateSuggestionLikes(suggestionId, -1);
            } else {
                // Like
                likedSuggestions.add(suggestionId);
                updateSuggestionLikes(suggestionId, 1);
            }
            
            saveLikedSuggestions();
            loadSuggestions();
        }
        
        // Update suggestion likes count
        function updateSuggestionLikes(suggestionId, delta) {
            if (database) {
                // Update in Firebase
                database.ref(`suggestions/${suggestionId}`).transaction((suggestion) => {
                    if (suggestion) {
                        suggestion.likes = (suggestion.likes || 0) + delta;
                        if (suggestion.likes < 0) suggestion.likes = 0;
                    }
                    return suggestion;
                });
            } else {
                // Update in localStorage
                const saved = localStorage.getItem('suggestions');
                if (saved) {
                    const suggestions = JSON.parse(saved);
                    const index = suggestions.findIndex(s => s.id === suggestionId);
                    if (index !== -1) {
                        suggestions[index].likes = (suggestions[index].likes || 0) + delta;
                        if (suggestions[index].likes < 0) suggestions[index].likes = 0;
                        localStorage.setItem('suggestions', JSON.stringify(suggestions));
                    }
                }
            }
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Make functions globally accessible
        window.submitSuggestion = submitSuggestion;
        window.toggleLikeSuggestion = toggleLikeSuggestion;
        
        // Load liked suggestions on page load
        loadLikedSuggestions();
    </script>
</body>
</html>
